<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyspark package &mdash; PySpark 2.0.0 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/pyspark.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '2.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/pyspark.js"></script>
    <link rel="top" title="PySpark 2.0.0 documentation" href="index.html" />
    <link rel="next" title="pyspark.sql module" href="pyspark.sql.html" />
    <link rel="prev" title="Welcome to Spark Python API Docs!" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="pyspark.sql.html" title="pyspark.sql module"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="index.html" title="Welcome to Spark Python API Docs!"
             accesskey="P">previous</a> |</li>
    
        <li><a href="index.html">PySpark 2.0.0 documentation</a> &raquo;</li>
 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="pyspark-package">
<h1>pyspark package<a class="headerlink" href="#pyspark-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="pyspark.sql.html">pyspark.sql module</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyspark.streaming.html">pyspark.streaming module</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyspark.ml.html">pyspark.ml package</a></li>
<li class="toctree-l1"><a class="reference internal" href="pyspark.mllib.html">pyspark.mllib package</a></li>
</ul>
</div>
</div>
<div class="section" id="module-pyspark">
<span id="contents"></span><h2>Contents<a class="headerlink" href="#module-pyspark" title="Permalink to this headline">¶</a></h2>
<p>PySpark is the Python API for Spark.</p>
<p>Public classes:</p>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#pyspark.SparkContext" title="pyspark.SparkContext"><tt class="xref py py-class docutils literal"><span class="pre">SparkContext</span></tt></a>:</dt>
<dd><p class="first last">Main entry point for Spark functionality.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#pyspark.RDD" title="pyspark.RDD"><tt class="xref py py-class docutils literal"><span class="pre">RDD</span></tt></a>:</dt>
<dd><p class="first last">A Resilient Distributed Dataset (RDD), the basic abstraction in Spark.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#pyspark.Broadcast" title="pyspark.Broadcast"><tt class="xref py py-class docutils literal"><span class="pre">Broadcast</span></tt></a>:</dt>
<dd><p class="first last">A broadcast variable that gets reused across tasks.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#pyspark.Accumulator" title="pyspark.Accumulator"><tt class="xref py py-class docutils literal"><span class="pre">Accumulator</span></tt></a>:</dt>
<dd><p class="first last">An &#8220;add-only&#8221; shared variable that tasks can only add values to.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#pyspark.SparkConf" title="pyspark.SparkConf"><tt class="xref py py-class docutils literal"><span class="pre">SparkConf</span></tt></a>:</dt>
<dd><p class="first last">For configuring Spark.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#pyspark.SparkFiles" title="pyspark.SparkFiles"><tt class="xref py py-class docutils literal"><span class="pre">SparkFiles</span></tt></a>:</dt>
<dd><p class="first last">Access files shipped with jobs.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><a class="reference internal" href="#pyspark.StorageLevel" title="pyspark.StorageLevel"><tt class="xref py py-class docutils literal"><span class="pre">StorageLevel</span></tt></a>:</dt>
<dd><p class="first last">Finer-grained cache persistence levels.</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<dl class="class">
<dt id="pyspark.SparkConf">
<em class="property">class </em><tt class="descclassname">pyspark.</tt><tt class="descname">SparkConf</tt><big>(</big><em>loadDefaults=True</em>, <em>_jvm=None</em>, <em>_jconf=None</em><big>)</big><a class="headerlink" href="#pyspark.SparkConf" title="Permalink to this definition">¶</a></dt>
<dd><p>Configuration for a Spark application. Used to set various Spark
parameters as key-value pairs.</p>
<p>Most of the time, you would create a SparkConf object with
<a class="reference internal" href="#pyspark.SparkConf" title="pyspark.SparkConf"><tt class="xref py py-class docutils literal"><span class="pre">SparkConf()</span></tt></a>, which will load values from <cite>spark.*</cite> Java system
properties as well. In this case, any parameters you set directly on
the <a class="reference internal" href="#pyspark.SparkConf" title="pyspark.SparkConf"><tt class="xref py py-class docutils literal"><span class="pre">SparkConf</span></tt></a> object take priority over system properties.</p>
<p>For unit tests, you can also call <tt class="xref py py-class docutils literal"><span class="pre">SparkConf(false)</span></tt> to skip
loading external settings and get the same configuration no matter
what the system properties are.</p>
<p>All setter methods in this class support chaining. For example,
you can write <cite>conf.setMaster(&#8220;local&#8221;).setAppName(&#8220;My app&#8221;)</cite>.</p>
<p>Note that once a SparkConf object is passed to Spark, it is cloned
and can no longer be modified by the user.</p>
<dl class="method">
<dt id="pyspark.SparkConf.contains">
<tt class="descname">contains</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#pyspark.SparkConf.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Does this configuration contain a given key?</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkConf.get">
<tt class="descname">get</tt><big>(</big><em>key</em>, <em>defaultValue=None</em><big>)</big><a class="headerlink" href="#pyspark.SparkConf.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the configured value for some key, or return a default otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkConf.getAll">
<tt class="descname">getAll</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.SparkConf.getAll" title="Permalink to this definition">¶</a></dt>
<dd><p>Get all values as a list of key-value pairs.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkConf.set">
<tt class="descname">set</tt><big>(</big><em>key</em>, <em>value</em><big>)</big><a class="headerlink" href="#pyspark.SparkConf.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a configuration property.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkConf.setAll">
<tt class="descname">setAll</tt><big>(</big><em>pairs</em><big>)</big><a class="headerlink" href="#pyspark.SparkConf.setAll" title="Permalink to this definition">¶</a></dt>
<dd><p>Set multiple parameters, passed as a list of key-value pairs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>pairs</strong> &#8211; list of key-value pairs to set</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkConf.setAppName">
<tt class="descname">setAppName</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyspark.SparkConf.setAppName" title="Permalink to this definition">¶</a></dt>
<dd><p>Set application name.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkConf.setExecutorEnv">
<tt class="descname">setExecutorEnv</tt><big>(</big><em>key=None</em>, <em>value=None</em>, <em>pairs=None</em><big>)</big><a class="headerlink" href="#pyspark.SparkConf.setExecutorEnv" title="Permalink to this definition">¶</a></dt>
<dd><p>Set an environment variable to be passed to executors.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkConf.setIfMissing">
<tt class="descname">setIfMissing</tt><big>(</big><em>key</em>, <em>value</em><big>)</big><a class="headerlink" href="#pyspark.SparkConf.setIfMissing" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a configuration property, if not already set.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkConf.setMaster">
<tt class="descname">setMaster</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyspark.SparkConf.setMaster" title="Permalink to this definition">¶</a></dt>
<dd><p>Set master URL to connect to.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkConf.setSparkHome">
<tt class="descname">setSparkHome</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyspark.SparkConf.setSparkHome" title="Permalink to this definition">¶</a></dt>
<dd><p>Set path where Spark is installed on worker nodes.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkConf.toDebugString">
<tt class="descname">toDebugString</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.SparkConf.toDebugString" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a printable version of the configuration, as a list of
key=value pairs, one per line.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyspark.SparkContext">
<em class="property">class </em><tt class="descclassname">pyspark.</tt><tt class="descname">SparkContext</tt><big>(</big><em>master=None</em>, <em>appName=None</em>, <em>sparkHome=None</em>, <em>pyFiles=None</em>, <em>environment=None</em>, <em>batchSize=0</em>, <em>serializer=PickleSerializer()</em>, <em>conf=None</em>, <em>gateway=None</em>, <em>jsc=None</em>, <em>profiler_cls=&lt;class 'pyspark.profiler.BasicProfiler'&gt;</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext" title="Permalink to this definition">¶</a></dt>
<dd><p>Main entry point for Spark functionality. A SparkContext represents the
connection to a Spark cluster, and can be used to create <a class="reference internal" href="#pyspark.RDD" title="pyspark.RDD"><tt class="xref py py-class docutils literal"><span class="pre">RDD</span></tt></a> and
broadcast variables on that cluster.</p>
<dl class="attribute">
<dt id="pyspark.SparkContext.PACKAGE_EXTENSIONS">
<tt class="descname">PACKAGE_EXTENSIONS</tt><em class="property"> = ('.zip', '.egg', '.jar')</em><a class="headerlink" href="#pyspark.SparkContext.PACKAGE_EXTENSIONS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.accumulator">
<tt class="descname">accumulator</tt><big>(</big><em>value</em>, <em>accum_param=None</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.accumulator" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an <a class="reference internal" href="#pyspark.Accumulator" title="pyspark.Accumulator"><tt class="xref py py-class docutils literal"><span class="pre">Accumulator</span></tt></a> with the given initial value, using a given
<a class="reference internal" href="#pyspark.AccumulatorParam" title="pyspark.AccumulatorParam"><tt class="xref py py-class docutils literal"><span class="pre">AccumulatorParam</span></tt></a> helper object to define how to add values of the
data type if provided. Default AccumulatorParams are used for integers
and floating-point numbers if you do not provide one. For other types,
a custom AccumulatorParam can be used.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.addFile">
<tt class="descname">addFile</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.addFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a file to be downloaded with this Spark job on every node.
The <tt class="xref py py-class docutils literal"><span class="pre">path</span></tt> passed can be either a local file, a file in HDFS
(or other Hadoop-supported filesystems), or an HTTP, HTTPS or
FTP URI.</p>
<p>To access the file in Spark jobs, use
L{SparkFiles.get(fileName)&lt;pyspark.files.SparkFiles.get&gt;} with the
filename to find its download location.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyspark</span> <span class="kn">import</span> <span class="n">SparkFiles</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tempdir</span><span class="p">,</span> <span class="s">&quot;test.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">testFile</span><span class="p">:</span>
<span class="gp">... </span>   <span class="n">_</span> <span class="o">=</span> <span class="n">testFile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;100&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">addFile</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">iterator</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">SparkFiles</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&quot;test.txt&quot;</span><span class="p">))</span> <span class="k">as</span> <span class="n">testFile</span><span class="p">:</span>
<span class="gp">... </span>       <span class="n">fileVal</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">testFile</span><span class="o">.</span><span class="n">readline</span><span class="p">())</span>
<span class="gp">... </span>       <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">fileVal</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">mapPartitions</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[100, 200, 300, 400]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.addPyFile">
<tt class="descname">addPyFile</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.addPyFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a .py or .zip dependency for all tasks to be executed on this
SparkContext in the future.  The <tt class="xref py py-class docutils literal"><span class="pre">path</span></tt> passed can be either a local
file, a file in HDFS (or other Hadoop-supported filesystems), or an
HTTP, HTTPS or FTP URI.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyspark.SparkContext.applicationId">
<tt class="descname">applicationId</tt><a class="headerlink" href="#pyspark.SparkContext.applicationId" title="Permalink to this definition">¶</a></dt>
<dd><p>A unique identifier for the Spark application.
Its format depends on the scheduler implementation.</p>
<ul class="simple">
<li>in case of local spark app something like &#8216;local-1433865536131&#8217;</li>
<li>in case of YARN something like &#8216;application_1433865536131_34483&#8217;</li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">applicationId</span>  
<span class="go">u&#39;local-...&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.binaryFiles">
<tt class="descname">binaryFiles</tt><big>(</big><em>path</em>, <em>minPartitions=None</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.binaryFiles" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Experimental</p>
</div>
<p>Read a directory of binary files from HDFS, a local file system
(available on all nodes), or any Hadoop-supported file system URI
as a byte array. Each file is read as a single record and returned
in a key-value pair, where the key is the path of each file, the
value is the content of each file.</p>
<p>Note: Small files are preferred, large file is also allowable, but
may cause bad performance.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.binaryRecords">
<tt class="descname">binaryRecords</tt><big>(</big><em>path</em>, <em>recordLength</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.binaryRecords" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Experimental</p>
</div>
<p>Load data from a flat binary file, assuming each record is a set of numbers
with the specified numerical format (see ByteBuffer), and the number of
bytes per record is constant.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>path</strong> &#8211; Directory to the input data files</li>
<li><strong>recordLength</strong> &#8211; The length at which to split the records</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.broadcast">
<tt class="descname">broadcast</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.broadcast" title="Permalink to this definition">¶</a></dt>
<dd><p>Broadcast a read-only variable to the cluster, returning a
L{Broadcast&lt;pyspark.broadcast.Broadcast&gt;}
object for reading it in distributed functions. The variable will
be sent to each cluster only once.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.cancelAllJobs">
<tt class="descname">cancelAllJobs</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.SparkContext.cancelAllJobs" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel all jobs that have been scheduled or are running.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.cancelJobGroup">
<tt class="descname">cancelJobGroup</tt><big>(</big><em>groupId</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.cancelJobGroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Cancel active jobs for the specified group. See <a class="reference internal" href="#pyspark.SparkContext.setJobGroup" title="pyspark.SparkContext.setJobGroup"><tt class="xref py py-class docutils literal"><span class="pre">SparkContext.setJobGroup</span></tt></a>
for more information.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.clearFiles">
<tt class="descname">clearFiles</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.SparkContext.clearFiles" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear the job&#8217;s list of files added by <a class="reference internal" href="#pyspark.SparkContext.addFile" title="pyspark.SparkContext.addFile"><tt class="xref py py-class docutils literal"><span class="pre">addFile</span></tt></a> or <a class="reference internal" href="#pyspark.SparkContext.addPyFile" title="pyspark.SparkContext.addPyFile"><tt class="xref py py-class docutils literal"><span class="pre">addPyFile</span></tt></a> so
that they do not get downloaded to any new nodes.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyspark.SparkContext.defaultMinPartitions">
<tt class="descname">defaultMinPartitions</tt><a class="headerlink" href="#pyspark.SparkContext.defaultMinPartitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Default min number of partitions for Hadoop RDDs when not given by user</p>
</dd></dl>

<dl class="attribute">
<dt id="pyspark.SparkContext.defaultParallelism">
<tt class="descname">defaultParallelism</tt><a class="headerlink" href="#pyspark.SparkContext.defaultParallelism" title="Permalink to this definition">¶</a></dt>
<dd><p>Default level of parallelism to use when not given by user (e.g. for
reduce tasks)</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.dump_profiles">
<tt class="descname">dump_profiles</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.dump_profiles" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump the profile stats into directory <cite>path</cite></p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.emptyRDD">
<tt class="descname">emptyRDD</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.SparkContext.emptyRDD" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an RDD that has no partitions or elements.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.getConf">
<tt class="descname">getConf</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.SparkContext.getConf" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.getLocalProperty">
<tt class="descname">getLocalProperty</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.getLocalProperty" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a local property set in this thread, or null if it is missing. See
<a class="reference internal" href="#pyspark.SparkContext.setLocalProperty" title="pyspark.SparkContext.setLocalProperty"><tt class="xref py py-class docutils literal"><span class="pre">setLocalProperty</span></tt></a></p>
</dd></dl>

<dl class="classmethod">
<dt id="pyspark.SparkContext.getOrCreate">
<em class="property">classmethod </em><tt class="descname">getOrCreate</tt><big>(</big><em>conf=None</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.getOrCreate" title="Permalink to this definition">¶</a></dt>
<dd><p>Get or instantiate a SparkContext and register it as a singleton object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>conf</strong> &#8211; SparkConf (optional)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.hadoopFile">
<tt class="descname">hadoopFile</tt><big>(</big><em>path</em>, <em>inputFormatClass</em>, <em>keyClass</em>, <em>valueClass</em>, <em>keyConverter=None</em>, <em>valueConverter=None</em>, <em>conf=None</em>, <em>batchSize=0</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.hadoopFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read an &#8216;old&#8217; Hadoop InputFormat with arbitrary key and value class from HDFS,
a local file system (available on all nodes), or any Hadoop-supported file system URI.
The mechanism is the same as for sc.sequenceFile.</p>
<p>A Hadoop configuration can be passed in as a Python dict. This will be converted into a
Configuration in Java.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>path</strong> &#8211; path to Hadoop file</li>
<li><strong>inputFormatClass</strong> &#8211; fully qualified classname of Hadoop InputFormat
(e.g. &#8220;org.apache.hadoop.mapred.TextInputFormat&#8221;)</li>
<li><strong>keyClass</strong> &#8211; fully qualified classname of key Writable class
(e.g. &#8220;org.apache.hadoop.io.Text&#8221;)</li>
<li><strong>valueClass</strong> &#8211; fully qualified classname of value Writable class
(e.g. &#8220;org.apache.hadoop.io.LongWritable&#8221;)</li>
<li><strong>keyConverter</strong> &#8211; (None by default)</li>
<li><strong>valueConverter</strong> &#8211; (None by default)</li>
<li><strong>conf</strong> &#8211; Hadoop configuration, passed in as a dict
(None by default)</li>
<li><strong>batchSize</strong> &#8211; The number of Python objects represented as a single
Java object. (default 0, choose batchSize automatically)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.hadoopRDD">
<tt class="descname">hadoopRDD</tt><big>(</big><em>inputFormatClass</em>, <em>keyClass</em>, <em>valueClass</em>, <em>keyConverter=None</em>, <em>valueConverter=None</em>, <em>conf=None</em>, <em>batchSize=0</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.hadoopRDD" title="Permalink to this definition">¶</a></dt>
<dd><p>Read an &#8216;old&#8217; Hadoop InputFormat with arbitrary key and value class, from an arbitrary
Hadoop configuration, which is passed in as a Python dict.
This will be converted into a Configuration in Java.
The mechanism is the same as for sc.sequenceFile.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>inputFormatClass</strong> &#8211; fully qualified classname of Hadoop InputFormat
(e.g. &#8220;org.apache.hadoop.mapred.TextInputFormat&#8221;)</li>
<li><strong>keyClass</strong> &#8211; fully qualified classname of key Writable class
(e.g. &#8220;org.apache.hadoop.io.Text&#8221;)</li>
<li><strong>valueClass</strong> &#8211; fully qualified classname of value Writable class
(e.g. &#8220;org.apache.hadoop.io.LongWritable&#8221;)</li>
<li><strong>keyConverter</strong> &#8211; (None by default)</li>
<li><strong>valueConverter</strong> &#8211; (None by default)</li>
<li><strong>conf</strong> &#8211; Hadoop configuration, passed in as a dict
(None by default)</li>
<li><strong>batchSize</strong> &#8211; The number of Python objects represented as a single
Java object. (default 0, choose batchSize automatically)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.newAPIHadoopFile">
<tt class="descname">newAPIHadoopFile</tt><big>(</big><em>path</em>, <em>inputFormatClass</em>, <em>keyClass</em>, <em>valueClass</em>, <em>keyConverter=None</em>, <em>valueConverter=None</em>, <em>conf=None</em>, <em>batchSize=0</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.newAPIHadoopFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a &#8216;new API&#8217; Hadoop InputFormat with arbitrary key and value class from HDFS,
a local file system (available on all nodes), or any Hadoop-supported file system URI.
The mechanism is the same as for sc.sequenceFile.</p>
<p>A Hadoop configuration can be passed in as a Python dict. This will be converted into a
Configuration in Java</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>path</strong> &#8211; path to Hadoop file</li>
<li><strong>inputFormatClass</strong> &#8211; fully qualified classname of Hadoop InputFormat
(e.g. &#8220;org.apache.hadoop.mapreduce.lib.input.TextInputFormat&#8221;)</li>
<li><strong>keyClass</strong> &#8211; fully qualified classname of key Writable class
(e.g. &#8220;org.apache.hadoop.io.Text&#8221;)</li>
<li><strong>valueClass</strong> &#8211; fully qualified classname of value Writable class
(e.g. &#8220;org.apache.hadoop.io.LongWritable&#8221;)</li>
<li><strong>keyConverter</strong> &#8211; (None by default)</li>
<li><strong>valueConverter</strong> &#8211; (None by default)</li>
<li><strong>conf</strong> &#8211; Hadoop configuration, passed in as a dict
(None by default)</li>
<li><strong>batchSize</strong> &#8211; The number of Python objects represented as a single
Java object. (default 0, choose batchSize automatically)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.newAPIHadoopRDD">
<tt class="descname">newAPIHadoopRDD</tt><big>(</big><em>inputFormatClass</em>, <em>keyClass</em>, <em>valueClass</em>, <em>keyConverter=None</em>, <em>valueConverter=None</em>, <em>conf=None</em>, <em>batchSize=0</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.newAPIHadoopRDD" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a &#8216;new API&#8217; Hadoop InputFormat with arbitrary key and value class, from an arbitrary
Hadoop configuration, which is passed in as a Python dict.
This will be converted into a Configuration in Java.
The mechanism is the same as for sc.sequenceFile.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>inputFormatClass</strong> &#8211; fully qualified classname of Hadoop InputFormat
(e.g. &#8220;org.apache.hadoop.mapreduce.lib.input.TextInputFormat&#8221;)</li>
<li><strong>keyClass</strong> &#8211; fully qualified classname of key Writable class
(e.g. &#8220;org.apache.hadoop.io.Text&#8221;)</li>
<li><strong>valueClass</strong> &#8211; fully qualified classname of value Writable class
(e.g. &#8220;org.apache.hadoop.io.LongWritable&#8221;)</li>
<li><strong>keyConverter</strong> &#8211; (None by default)</li>
<li><strong>valueConverter</strong> &#8211; (None by default)</li>
<li><strong>conf</strong> &#8211; Hadoop configuration, passed in as a dict
(None by default)</li>
<li><strong>batchSize</strong> &#8211; The number of Python objects represented as a single
Java object. (default 0, choose batchSize automatically)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.parallelize">
<tt class="descname">parallelize</tt><big>(</big><em>c</em>, <em>numSlices=None</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.parallelize" title="Permalink to this definition">¶</a></dt>
<dd><p>Distribute a local Python collection to form an RDD. Using xrange
is recommended if the input represents a range for performance.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">glom</span><span class="p">()</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[[0], [2], [3], [4], [6]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">glom</span><span class="p">()</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[[], [0], [], [2], [4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.pickleFile">
<tt class="descname">pickleFile</tt><big>(</big><em>name</em>, <em>minPartitions=None</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.pickleFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Load an RDD previously saved using <a class="reference internal" href="#pyspark.RDD.saveAsPickleFile" title="pyspark.RDD.saveAsPickleFile"><tt class="xref py py-class docutils literal"><span class="pre">RDD.saveAsPickleFile</span></tt></a> method.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tmpFile</span> <span class="o">=</span> <span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">delete</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tmpFile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span><span class="o">.</span><span class="n">saveAsPickleFile</span><span class="p">(</span><span class="n">tmpFile</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">pickleFile</span><span class="p">(</span><span class="n">tmpFile</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.range">
<tt class="descname">range</tt><big>(</big><em>start</em>, <em>end=None</em>, <em>step=1</em>, <em>numSlices=None</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.range" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new RDD of int containing elements from <cite>start</cite> to <cite>end</cite>
(exclusive), increased by <cite>step</cite> every element. Can be called the same
way as python&#8217;s built-in range() function. If called with a single argument,
the argument is interpreted as <cite>end</cite>, and <cite>start</cite> is set to 0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>start</strong> &#8211; the start value</li>
<li><strong>end</strong> &#8211; the end value (exclusive)</li>
<li><strong>step</strong> &#8211; the incremental step (default: 1)</li>
<li><strong>numSlices</strong> &#8211; the number of partitions of the new RDD</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An RDD of int</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[1, 3, 5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.runJob">
<tt class="descname">runJob</tt><big>(</big><em>rdd</em>, <em>partitionFunc</em>, <em>partitions=None</em>, <em>allowLocal=False</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.runJob" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes the given partitionFunc on the specified set of partitions,
returning the result as an array of elements.</p>
<p>If &#8216;partitions&#8217; is not specified, this will run over all partitions.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">myRDD</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">runJob</span><span class="p">(</span><span class="n">myRDD</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">part</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">part</span><span class="p">])</span>
<span class="go">[0, 1, 4, 9, 16, 25]</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">myRDD</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">runJob</span><span class="p">(</span><span class="n">myRDD</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">part</span><span class="p">:</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">part</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="bp">True</span><span class="p">)</span>
<span class="go">[0, 1, 16, 25]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.sequenceFile">
<tt class="descname">sequenceFile</tt><big>(</big><em>path</em>, <em>keyClass=None</em>, <em>valueClass=None</em>, <em>keyConverter=None</em>, <em>valueConverter=None</em>, <em>minSplits=None</em>, <em>batchSize=0</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.sequenceFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a Hadoop SequenceFile with arbitrary key and value Writable class from HDFS,
a local file system (available on all nodes), or any Hadoop-supported file system URI.
The mechanism is as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li>A Java RDD is created from the SequenceFile or other InputFormat, and the key
and value Writable classes</li>
<li>Serialization is attempted via Pyrolite pickling</li>
<li>If this fails, the fallback is to call &#8216;toString&#8217; on each key and value</li>
<li><a class="reference internal" href="#pyspark.PickleSerializer" title="pyspark.PickleSerializer"><tt class="xref py py-class docutils literal"><span class="pre">PickleSerializer</span></tt></a> is used to deserialize pickled objects on the Python side</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>path</strong> &#8211; path to sequncefile</li>
<li><strong>keyClass</strong> &#8211; fully qualified classname of key Writable class
(e.g. &#8220;org.apache.hadoop.io.Text&#8221;)</li>
<li><strong>valueClass</strong> &#8211; fully qualified classname of value Writable class
(e.g. &#8220;org.apache.hadoop.io.LongWritable&#8221;)</li>
<li><strong>keyConverter</strong> &#8211; </li>
<li><strong>valueConverter</strong> &#8211; </li>
<li><strong>minSplits</strong> &#8211; minimum splits in dataset
(default min(2, sc.defaultParallelism))</li>
<li><strong>batchSize</strong> &#8211; The number of Python objects represented as a single
Java object. (default 0, choose batchSize automatically)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.setCheckpointDir">
<tt class="descname">setCheckpointDir</tt><big>(</big><em>dirName</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.setCheckpointDir" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the directory under which RDDs are going to be checkpointed. The
directory must be a HDFS path if running on a cluster.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.setJobGroup">
<tt class="descname">setJobGroup</tt><big>(</big><em>groupId</em>, <em>description</em>, <em>interruptOnCancel=False</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.setJobGroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Assigns a group ID to all the jobs started by this thread until the group ID is set to a
different value or cleared.</p>
<p>Often, a unit of execution in an application consists of multiple Spark actions or jobs.
Application programmers can use this method to group all those jobs together and give a
group description. Once set, the Spark web UI will associate such jobs with this group.</p>
<p>The application can use <a class="reference internal" href="#pyspark.SparkContext.cancelJobGroup" title="pyspark.SparkContext.cancelJobGroup"><tt class="xref py py-class docutils literal"><span class="pre">SparkContext.cancelJobGroup</span></tt></a> to cancel all
running jobs in this group.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">threading</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">sleep</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="s">&quot;Not Set&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lock</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Lock</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">map_func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">sleep</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Task should have been cancelled&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">start_job</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">global</span> <span class="n">result</span>
<span class="gp">... </span>    <span class="k">try</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">sc</span><span class="o">.</span><span class="n">setJobGroup</span><span class="p">(</span><span class="s">&quot;job_to_cancel&quot;</span><span class="p">,</span> <span class="s">&quot;some description&quot;</span><span class="p">)</span>
<span class="gp">... </span>        <span class="n">result</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">map_func</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="gp">... </span>    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">result</span> <span class="o">=</span> <span class="s">&quot;Cancelled&quot;</span>
<span class="gp">... </span>    <span class="n">lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">stop_job</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">sc</span><span class="o">.</span><span class="n">cancelJobGroup</span><span class="p">(</span><span class="s">&quot;job_to_cancel&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">supress</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">supress</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">start_job</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,))</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">supress</span> <span class="o">=</span> <span class="n">threading</span><span class="o">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">stop_job</span><span class="p">)</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">supress</span> <span class="o">=</span> <span class="n">lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">Cancelled</span>
</pre></div>
</div>
<p>If interruptOnCancel is set to true for the job group, then job cancellation will result
in Thread.interrupt() being called on the job&#8217;s executor threads. This is useful to help
ensure that the tasks are actually stopped in a timely manner, but is off by default due
to HDFS-1208, where HDFS may respond to Thread.interrupt() by marking nodes as dead.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.setLocalProperty">
<tt class="descname">setLocalProperty</tt><big>(</big><em>key</em>, <em>value</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.setLocalProperty" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a local property that affects jobs submitted from this thread, such as the
Spark fair scheduler pool.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.setLogLevel">
<tt class="descname">setLogLevel</tt><big>(</big><em>logLevel</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.setLogLevel" title="Permalink to this definition">¶</a></dt>
<dd><p>Control our logLevel. This overrides any user-defined log settings.
Valid log levels include: ALL, DEBUG, ERROR, FATAL, INFO, OFF, TRACE, WARN</p>
</dd></dl>

<dl class="classmethod">
<dt id="pyspark.SparkContext.setSystemProperty">
<em class="property">classmethod </em><tt class="descname">setSystemProperty</tt><big>(</big><em>key</em>, <em>value</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.setSystemProperty" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a Java system property, such as spark.executor.memory. This must
must be invoked before instantiating SparkContext.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.show_profiles">
<tt class="descname">show_profiles</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.SparkContext.show_profiles" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the profile stats to stdout</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.sparkUser">
<tt class="descname">sparkUser</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.SparkContext.sparkUser" title="Permalink to this definition">¶</a></dt>
<dd><p>Get SPARK_USER for user who is running SparkContext.</p>
</dd></dl>

<dl class="attribute">
<dt id="pyspark.SparkContext.startTime">
<tt class="descname">startTime</tt><a class="headerlink" href="#pyspark.SparkContext.startTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the epoch time when the Spark Context was started.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.statusTracker">
<tt class="descname">statusTracker</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.SparkContext.statusTracker" title="Permalink to this definition">¶</a></dt>
<dd><p>Return <a class="reference internal" href="#pyspark.StatusTracker" title="pyspark.StatusTracker"><tt class="xref py py-class docutils literal"><span class="pre">StatusTracker</span></tt></a> object</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.stop">
<tt class="descname">stop</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.SparkContext.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Shut down the SparkContext.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.textFile">
<tt class="descname">textFile</tt><big>(</big><em>name</em>, <em>minPartitions=None</em>, <em>use_unicode=True</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.textFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a text file from HDFS, a local file system (available on all
nodes), or any Hadoop-supported file system URI, and return it as an
RDD of Strings.</p>
<p>If use_unicode is False, the strings will be kept as <cite>str</cite> (encoding
as <cite>utf-8</cite>), which is faster and smaller than unicode. (Added in
Spark 1.2)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tempdir</span><span class="p">,</span> <span class="s">&quot;sample-text.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">testFile</span><span class="p">:</span>
<span class="gp">... </span>   <span class="n">_</span> <span class="o">=</span> <span class="n">testFile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Hello world!&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">textFile</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">textFile</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">textFile</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[u&#39;Hello world!&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.union">
<tt class="descname">union</tt><big>(</big><em>rdds</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Build the union of a list of RDDs.</p>
<p>This supports unions() of RDDs with different serialized formats,
although this forces them to be reserialized using the default
serializer:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tempdir</span><span class="p">,</span> <span class="s">&quot;union-text.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">testFile</span><span class="p">:</span>
<span class="gp">... </span>   <span class="n">_</span> <span class="o">=</span> <span class="n">testFile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">textFile</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">textFile</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">textFile</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[u&#39;Hello&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parallelized</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="s">&quot;World!&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">union</span><span class="p">([</span><span class="n">textFile</span><span class="p">,</span> <span class="n">parallelized</span><span class="p">])</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="go">[u&#39;Hello&#39;, &#39;World!&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pyspark.SparkContext.version">
<tt class="descname">version</tt><a class="headerlink" href="#pyspark.SparkContext.version" title="Permalink to this definition">¶</a></dt>
<dd><p>The version of Spark on which this application is running.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.SparkContext.wholeTextFiles">
<tt class="descname">wholeTextFiles</tt><big>(</big><em>path</em>, <em>minPartitions=None</em>, <em>use_unicode=True</em><big>)</big><a class="headerlink" href="#pyspark.SparkContext.wholeTextFiles" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a directory of text files from HDFS, a local file system
(available on all nodes), or any  Hadoop-supported file system
URI. Each file is read as a single record and returned in a
key-value pair, where the key is the path of each file, the
value is the content of each file.</p>
<p>If use_unicode is False, the strings will be kept as <cite>str</cite> (encoding
as <cite>utf-8</cite>), which is faster and smaller than unicode. (Added in
Spark 1.2)</p>
<p>For example, if you have the following files:</p>
<div class="highlight-python"><div class="highlight"><pre>hdfs://a-hdfs-path/part-00000
hdfs://a-hdfs-path/part-00001
...
hdfs://a-hdfs-path/part-nnnnn
</pre></div>
</div>
<p>Do <cite>rdd = sparkContext.wholeTextFiles(&#8220;hdfs://a-hdfs-path&#8221;)</cite>,
then <tt class="xref py py-class docutils literal"><span class="pre">rdd</span></tt> contains:</p>
<div class="highlight-python"><div class="highlight"><pre>(a-hdfs-path/part-00000, its content)
(a-hdfs-path/part-00001, its content)
...
(a-hdfs-path/part-nnnnn, its content)
</pre></div>
</div>
<p>NOTE: Small files are preferred, as each file will be loaded
fully in memory.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">dirPath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tempdir</span><span class="p">,</span> <span class="s">&quot;files&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">dirPath</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirPath</span><span class="p">,</span> <span class="s">&quot;1.txt&quot;</span><span class="p">),</span> <span class="s">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file1</span><span class="p">:</span>
<span class="gp">... </span>   <span class="n">_</span> <span class="o">=</span> <span class="n">file1</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirPath</span><span class="p">,</span> <span class="s">&quot;2.txt&quot;</span><span class="p">),</span> <span class="s">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file2</span><span class="p">:</span>
<span class="gp">... </span>   <span class="n">_</span> <span class="o">=</span> <span class="n">file2</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;2&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">textFiles</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">wholeTextFiles</span><span class="p">(</span><span class="n">dirPath</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">textFiles</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="go">[(u&#39;.../1.txt&#39;, u&#39;1&#39;), (u&#39;.../2.txt&#39;, u&#39;2&#39;)]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyspark.SparkFiles">
<em class="property">class </em><tt class="descclassname">pyspark.</tt><tt class="descname">SparkFiles</tt><a class="headerlink" href="#pyspark.SparkFiles" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolves paths to files added through
L{SparkContext.addFile()&lt;pyspark.context.SparkContext.addFile&gt;}.</p>
<p>SparkFiles contains only classmethods; users should not create SparkFiles
instances.</p>
<dl class="classmethod">
<dt id="pyspark.SparkFiles.get">
<em class="property">classmethod </em><tt class="descname">get</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pyspark.SparkFiles.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the absolute path of a file added through <a class="reference internal" href="#pyspark.SparkContext.addFile" title="pyspark.SparkContext.addFile"><tt class="xref py py-func docutils literal"><span class="pre">SparkContext.addFile()</span></tt></a>.</p>
</dd></dl>

<dl class="classmethod">
<dt id="pyspark.SparkFiles.getRootDirectory">
<em class="property">classmethod </em><tt class="descname">getRootDirectory</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.SparkFiles.getRootDirectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the root directory that contains files added through
<a class="reference internal" href="#pyspark.SparkContext.addFile" title="pyspark.SparkContext.addFile"><tt class="xref py py-func docutils literal"><span class="pre">SparkContext.addFile()</span></tt></a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyspark.RDD">
<em class="property">class </em><tt class="descclassname">pyspark.</tt><tt class="descname">RDD</tt><big>(</big><em>jrdd</em>, <em>ctx</em>, <em>jrdd_deserializer=AutoBatchedSerializer(PickleSerializer())</em><big>)</big><a class="headerlink" href="#pyspark.RDD" title="Permalink to this definition">¶</a></dt>
<dd><p>A Resilient Distributed Dataset (RDD), the basic abstraction in Spark.
Represents an immutable, partitioned collection of elements that can be
operated on in parallel.</p>
<dl class="method">
<dt id="pyspark.RDD.aggregate">
<tt class="descname">aggregate</tt><big>(</big><em>zeroValue</em>, <em>seqOp</em>, <em>combOp</em><big>)</big><a class="headerlink" href="#pyspark.RDD.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Aggregate the elements of each partition, and then the results for all
the partitions, using a given combine functions and a neutral &#8220;zero
value.&#8221;</p>
<p>The functions <cite>op(t1, t2)</cite> is allowed to modify <tt class="xref py py-class docutils literal"><span class="pre">t1</span></tt> and return it
as its result value to avoid object allocation; however, it should not
modify <tt class="xref py py-class docutils literal"><span class="pre">t2</span></tt>.</p>
<p>The first function (seqOp) can return a different result type, U, than
the type of this RDD. Thus, we need one operation for merging a T into
an U and one operation for merging two U</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">seqOp</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">combOp</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">aggregate</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">seqOp</span><span class="p">,</span> <span class="n">combOp</span><span class="p">)</span>
<span class="go">(10, 4)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([])</span><span class="o">.</span><span class="n">aggregate</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">seqOp</span><span class="p">,</span> <span class="n">combOp</span><span class="p">)</span>
<span class="go">(0, 0)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.aggregateByKey">
<tt class="descname">aggregateByKey</tt><big>(</big><em>zeroValue</em>, <em>seqFunc</em>, <em>combFunc</em>, <em>numPartitions=None</em>, <em>partitionFunc=&lt;function portable_hash at 0x7f839c2c6e60&gt;</em><big>)</big><a class="headerlink" href="#pyspark.RDD.aggregateByKey" title="Permalink to this definition">¶</a></dt>
<dd><p>Aggregate the values of each key, using given combine functions and a neutral
&#8220;zero value&#8221;. This function can return a different result type, U, than the type
of the values in this RDD, V. Thus, we need one operation for merging a V into
a U and one operation for merging two U&#8217;s, The former operation is used for merging
values within a partition, and the latter is used for merging values between
partitions. To avoid memory allocation, both of these functions are
allowed to modify and return their first argument instead of creating a new U.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.cache">
<tt class="descname">cache</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Persist this RDD with the default storage level (<tt class="xref py py-class docutils literal"><span class="pre">MEMORY_ONLY</span></tt>).</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.cartesian">
<tt class="descname">cartesian</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#pyspark.RDD.cartesian" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Cartesian product of this RDD and another one, that is, the
RDD of all pairs of elements <cite>(a, b)</cite> where <tt class="xref py py-class docutils literal"><span class="pre">a</span></tt> is in <tt class="xref py py-class docutils literal"><span class="pre">self</span></tt> and
<tt class="xref py py-class docutils literal"><span class="pre">b</span></tt> is in <tt class="xref py py-class docutils literal"><span class="pre">other</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">rdd</span><span class="o">.</span><span class="n">cartesian</span><span class="p">(</span><span class="n">rdd</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="go">[(1, 1), (1, 2), (2, 1), (2, 2)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.checkpoint">
<tt class="descname">checkpoint</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark this RDD for checkpointing. It will be saved to a file inside the
checkpoint directory set with <a class="reference internal" href="#pyspark.SparkContext.setCheckpointDir" title="pyspark.SparkContext.setCheckpointDir"><tt class="xref py py-class docutils literal"><span class="pre">SparkContext.setCheckpointDir()</span></tt></a> and
all references to its parent RDDs will be removed. This function must
be called before any job has been executed on this RDD. It is strongly
recommended that this RDD is persisted in memory, otherwise saving it
on a file will require recomputation.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.coalesce">
<tt class="descname">coalesce</tt><big>(</big><em>numPartitions</em>, <em>shuffle=False</em><big>)</big><a class="headerlink" href="#pyspark.RDD.coalesce" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new RDD that is reduced into <cite>numPartitions</cite> partitions.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">glom</span><span class="p">()</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[[1], [2, 3], [4, 5]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">coalesce</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">glom</span><span class="p">()</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[[1, 2, 3, 4, 5]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.cogroup">
<tt class="descname">cogroup</tt><big>(</big><em>other</em>, <em>numPartitions=None</em><big>)</big><a class="headerlink" href="#pyspark.RDD.cogroup" title="Permalink to this definition">¶</a></dt>
<dd><p>For each key k in <tt class="xref py py-class docutils literal"><span class="pre">self</span></tt> or <tt class="xref py py-class docutils literal"><span class="pre">other</span></tt>, return a resulting RDD that
contains a tuple with the list of values for that key in <tt class="xref py py-class docutils literal"><span class="pre">self</span></tt> as
well as <tt class="xref py py-class docutils literal"><span class="pre">other</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">y</span><span class="p">)))</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">cogroup</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()))]</span>
<span class="go">[(&#39;a&#39;, ([1], [2])), (&#39;b&#39;, ([4], []))]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.collect">
<tt class="descname">collect</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.collect" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list that contains all of the elements in this RDD.
Note that this method should only be used if the resulting array is expected
to be small, as all the data is loaded into the driver&#8217;s memory.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.collectAsMap">
<tt class="descname">collectAsMap</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.collectAsMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the key-value pairs in this RDD to the master as a dictionary.</p>
<p>Note that this method should only be used if the resulting data is expected
to be small, as all the data is loaded into the driver&#8217;s memory.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span><span class="o">.</span><span class="n">collectAsMap</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="go">4</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.combineByKey">
<tt class="descname">combineByKey</tt><big>(</big><em>createCombiner</em>, <em>mergeValue</em>, <em>mergeCombiners</em>, <em>numPartitions=None</em>, <em>partitionFunc=&lt;function portable_hash at 0x7f839c2c6e60&gt;</em><big>)</big><a class="headerlink" href="#pyspark.RDD.combineByKey" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic function to combine the elements for each key using a custom
set of aggregation functions.</p>
<p>Turns an RDD[(K, V)] into a result of type RDD[(K, C)], for a &#8220;combined
type&#8221; C.  Note that V and C can be different &#8211; for example, one might
group an RDD of type (Int, Int) into an RDD of type (Int, List[Int]).</p>
<p>Users provide three functions:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="xref py py-class docutils literal"><span class="pre">createCombiner</span></tt>, which turns a V into a C (e.g., creates
a one-element list)</li>
<li><tt class="xref py py-class docutils literal"><span class="pre">mergeValue</span></tt>, to merge a V into a C (e.g., adds it to the end of
a list)</li>
<li><tt class="xref py py-class docutils literal"><span class="pre">mergeCombiners</span></tt>, to combine two C&#8217;s into a single one.</li>
</ul>
</div></blockquote>
<p>In addition, users can control the partitioning of the output RDD.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">combineByKey</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">add</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="go">[(&#39;a&#39;, &#39;11&#39;), (&#39;b&#39;, &#39;1&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pyspark.RDD.context">
<tt class="descname">context</tt><a class="headerlink" href="#pyspark.RDD.context" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#pyspark.SparkContext" title="pyspark.SparkContext"><tt class="xref py py-class docutils literal"><span class="pre">SparkContext</span></tt></a> that this RDD was created on.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.count">
<tt class="descname">count</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of elements in this RDD.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.countApprox">
<tt class="descname">countApprox</tt><big>(</big><em>timeout</em>, <em>confidence=0.95</em><big>)</big><a class="headerlink" href="#pyspark.RDD.countApprox" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Experimental</p>
</div>
<p>Approximate version of count() that returns a potentially incomplete
result within a timeout, even if not all tasks have finished.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">countApprox</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="go">1000</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.countApproxDistinct">
<tt class="descname">countApproxDistinct</tt><big>(</big><em>relativeSD=0.05</em><big>)</big><a class="headerlink" href="#pyspark.RDD.countApproxDistinct" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Experimental</p>
</div>
<p>Return approximate number of distinct elements in the RDD.</p>
<p>The algorithm used is based on streamlib&#8217;s implementation of
<a class="reference external" href="http://dx.doi.org/10.1145/2452376.2452456">&#8220;HyperLogLog in Practice: Algorithmic Engineering of a State
of The Art Cardinality Estimation Algorithm&#8221;, available here</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>relativeSD</strong> &#8211; Relative accuracy. Smaller values create
counters that require more space.
It must be greater than 0.000017.</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">countApproxDistinct</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">900</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1100</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="n">i</span> <span class="o">%</span> <span class="mi">20</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">)])</span><span class="o">.</span><span class="n">countApproxDistinct</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">16</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">24</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.countByKey">
<tt class="descname">countByKey</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.countByKey" title="Permalink to this definition">¶</a></dt>
<dd><p>Count the number of elements for each key, and return the result to the
master as a dictionary.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">rdd</span><span class="o">.</span><span class="n">countByKey</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;a&#39;, 2), (&#39;b&#39;, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.countByValue">
<tt class="descname">countByValue</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.countByValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the count of each unique value in this RDD as a dictionary of
(value, count) pairs.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">countByValue</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(1, 2), (2, 3)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.distinct">
<tt class="descname">distinct</tt><big>(</big><em>numPartitions=None</em><big>)</big><a class="headerlink" href="#pyspark.RDD.distinct" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new RDD containing the distinct elements in this RDD.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">distinct</span><span class="p">()</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="go">[1, 2, 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.filter">
<tt class="descname">filter</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#pyspark.RDD.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new RDD containing only the elements that satisfy a predicate.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[2, 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.first">
<tt class="descname">first</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.first" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the first element in this RDD.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([])</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">ValueError</span>: <span class="n">RDD is empty</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.flatMap">
<tt class="descname">flatMap</tt><big>(</big><em>f</em>, <em>preservesPartitioning=False</em><big>)</big><a class="headerlink" href="#pyspark.RDD.flatMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new RDD by first applying a function to all elements of this
RDD, and then flattening the results.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">rdd</span><span class="o">.</span><span class="n">flatMap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="go">[1, 1, 1, 2, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">rdd</span><span class="o">.</span><span class="n">flatMap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)])</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="go">[(2, 2), (2, 2), (3, 3), (3, 3), (4, 4), (4, 4)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.flatMapValues">
<tt class="descname">flatMapValues</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#pyspark.RDD.flatMapValues" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass each value in the key-value pair RDD through a flatMap function
without changing the keys; this also retains the original RDD&#8217;s
partitioning.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;x&quot;</span><span class="p">,</span> <span class="s">&quot;y&quot;</span><span class="p">,</span> <span class="s">&quot;z&quot;</span><span class="p">]),</span> <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;p&quot;</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">])])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">flatMapValues</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[(&#39;a&#39;, &#39;x&#39;), (&#39;a&#39;, &#39;y&#39;), (&#39;a&#39;, &#39;z&#39;), (&#39;b&#39;, &#39;p&#39;), (&#39;b&#39;, &#39;r&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.fold">
<tt class="descname">fold</tt><big>(</big><em>zeroValue</em>, <em>op</em><big>)</big><a class="headerlink" href="#pyspark.RDD.fold" title="Permalink to this definition">¶</a></dt>
<dd><p>Aggregate the elements of each partition, and then the results for all
the partitions, using a given associative function and a neutral &#8220;zero value.&#8221;</p>
<p>The function <cite>op(t1, t2)</cite> is allowed to modify <tt class="xref py py-class docutils literal"><span class="pre">t1</span></tt> and return it
as its result value to avoid object allocation; however, it should not
modify <tt class="xref py py-class docutils literal"><span class="pre">t2</span></tt>.</p>
<p>This behaves somewhat differently from fold operations implemented
for non-distributed collections in functional languages like Scala.
This fold operation may be applied to partitions individually, and then
fold those results into the final result, rather than apply the fold
to each element sequentially in some defined ordering. For functions
that are not commutative, the result may differ from that of a fold
applied to a non-distributed collection.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">add</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">add</span><span class="p">)</span>
<span class="go">15</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.foldByKey">
<tt class="descname">foldByKey</tt><big>(</big><em>zeroValue</em>, <em>func</em>, <em>numPartitions=None</em>, <em>partitionFunc=&lt;function portable_hash at 0x7f839c2c6e60&gt;</em><big>)</big><a class="headerlink" href="#pyspark.RDD.foldByKey" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge the values for each key using an associative function &#8220;func&#8221;
and a neutral &#8220;zeroValue&#8221; which may be added to the result an
arbitrary number of times, and must not change the result
(e.g., 0 for addition, or 1 for multiplication.).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">add</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">rdd</span><span class="o">.</span><span class="n">foldByKey</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">add</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="go">[(&#39;a&#39;, 2), (&#39;b&#39;, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.foreach">
<tt class="descname">foreach</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#pyspark.RDD.foreach" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a function to all elements of this RDD.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">foreach</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.foreachPartition">
<tt class="descname">foreachPartition</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#pyspark.RDD.foreachPartition" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a function to each partition of this RDD.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">iterator</span><span class="p">):</span>
<span class="gp">... </span>     <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
<span class="gp">... </span>          <span class="k">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">foreachPartition</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.fullOuterJoin">
<tt class="descname">fullOuterJoin</tt><big>(</big><em>other</em>, <em>numPartitions=None</em><big>)</big><a class="headerlink" href="#pyspark.RDD.fullOuterJoin" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a right outer join of <tt class="xref py py-class docutils literal"><span class="pre">self</span></tt> and <tt class="xref py py-class docutils literal"><span class="pre">other</span></tt>.</p>
<p>For each element (k, v) in <tt class="xref py py-class docutils literal"><span class="pre">self</span></tt>, the resulting RDD will either
contain all pairs (k, (v, w)) for w in <tt class="xref py py-class docutils literal"><span class="pre">other</span></tt>, or the pair
(k, (v, None)) if no elements in <tt class="xref py py-class docutils literal"><span class="pre">other</span></tt> have key k.</p>
<p>Similarly, for each element (k, w) in <tt class="xref py py-class docutils literal"><span class="pre">other</span></tt>, the resulting RDD will
either contain all pairs (k, (v, w)) for v in <tt class="xref py py-class docutils literal"><span class="pre">self</span></tt>, or the pair
(k, (None, w)) if no elements in <tt class="xref py py-class docutils literal"><span class="pre">self</span></tt> have key k.</p>
<p>Hash-partitions the resulting RDD into the given number of partitions.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">fullOuterJoin</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="go">[(&#39;a&#39;, (1, 2)), (&#39;b&#39;, (4, None)), (&#39;c&#39;, (None, 8))]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.getCheckpointFile">
<tt class="descname">getCheckpointFile</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.getCheckpointFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the name of the file to which this RDD was checkpointed</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.getNumPartitions">
<tt class="descname">getNumPartitions</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.getNumPartitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of partitions in RDD</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">getNumPartitions</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.getStorageLevel">
<tt class="descname">getStorageLevel</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.getStorageLevel" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the RDD&#8217;s current storage level.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd1</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd1</span><span class="o">.</span><span class="n">getStorageLevel</span><span class="p">()</span>
<span class="go">StorageLevel(False, False, False, False, 1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">rdd1</span><span class="o">.</span><span class="n">getStorageLevel</span><span class="p">())</span>
<span class="go">Serialized 1x Replicated</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.glom">
<tt class="descname">glom</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.glom" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an RDD created by coalescing all elements within each partition
into a list.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">rdd</span><span class="o">.</span><span class="n">glom</span><span class="p">()</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="go">[[1, 2], [3, 4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.groupBy">
<tt class="descname">groupBy</tt><big>(</big><em>f</em>, <em>numPartitions=None</em>, <em>partitionFunc=&lt;function portable_hash at 0x7f839c2c6e60&gt;</em><big>)</big><a class="headerlink" href="#pyspark.RDD.groupBy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an RDD of grouped items.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">rdd</span><span class="o">.</span><span class="n">groupBy</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">result</span><span class="p">])</span>
<span class="go">[(0, [2, 8]), (1, [1, 1, 3, 5])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.groupByKey">
<tt class="descname">groupByKey</tt><big>(</big><em>numPartitions=None</em>, <em>partitionFunc=&lt;function portable_hash at 0x7f839c2c6e60&gt;</em><big>)</big><a class="headerlink" href="#pyspark.RDD.groupByKey" title="Permalink to this definition">¶</a></dt>
<dd><p>Group the values for each key in the RDD into a single sequence.
Hash-partitions the resulting RDD with numPartitions partitions.</p>
<p>Note: If you are grouping in order to perform an aggregation (such as a
sum or average) over each key, using reduceByKey or aggregateByKey will
provide much better performance.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">rdd</span><span class="o">.</span><span class="n">groupByKey</span><span class="p">()</span><span class="o">.</span><span class="n">mapValues</span><span class="p">(</span><span class="nb">len</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="go">[(&#39;a&#39;, 2), (&#39;b&#39;, 1)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">rdd</span><span class="o">.</span><span class="n">groupByKey</span><span class="p">()</span><span class="o">.</span><span class="n">mapValues</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="go">[(&#39;a&#39;, [1, 1]), (&#39;b&#39;, [1])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.groupWith">
<tt class="descname">groupWith</tt><big>(</big><em>other</em>, <em>*others</em><big>)</big><a class="headerlink" href="#pyspark.RDD.groupWith" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for cogroup but with support for multiple RDDs.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="mi">42</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">y</span><span class="p">)))</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">groupWith</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()))]</span>
<span class="go">[(&#39;a&#39;, ([5], [1], [2], [])), (&#39;b&#39;, ([6], [4], [], [42]))]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.histogram">
<tt class="descname">histogram</tt><big>(</big><em>buckets</em><big>)</big><a class="headerlink" href="#pyspark.RDD.histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a histogram using the provided buckets. The buckets
are all open to the right except for the last which is closed.
e.g. [1,10,20,50] means the buckets are [1,10) [10,20) [20,50],
which means 1&lt;=x&lt;10, 10&lt;=x&lt;20, 20&lt;=x&lt;=50. And on the input of 1
and 50 we would have a histogram of 1,0,1.</p>
<p>If your histogram is evenly spaced (e.g. [0, 10, 20, 30]),
this can be switched from an O(log n) inseration to O(1) per
element (where n is the number of buckets).</p>
<p>Buckets must be sorted, not contain any duplicates, and have
at least two elements.</p>
<p>If <cite>buckets</cite> is a number, it will generate buckets which are
evenly spaced between the minimum and maximum of the RDD. For
example, if the min value is 0 and the max is 100, given <cite>buckets</cite>
as 2, the resulting buckets will be [0,50) [50,100]. <cite>buckets</cite> must
be at least 1. An exception is raised if the RDD contains infinity.
If the elements in the RDD do not vary (max == min), a single bucket
will be used.</p>
<p>The return value is a tuple of buckets and histogram.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">51</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">([0, 25, 50], [25, 26])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">histogram</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">50</span><span class="p">])</span>
<span class="go">([0, 5, 25, 50], [5, 20, 26])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">histogram</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">60</span><span class="p">])</span>  <span class="c"># evenly spaced buckets</span>
<span class="go">([0, 15, 30, 45, 60], [15, 15, 15, 6])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="s">&quot;ab&quot;</span><span class="p">,</span> <span class="s">&quot;ac&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;bd&quot;</span><span class="p">,</span> <span class="s">&quot;ef&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">histogram</span><span class="p">((</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">))</span>
<span class="go">((&#39;a&#39;, &#39;b&#39;, &#39;c&#39;), [2, 2])</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.id">
<tt class="descname">id</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.id" title="Permalink to this definition">¶</a></dt>
<dd><p>A unique ID for this RDD (within its SparkContext).</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.intersection">
<tt class="descname">intersection</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#pyspark.RDD.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the intersection of this RDD and another one. The output will
not contain any duplicate elements, even if the input RDDs did.</p>
<p>Note that this method performs a shuffle internally.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd1</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd2</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">rdd2</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[1, 2, 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.isCheckpointed">
<tt class="descname">isCheckpointed</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.isCheckpointed" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether this RDD has been checkpointed or not</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.isEmpty">
<tt class="descname">isEmpty</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.isEmpty" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if and only if the RDD contains no elements at all. Note that an RDD
may be empty even when it has at least 1 partition.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([])</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">isEmpty</span><span class="p">()</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.join">
<tt class="descname">join</tt><big>(</big><em>other</em>, <em>numPartitions=None</em><big>)</big><a class="headerlink" href="#pyspark.RDD.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an RDD containing all pairs of elements with matching keys in
<tt class="xref py py-class docutils literal"><span class="pre">self</span></tt> and <tt class="xref py py-class docutils literal"><span class="pre">other</span></tt>.</p>
<p>Each pair of elements will be returned as a (k, (v1, v2)) tuple, where
(k, v1) is in <tt class="xref py py-class docutils literal"><span class="pre">self</span></tt> and (k, v2) is in <tt class="xref py py-class docutils literal"><span class="pre">other</span></tt>.</p>
<p>Performs a hash join across the cluster.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="go">[(&#39;a&#39;, (1, 2)), (&#39;a&#39;, (1, 3))]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.keyBy">
<tt class="descname">keyBy</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#pyspark.RDD.keyBy" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates tuples of the elements in this RDD by applying <tt class="xref py py-class docutils literal"><span class="pre">f</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">keyBy</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">y</span><span class="p">)))</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">cogroup</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">())]</span>
<span class="go">[(0, [[0], [0]]), (1, [[1], [1]]), (2, [[], [2]]), (3, [[], [3]]), (4, [[2], [4]])]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.keys">
<tt class="descname">keys</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.keys" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an RDD with the keys of each tuple.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[1, 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.leftOuterJoin">
<tt class="descname">leftOuterJoin</tt><big>(</big><em>other</em>, <em>numPartitions=None</em><big>)</big><a class="headerlink" href="#pyspark.RDD.leftOuterJoin" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a left outer join of <tt class="xref py py-class docutils literal"><span class="pre">self</span></tt> and <tt class="xref py py-class docutils literal"><span class="pre">other</span></tt>.</p>
<p>For each element (k, v) in <tt class="xref py py-class docutils literal"><span class="pre">self</span></tt>, the resulting RDD will either
contain all pairs (k, (v, w)) for w in <tt class="xref py py-class docutils literal"><span class="pre">other</span></tt>, or the pair
(k, (v, None)) if no elements in <tt class="xref py py-class docutils literal"><span class="pre">other</span></tt> have key k.</p>
<p>Hash-partitions the resulting RDD into the given number of partitions.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">leftOuterJoin</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="go">[(&#39;a&#39;, (1, 2)), (&#39;b&#39;, (4, None))]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.lookup">
<tt class="descname">lookup</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#pyspark.RDD.lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of values in the RDD for key <cite>key</cite>. This operation
is done efficiently if the RDD has a known partitioner by only
searching the partition that the key maps to.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">l</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>  <span class="c"># slow</span>
<span class="go">[42]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span> <span class="o">=</span> <span class="n">rdd</span><span class="o">.</span><span class="n">sortByKey</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>  <span class="c"># fast</span>
<span class="go">[42]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd2</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([((</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">),</span> <span class="s">&#39;c&#39;</span><span class="p">)])</span><span class="o">.</span><span class="n">groupByKey</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">rdd2</span><span class="o">.</span><span class="n">lookup</span><span class="p">((</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;b&#39;</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>
<span class="go">[&#39;c&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.map">
<tt class="descname">map</tt><big>(</big><em>f</em>, <em>preservesPartitioning=False</em><big>)</big><a class="headerlink" href="#pyspark.RDD.map" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new RDD by applying a function to each element of this RDD.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">rdd</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="go">[(&#39;a&#39;, 1), (&#39;b&#39;, 1), (&#39;c&#39;, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.mapPartitions">
<tt class="descname">mapPartitions</tt><big>(</big><em>f</em>, <em>preservesPartitioning=False</em><big>)</big><a class="headerlink" href="#pyspark.RDD.mapPartitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new RDD by applying a function to each partition of this RDD.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">iterator</span><span class="p">):</span> <span class="k">yield</span> <span class="nb">sum</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">mapPartitions</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[3, 7]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.mapPartitionsWithIndex">
<tt class="descname">mapPartitionsWithIndex</tt><big>(</big><em>f</em>, <em>preservesPartitioning=False</em><big>)</big><a class="headerlink" href="#pyspark.RDD.mapPartitionsWithIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new RDD by applying a function to each partition of this RDD,
while tracking the index of the original partition.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">splitIndex</span><span class="p">,</span> <span class="n">iterator</span><span class="p">):</span> <span class="k">yield</span> <span class="n">splitIndex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">mapPartitionsWithIndex</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.mapPartitionsWithSplit">
<tt class="descname">mapPartitionsWithSplit</tt><big>(</big><em>f</em>, <em>preservesPartitioning=False</em><big>)</big><a class="headerlink" href="#pyspark.RDD.mapPartitionsWithSplit" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated: use mapPartitionsWithIndex instead.</p>
<p>Return a new RDD by applying a function to each partition of this RDD,
while tracking the index of the original partition.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">splitIndex</span><span class="p">,</span> <span class="n">iterator</span><span class="p">):</span> <span class="k">yield</span> <span class="n">splitIndex</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">mapPartitionsWithSplit</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.mapValues">
<tt class="descname">mapValues</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#pyspark.RDD.mapValues" title="Permalink to this definition">¶</a></dt>
<dd><p>Pass each value in the key-value pair RDD through a map function
without changing the keys; this also retains the original RDD&#8217;s
partitioning.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;apple&quot;</span><span class="p">,</span> <span class="s">&quot;banana&quot;</span><span class="p">,</span> <span class="s">&quot;lemon&quot;</span><span class="p">]),</span> <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;grapes&quot;</span><span class="p">])])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">mapValues</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[(&#39;a&#39;, 3), (&#39;b&#39;, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.max">
<tt class="descname">max</tt><big>(</big><em>key=None</em><big>)</big><a class="headerlink" href="#pyspark.RDD.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the maximum item in this RDD.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> &#8211; A function used to generate key for comparing</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">43.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="go">43.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="go">5.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.mean">
<tt class="descname">mean</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mean of this RDD&#8217;s elements.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="go">2.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.meanApprox">
<tt class="descname">meanApprox</tt><big>(</big><em>timeout</em>, <em>confidence=0.95</em><big>)</big><a class="headerlink" href="#pyspark.RDD.meanApprox" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Experimental</p>
</div>
<p>Approximate operation to return the mean within a timeout
or meet the confidence.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span> <span class="o">/</span> <span class="mf">1000.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">rdd</span><span class="o">.</span><span class="n">meanApprox</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mf">0.05</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.min">
<tt class="descname">min</tt><big>(</big><em>key=None</em><big>)</big><a class="headerlink" href="#pyspark.RDD.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the minimum item in this RDD.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> &#8211; A function used to generate key for comparing</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">43.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="go">10.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.name">
<tt class="descname">name</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the name of this RDD.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.partitionBy">
<tt class="descname">partitionBy</tt><big>(</big><em>numPartitions</em>, <em>partitionFunc=&lt;function portable_hash at 0x7f839c2c6e60&gt;</em><big>)</big><a class="headerlink" href="#pyspark.RDD.partitionBy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a copy of the RDD partitioned using the specified partitioner.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">pairs</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sets</span> <span class="o">=</span> <span class="n">pairs</span><span class="o">.</span><span class="n">partitionBy</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">glom</span><span class="p">()</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sets</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sets</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.persist">
<tt class="descname">persist</tt><big>(</big><em>storageLevel=StorageLevel(False</em>, <em>True</em>, <em>False</em>, <em>False</em>, <em>1)</em><big>)</big><a class="headerlink" href="#pyspark.RDD.persist" title="Permalink to this definition">¶</a></dt>
<dd><p>Set this RDD&#8217;s storage level to persist its values across operations
after the first time it is computed. This can only be used to assign
a new storage level if the RDD does not have a storage level set yet.
If no storage level is specified defaults to (<tt class="xref py py-class docutils literal"><span class="pre">MEMORY_ONLY</span></tt>).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">persist</span><span class="p">()</span><span class="o">.</span><span class="n">is_cached</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.pipe">
<tt class="descname">pipe</tt><big>(</big><em>command</em>, <em>env=None</em>, <em>checkCode=False</em><big>)</big><a class="headerlink" href="#pyspark.RDD.pipe" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an RDD created by piping elements to a forked external process.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;3&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="s">&#39;cat&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[u&#39;1&#39;, u&#39;2&#39;, u&#39;&#39;, u&#39;3&#39;]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>checkCode</strong> &#8211; whether or not to check the return value of the shell command.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.randomSplit">
<tt class="descname">randomSplit</tt><big>(</big><em>weights</em>, <em>seed=None</em><big>)</big><a class="headerlink" href="#pyspark.RDD.randomSplit" title="Permalink to this definition">¶</a></dt>
<dd><p>Randomly splits this RDD with the provided weights.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>weights</strong> &#8211; weights for splits, will be normalized if they don&#8217;t sum to 1</li>
<li><strong>seed</strong> &#8211; random seed</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">split RDDs in a list</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">500</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd1</span><span class="p">,</span> <span class="n">rdd2</span> <span class="o">=</span> <span class="n">rdd</span><span class="o">.</span><span class="n">randomSplit</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">17</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">rdd1</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span> <span class="o">+</span> <span class="n">rdd2</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="go">500</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">150</span> <span class="o">&lt;</span> <span class="n">rdd1</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">250</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">250</span> <span class="o">&lt;</span> <span class="n">rdd2</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">350</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.reduce">
<tt class="descname">reduce</tt><big>(</big><em>f</em><big>)</big><a class="headerlink" href="#pyspark.RDD.reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduces the elements of this RDD using the specified commutative and
associative binary operator. Currently reduces partitions locally.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">add</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">add</span><span class="p">)</span>
<span class="go">15</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">((</span><span class="mi">2</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)))</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cache</span><span class="p">()</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">add</span><span class="p">)</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([])</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">add</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
    <span class="o">...</span>
<span class="gr">ValueError</span>: <span class="n">Can not reduce() empty RDD</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.reduceByKey">
<tt class="descname">reduceByKey</tt><big>(</big><em>func</em>, <em>numPartitions=None</em>, <em>partitionFunc=&lt;function portable_hash at 0x7f839c2c6e60&gt;</em><big>)</big><a class="headerlink" href="#pyspark.RDD.reduceByKey" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge the values for each key using an associative and commutative reduce function.</p>
<p>This will also perform the merging locally on each mapper before
sending results to a reducer, similarly to a &#8220;combiner&#8221; in MapReduce.</p>
<p>Output will be partitioned with <tt class="xref py py-class docutils literal"><span class="pre">numPartitions</span></tt> partitions, or
the default parallelism level if <tt class="xref py py-class docutils literal"><span class="pre">numPartitions</span></tt> is not specified.
Default partitioner is hash-partition.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">add</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">rdd</span><span class="o">.</span><span class="n">reduceByKey</span><span class="p">(</span><span class="n">add</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="go">[(&#39;a&#39;, 2), (&#39;b&#39;, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.reduceByKeyLocally">
<tt class="descname">reduceByKeyLocally</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#pyspark.RDD.reduceByKeyLocally" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge the values for each key using an associative and commutative reduce function, but
return the results immediately to the master as a dictionary.</p>
<p>This will also perform the merging locally on each mapper before
sending results to a reducer, similarly to a &#8220;combiner&#8221; in MapReduce.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">add</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">rdd</span><span class="o">.</span><span class="n">reduceByKeyLocally</span><span class="p">(</span><span class="n">add</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
<span class="go">[(&#39;a&#39;, 2), (&#39;b&#39;, 1)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.repartition">
<tt class="descname">repartition</tt><big>(</big><em>numPartitions</em><big>)</big><a class="headerlink" href="#pyspark.RDD.repartition" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new RDD that has exactly numPartitions partitions.</p>
<p>Can increase or decrease the level of parallelism in this RDD.
Internally, this uses a shuffle to redistribute data.
If you are decreasing the number of partitions in this RDD, consider
using <cite>coalesce</cite>, which can avoid performing a shuffle.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">rdd</span><span class="o">.</span><span class="n">glom</span><span class="p">()</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="go">[[1], [2, 3], [4, 5], [6, 7]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">rdd</span><span class="o">.</span><span class="n">repartition</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">glom</span><span class="p">()</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">rdd</span><span class="o">.</span><span class="n">repartition</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">glom</span><span class="p">()</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="go">10</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.repartitionAndSortWithinPartitions">
<tt class="descname">repartitionAndSortWithinPartitions</tt><big>(</big><em>numPartitions=None</em>, <em>partitionFunc=&lt;function portable_hash at 0x7f839c2c6e60&gt;</em>, <em>ascending=True</em>, <em>keyfunc=&lt;function &lt;lambda&gt; at 0x7f839c2cf668&gt;</em><big>)</big><a class="headerlink" href="#pyspark.RDD.repartitionAndSortWithinPartitions" title="Permalink to this definition">¶</a></dt>
<dd><p>Repartition the RDD according to the given partitioner and, within each resulting partition,
sort records by their keys.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd2</span> <span class="o">=</span> <span class="n">rdd</span><span class="o">.</span><span class="n">repartitionAndSortWithinPartitions</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd2</span><span class="o">.</span><span class="n">glom</span><span class="p">()</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[[(0, 5), (0, 8), (2, 6)], [(1, 3), (3, 8), (3, 8)]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.rightOuterJoin">
<tt class="descname">rightOuterJoin</tt><big>(</big><em>other</em>, <em>numPartitions=None</em><big>)</big><a class="headerlink" href="#pyspark.RDD.rightOuterJoin" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a right outer join of <tt class="xref py py-class docutils literal"><span class="pre">self</span></tt> and <tt class="xref py py-class docutils literal"><span class="pre">other</span></tt>.</p>
<p>For each element (k, w) in <tt class="xref py py-class docutils literal"><span class="pre">other</span></tt>, the resulting RDD will either
contain all pairs (k, (v, w)) for v in this, or the pair (k, (None, w))
if no elements in <tt class="xref py py-class docutils literal"><span class="pre">self</span></tt> have key k.</p>
<p>Hash-partitions the resulting RDD into the given number of partitions.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">rightOuterJoin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="go">[(&#39;a&#39;, (2, 1)), (&#39;b&#39;, (None, 4))]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.sample">
<tt class="descname">sample</tt><big>(</big><em>withReplacement</em>, <em>fraction</em>, <em>seed=None</em><big>)</big><a class="headerlink" href="#pyspark.RDD.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sampled subset of this RDD.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>withReplacement</strong> &#8211; can elements be sampled multiple times (replaced when sampled out)</li>
<li><strong>fraction</strong> &#8211; expected size of the sample as a fraction of this RDD&#8217;s size
without replacement: probability that each element is chosen; fraction must be [0, 1]
with replacement: expected number of times each element is chosen; fraction must be &gt;= 0</li>
<li><strong>seed</strong> &#8211; seed for the random number generator</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">6</span> <span class="o">&lt;=</span> <span class="n">rdd</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="bp">False</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">81</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">14</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.sampleByKey">
<tt class="descname">sampleByKey</tt><big>(</big><em>withReplacement</em>, <em>fractions</em>, <em>seed=None</em><big>)</big><a class="headerlink" href="#pyspark.RDD.sampleByKey" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a subset of this RDD sampled by key (via stratified sampling).
Create a sample of this RDD using variable sampling rates for
different keys as specified by fractions, a key to sampling rate map.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fractions</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;a&quot;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="n">fractions</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">cartesian</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">rdd</span><span class="o">.</span><span class="n">sampleByKey</span><span class="p">(</span><span class="bp">False</span><span class="p">,</span> <span class="n">fractions</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">groupByKey</span><span class="p">()</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">100</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="s">&quot;a&quot;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">300</span> <span class="ow">and</span> <span class="mi">50</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="s">&quot;b&quot;</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">150</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="s">&quot;a&quot;</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">999</span> <span class="ow">and</span> <span class="nb">min</span><span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="s">&quot;a&quot;</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">0</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">max</span><span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="s">&quot;b&quot;</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">999</span> <span class="ow">and</span> <span class="nb">min</span><span class="p">(</span><span class="n">sample</span><span class="p">[</span><span class="s">&quot;b&quot;</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">0</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.sampleStdev">
<tt class="descname">sampleStdev</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.sampleStdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the sample standard deviation of this RDD&#8217;s elements (which
corrects for bias in estimating the standard deviation by dividing by
N-1 instead of N).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">sampleStdev</span><span class="p">()</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.sampleVariance">
<tt class="descname">sampleVariance</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.sampleVariance" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the sample variance of this RDD&#8217;s elements (which corrects
for bias in estimating the variance by dividing by N-1 instead of N).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">sampleVariance</span><span class="p">()</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.saveAsHadoopDataset">
<tt class="descname">saveAsHadoopDataset</tt><big>(</big><em>conf</em>, <em>keyConverter=None</em>, <em>valueConverter=None</em><big>)</big><a class="headerlink" href="#pyspark.RDD.saveAsHadoopDataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Output a Python RDD of key-value pairs (of form <cite>RDD[(K, V)]</cite>) to any Hadoop file
system, using the old Hadoop OutputFormat API (mapred package). Keys/values are
converted for output using either user specified converters or, by default,
<tt class="xref py py-class docutils literal"><span class="pre">org.apache.spark.api.python.JavaToWritableConverter</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>conf</strong> &#8211; Hadoop job configuration, passed in as a dict</li>
<li><strong>keyConverter</strong> &#8211; (None by default)</li>
<li><strong>valueConverter</strong> &#8211; (None by default)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.saveAsHadoopFile">
<tt class="descname">saveAsHadoopFile</tt><big>(</big><em>path</em>, <em>outputFormatClass</em>, <em>keyClass=None</em>, <em>valueClass=None</em>, <em>keyConverter=None</em>, <em>valueConverter=None</em>, <em>conf=None</em>, <em>compressionCodecClass=None</em><big>)</big><a class="headerlink" href="#pyspark.RDD.saveAsHadoopFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Output a Python RDD of key-value pairs (of form <cite>RDD[(K, V)]</cite>) to any Hadoop file
system, using the old Hadoop OutputFormat API (mapred package). Key and value types
will be inferred if not specified. Keys and values are converted for output using either
user specified converters or <tt class="xref py py-class docutils literal"><span class="pre">org.apache.spark.api.python.JavaToWritableConverter</span></tt>. The
<tt class="xref py py-class docutils literal"><span class="pre">conf</span></tt> is applied on top of the base Hadoop conf associated with the SparkContext
of this RDD to create a merged Hadoop MapReduce job configuration for saving the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>path</strong> &#8211; path to Hadoop file</li>
<li><strong>outputFormatClass</strong> &#8211; fully qualified classname of Hadoop OutputFormat
(e.g. &#8220;org.apache.hadoop.mapred.SequenceFileOutputFormat&#8221;)</li>
<li><strong>keyClass</strong> &#8211; fully qualified classname of key Writable class
(e.g. &#8220;org.apache.hadoop.io.IntWritable&#8221;, None by default)</li>
<li><strong>valueClass</strong> &#8211; fully qualified classname of value Writable class
(e.g. &#8220;org.apache.hadoop.io.Text&#8221;, None by default)</li>
<li><strong>keyConverter</strong> &#8211; (None by default)</li>
<li><strong>valueConverter</strong> &#8211; (None by default)</li>
<li><strong>conf</strong> &#8211; (None by default)</li>
<li><strong>compressionCodecClass</strong> &#8211; (None by default)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.saveAsNewAPIHadoopDataset">
<tt class="descname">saveAsNewAPIHadoopDataset</tt><big>(</big><em>conf</em>, <em>keyConverter=None</em>, <em>valueConverter=None</em><big>)</big><a class="headerlink" href="#pyspark.RDD.saveAsNewAPIHadoopDataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Output a Python RDD of key-value pairs (of form <cite>RDD[(K, V)]</cite>) to any Hadoop file
system, using the new Hadoop OutputFormat API (mapreduce package). Keys/values are
converted for output using either user specified converters or, by default,
<tt class="xref py py-class docutils literal"><span class="pre">org.apache.spark.api.python.JavaToWritableConverter</span></tt>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>conf</strong> &#8211; Hadoop job configuration, passed in as a dict</li>
<li><strong>keyConverter</strong> &#8211; (None by default)</li>
<li><strong>valueConverter</strong> &#8211; (None by default)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.saveAsNewAPIHadoopFile">
<tt class="descname">saveAsNewAPIHadoopFile</tt><big>(</big><em>path</em>, <em>outputFormatClass</em>, <em>keyClass=None</em>, <em>valueClass=None</em>, <em>keyConverter=None</em>, <em>valueConverter=None</em>, <em>conf=None</em><big>)</big><a class="headerlink" href="#pyspark.RDD.saveAsNewAPIHadoopFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Output a Python RDD of key-value pairs (of form <cite>RDD[(K, V)]</cite>) to any Hadoop file
system, using the new Hadoop OutputFormat API (mapreduce package). Key and value types
will be inferred if not specified. Keys and values are converted for output using either
user specified converters or <tt class="xref py py-class docutils literal"><span class="pre">org.apache.spark.api.python.JavaToWritableConverter</span></tt>. The
<tt class="xref py py-class docutils literal"><span class="pre">conf</span></tt> is applied on top of the base Hadoop conf associated with the SparkContext
of this RDD to create a merged Hadoop MapReduce job configuration for saving the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>path</strong> &#8211; path to Hadoop file</li>
<li><strong>outputFormatClass</strong> &#8211; fully qualified classname of Hadoop OutputFormat
(e.g. &#8220;org.apache.hadoop.mapreduce.lib.output.SequenceFileOutputFormat&#8221;)</li>
<li><strong>keyClass</strong> &#8211; fully qualified classname of key Writable class
(e.g. &#8220;org.apache.hadoop.io.IntWritable&#8221;, None by default)</li>
<li><strong>valueClass</strong> &#8211; fully qualified classname of value Writable class
(e.g. &#8220;org.apache.hadoop.io.Text&#8221;, None by default)</li>
<li><strong>keyConverter</strong> &#8211; (None by default)</li>
<li><strong>valueConverter</strong> &#8211; (None by default)</li>
<li><strong>conf</strong> &#8211; Hadoop job configuration, passed in as a dict (None by default)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.saveAsPickleFile">
<tt class="descname">saveAsPickleFile</tt><big>(</big><em>path</em>, <em>batchSize=10</em><big>)</big><a class="headerlink" href="#pyspark.RDD.saveAsPickleFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Save this RDD as a SequenceFile of serialized objects. The serializer
used is <tt class="xref py py-class docutils literal"><span class="pre">pyspark.serializers.PickleSerializer</span></tt>, default batch size
is 10.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tmpFile</span> <span class="o">=</span> <span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">delete</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tmpFile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;spark&#39;</span><span class="p">,</span> <span class="s">&#39;rdd&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">saveAsPickleFile</span><span class="p">(</span><span class="n">tmpFile</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">pickleFile</span><span class="p">(</span><span class="n">tmpFile</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="go">[&#39;1&#39;, &#39;2&#39;, &#39;rdd&#39;, &#39;spark&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.saveAsSequenceFile">
<tt class="descname">saveAsSequenceFile</tt><big>(</big><em>path</em>, <em>compressionCodecClass=None</em><big>)</big><a class="headerlink" href="#pyspark.RDD.saveAsSequenceFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Output a Python RDD of key-value pairs (of form <cite>RDD[(K, V)]</cite>) to any Hadoop file
system, using the <tt class="xref py py-class docutils literal"><span class="pre">org.apache.hadoop.io.Writable</span></tt> types that we convert from the
RDD&#8217;s key and value types. The mechanism is as follows:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Pyrolite is used to convert pickled Python RDD into RDD of Java objects.</li>
<li>Keys and values of this Java RDD are converted to Writables and written out.</li>
</ol>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>path</strong> &#8211; path to sequence file</li>
<li><strong>compressionCodecClass</strong> &#8211; (None by default)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.saveAsTextFile">
<tt class="descname">saveAsTextFile</tt><big>(</big><em>path</em>, <em>compressionCodecClass=None</em><big>)</big><a class="headerlink" href="#pyspark.RDD.saveAsTextFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Save this RDD as a text file, using string representations of elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>path</strong> &#8211; path to text file</li>
<li><strong>compressionCodecClass</strong> &#8211; (None by default) string i.e.
&#8220;org.apache.hadoop.io.compress.GzipCodec&#8221;</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tempFile</span> <span class="o">=</span> <span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">delete</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tempFile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span><span class="o">.</span><span class="n">saveAsTextFile</span><span class="p">(</span><span class="n">tempFile</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fileinput</span> <span class="kn">import</span> <span class="nb">input</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">glob</span> <span class="kn">import</span> <span class="n">glob</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="n">glob</span><span class="p">(</span><span class="n">tempFile</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">&quot;/part-0000*&quot;</span><span class="p">))))</span>
<span class="go">&#39;0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n&#39;</span>
</pre></div>
</div>
<p>Empty lines are tolerated when saving to text files.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tempFile2</span> <span class="o">=</span> <span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">delete</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tempFile2</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;bar&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">saveAsTextFile</span><span class="p">(</span><span class="n">tempFile2</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="n">glob</span><span class="p">(</span><span class="n">tempFile2</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">&quot;/part-0000*&quot;</span><span class="p">))))</span>
<span class="go">&#39;\n\n\nbar\nfoo\n&#39;</span>
</pre></div>
</div>
<p>Using compressionCodecClass</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tempFile3</span> <span class="o">=</span> <span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">delete</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tempFile3</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">codec</span> <span class="o">=</span> <span class="s">&quot;org.apache.hadoop.io.compress.GzipCodec&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="s">&#39;foo&#39;</span><span class="p">,</span> <span class="s">&#39;bar&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">saveAsTextFile</span><span class="p">(</span><span class="n">tempFile3</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">codec</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fileinput</span> <span class="kn">import</span> <span class="nb">input</span><span class="p">,</span> <span class="n">hook_compressed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">input</span><span class="p">(</span><span class="n">glob</span><span class="p">(</span><span class="n">tempFile3</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s">&quot;/part*.gz&quot;</span><span class="p">),</span> <span class="n">openhook</span><span class="o">=</span><span class="n">hook_compressed</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">&#39;utf-8&#39;</span><span class="p">)</span>
<span class="go">u&#39;bar\nfoo\n&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.setName">
<tt class="descname">setName</tt><big>(</big><em>name</em><big>)</big><a class="headerlink" href="#pyspark.RDD.setName" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign a name to this RDD.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd1</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd1</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s">&#39;RDD1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>
<span class="go">u&#39;RDD1&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.sortBy">
<tt class="descname">sortBy</tt><big>(</big><em>keyfunc</em>, <em>ascending=True</em>, <em>numPartitions=None</em><big>)</big><a class="headerlink" href="#pyspark.RDD.sortBy" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorts this RDD by the given keyfunc</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tmp</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span><span class="o">.</span><span class="n">sortBy</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[(&#39;1&#39;, 3), (&#39;2&#39;, 5), (&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;d&#39;, 4)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span><span class="o">.</span><span class="n">sortBy</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;1&#39;, 3), (&#39;d&#39;, 4), (&#39;2&#39;, 5)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.sortByKey">
<tt class="descname">sortByKey</tt><big>(</big><em>ascending=True</em>, <em>numPartitions=None</em>, <em>keyfunc=&lt;function &lt;lambda&gt; at 0x7f839c2cf758&gt;</em><big>)</big><a class="headerlink" href="#pyspark.RDD.sortByKey" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorts this RDD, which is assumed to consist of (key, value) pairs.
# noqa</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tmp</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;1&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;2&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span><span class="o">.</span><span class="n">sortByKey</span><span class="p">()</span><span class="o">.</span><span class="n">first</span><span class="p">()</span>
<span class="go">(&#39;1&#39;, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span><span class="o">.</span><span class="n">sortByKey</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[(&#39;1&#39;, 3), (&#39;2&#39;, 5), (&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;d&#39;, 4)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span><span class="o">.</span><span class="n">sortByKey</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[(&#39;1&#39;, 3), (&#39;2&#39;, 5), (&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;d&#39;, 4)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tmp2</span> <span class="o">=</span> <span class="p">[(</span><span class="s">&#39;Mary&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;had&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;little&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;lamb&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tmp2</span><span class="o">.</span><span class="n">extend</span><span class="p">([(</span><span class="s">&#39;whose&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;fleece&#39;</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;was&#39;</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;white&#39;</span><span class="p">,</span> <span class="mi">9</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="n">tmp2</span><span class="p">)</span><span class="o">.</span><span class="n">sortByKey</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">keyfunc</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[(&#39;a&#39;, 3), (&#39;fleece&#39;, 7), (&#39;had&#39;, 2), (&#39;lamb&#39;, 5),...(&#39;white&#39;, 9), (&#39;whose&#39;, 6)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.stats">
<tt class="descname">stats</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a <tt class="xref py py-class docutils literal"><span class="pre">StatCounter</span></tt> object that captures the mean, variance
and count of the RDD&#8217;s elements in one operation.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.stdev">
<tt class="descname">stdev</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.stdev" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the standard deviation of this RDD&#8217;s elements.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">stdev</span><span class="p">()</span>
<span class="go">0.816...</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.subtract">
<tt class="descname">subtract</tt><big>(</big><em>other</em>, <em>numPartitions=None</em><big>)</big><a class="headerlink" href="#pyspark.RDD.subtract" title="Permalink to this definition">¶</a></dt>
<dd><p>Return each value in <tt class="xref py py-class docutils literal"><span class="pre">self</span></tt> that is not contained in <tt class="xref py py-class docutils literal"><span class="pre">other</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="go">[(&#39;a&#39;, 1), (&#39;b&#39;, 4), (&#39;b&#39;, 5)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.subtractByKey">
<tt class="descname">subtractByKey</tt><big>(</big><em>other</em>, <em>numPartitions=None</em><big>)</big><a class="headerlink" href="#pyspark.RDD.subtractByKey" title="Permalink to this definition">¶</a></dt>
<dd><p>Return each (key, value) pair in <tt class="xref py py-class docutils literal"><span class="pre">self</span></tt> that has no pair with matching
key in <tt class="xref py py-class docutils literal"><span class="pre">other</span></tt>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">subtractByKey</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">())</span>
<span class="go">[(&#39;b&#39;, 4), (&#39;b&#39;, 5)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.sum">
<tt class="descname">sum</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Add up the elements in this RDD.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">6.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.sumApprox">
<tt class="descname">sumApprox</tt><big>(</big><em>timeout</em>, <em>confidence=0.95</em><big>)</big><a class="headerlink" href="#pyspark.RDD.sumApprox" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Experimental</p>
</div>
<p>Approximate operation to return the sum within a timeout
or meet the confidence.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">abs</span><span class="p">(</span><span class="n">rdd</span><span class="o">.</span><span class="n">sumApprox</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mf">0.05</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.take">
<tt class="descname">take</tt><big>(</big><em>num</em><big>)</big><a class="headerlink" href="#pyspark.RDD.take" title="Permalink to this definition">¶</a></dt>
<dd><p>Take the first num elements of the RDD.</p>
<p>It works by first scanning one partition, and use the results from
that partition to estimate the number of additional partitions needed
to satisfy the limit.</p>
<p>Note that this method should only be used if the resulting array is expected
to be small, as all the data is loaded into the driver&#8217;s memory.</p>
<p>Translated from the Scala implementation in RDD#take().</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span><span class="o">.</span><span class="n">cache</span><span class="p">()</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">[2, 3, 4, 5, 6]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span> <span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">)</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">[91, 92, 93]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.takeOrdered">
<tt class="descname">takeOrdered</tt><big>(</big><em>num</em>, <em>key=None</em><big>)</big><a class="headerlink" href="#pyspark.RDD.takeOrdered" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the N elements from a RDD ordered in ascending order or as
specified by the optional key function.</p>
<p>Note that this method should only be used if the resulting array is expected
to be small, as all the data is loaded into the driver&#8217;s memory.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">])</span><span class="o">.</span><span class="n">takeOrdered</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
<span class="go">[1, 2, 3, 4, 5, 6]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">takeOrdered</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">)</span>
<span class="go">[10, 9, 7, 6, 5, 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.takeSample">
<tt class="descname">takeSample</tt><big>(</big><em>withReplacement</em>, <em>num</em>, <em>seed=None</em><big>)</big><a class="headerlink" href="#pyspark.RDD.takeSample" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a fixed-size sampled subset of this RDD.</p>
<p>Note that this method should only be used if the resulting array is expected
to be small, as all the data is loaded into the driver&#8217;s memory.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">rdd</span><span class="o">.</span><span class="n">takeSample</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">rdd</span><span class="o">.</span><span class="n">takeSample</span><span class="p">(</span><span class="bp">False</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="n">rdd</span><span class="o">.</span><span class="n">takeSample</span><span class="p">(</span><span class="bp">False</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">10</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.toDebugString">
<tt class="descname">toDebugString</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.toDebugString" title="Permalink to this definition">¶</a></dt>
<dd><p>A description of this RDD and its recursive dependencies for debugging.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.toLocalIterator">
<tt class="descname">toLocalIterator</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.toLocalIterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an iterator that contains all of the elements in this RDD.
The iterator will consume as much memory as the largest partition in this RDD.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">rdd</span><span class="o">.</span><span class="n">toLocalIterator</span><span class="p">()]</span>
<span class="go">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.top">
<tt class="descname">top</tt><big>(</big><em>num</em>, <em>key=None</em><big>)</big><a class="headerlink" href="#pyspark.RDD.top" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the top N elements from a RDD.</p>
<p>Note that this method should only be used if the resulting array is expected
to be small, as all the data is loaded into the driver&#8217;s memory.</p>
<p>Note: It returns the list sorted in descending order.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">top</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[12]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">top</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">[6, 5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">top</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
<span class="go">[4, 3, 2]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.treeAggregate">
<tt class="descname">treeAggregate</tt><big>(</big><em>zeroValue</em>, <em>seqOp</em>, <em>combOp</em>, <em>depth=2</em><big>)</big><a class="headerlink" href="#pyspark.RDD.treeAggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Aggregates the elements of this RDD in a multi-level tree
pattern.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>depth</strong> &#8211; suggested depth of the tree (default: 2)</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">add</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">treeAggregate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">add</span><span class="p">)</span>
<span class="go">-5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">treeAggregate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">-5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">treeAggregate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">-5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">treeAggregate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">-5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">treeAggregate</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">-5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.treeReduce">
<tt class="descname">treeReduce</tt><big>(</big><em>f</em>, <em>depth=2</em><big>)</big><a class="headerlink" href="#pyspark.RDD.treeReduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Reduces the elements of this RDD in a multi-level tree pattern.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>depth</strong> &#8211; suggested depth of the tree (default: 2)</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">add</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">treeReduce</span><span class="p">(</span><span class="n">add</span><span class="p">)</span>
<span class="go">-5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">treeReduce</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">-5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">treeReduce</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">-5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">treeReduce</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="go">-5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">treeReduce</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">-5</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.union">
<tt class="descname">union</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#pyspark.RDD.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the union of this RDD and another one.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rdd</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">rdd</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[1, 1, 2, 3, 1, 1, 2, 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.unpersist">
<tt class="descname">unpersist</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.unpersist" title="Permalink to this definition">¶</a></dt>
<dd><p>Mark the RDD as non-persistent, and remove all blocks for it from
memory and disk.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.values">
<tt class="descname">values</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an RDD with the values of each tuple.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)])</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[2, 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.variance">
<tt class="descname">variance</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the variance of this RDD&#8217;s elements.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">variance</span><span class="p">()</span>
<span class="go">0.666...</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.zip">
<tt class="descname">zip</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#pyspark.RDD.zip" title="Permalink to this definition">¶</a></dt>
<dd><p>Zips this RDD with another one, returning key-value pairs with the
first element in each RDD second element in each RDD, etc. Assumes
that the two RDDs have the same number of partitions and the same
number of elements in each partition (e.g. one was made through
a map on the other).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1005</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[(0, 1000), (1, 1001), (2, 1002), (3, 1003), (4, 1004)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.zipWithIndex">
<tt class="descname">zipWithIndex</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.zipWithIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Zips this RDD with its element indices.</p>
<p>The ordering is first based on the partition index and then the
ordering of items within each partition. So the first item in
the first partition gets index 0, and the last item in the last
partition receives the largest index.</p>
<p>This method needs to trigger a spark job when this RDD contains
more than one partitions.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="s">&quot;d&quot;</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">zipWithIndex</span><span class="p">()</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[(&#39;a&#39;, 0), (&#39;b&#39;, 1), (&#39;c&#39;, 2), (&#39;d&#39;, 3)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pyspark.RDD.zipWithUniqueId">
<tt class="descname">zipWithUniqueId</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.RDD.zipWithUniqueId" title="Permalink to this definition">¶</a></dt>
<dd><p>Zips this RDD with generated unique Long ids.</p>
<p>Items in the kth partition will get ids k, n+k, 2*n+k, ..., where
n is the number of partitions. So there may exist gaps, but this
method won&#8217;t trigger a spark job, which is different from
<a class="reference internal" href="#pyspark.RDD.zipWithIndex" title="pyspark.RDD.zipWithIndex"><tt class="xref py py-class docutils literal"><span class="pre">zipWithIndex</span></tt></a></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="s">&quot;d&quot;</span><span class="p">,</span> <span class="s">&quot;e&quot;</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">zipWithUniqueId</span><span class="p">()</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[(&#39;a&#39;, 0), (&#39;b&#39;, 1), (&#39;c&#39;, 4), (&#39;d&#39;, 2), (&#39;e&#39;, 5)]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyspark.StorageLevel">
<em class="property">class </em><tt class="descclassname">pyspark.</tt><tt class="descname">StorageLevel</tt><big>(</big><em>useDisk</em>, <em>useMemory</em>, <em>useOffHeap</em>, <em>deserialized</em>, <em>replication=1</em><big>)</big><a class="headerlink" href="#pyspark.StorageLevel" title="Permalink to this definition">¶</a></dt>
<dd><p>Flags for controlling the storage of an RDD. Each StorageLevel records whether to use memory,
whether to drop the RDD to disk if it falls out of memory, whether to keep the data in memory
in a JAVA-specific serialized format, and whether to replicate the RDD partitions on multiple
nodes. Also contains static constants for some commonly used storage levels, MEMORY_ONLY.
Since the data is always serialized on the Python side, all the constants use the serialized
formats.</p>
<dl class="attribute">
<dt id="pyspark.StorageLevel.DISK_ONLY">
<tt class="descname">DISK_ONLY</tt><em class="property"> = StorageLevel(True, False, False, False, 1)</em><a class="headerlink" href="#pyspark.StorageLevel.DISK_ONLY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyspark.StorageLevel.DISK_ONLY_2">
<tt class="descname">DISK_ONLY_2</tt><em class="property"> = StorageLevel(True, False, False, False, 2)</em><a class="headerlink" href="#pyspark.StorageLevel.DISK_ONLY_2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyspark.StorageLevel.MEMORY_AND_DISK">
<tt class="descname">MEMORY_AND_DISK</tt><em class="property"> = StorageLevel(True, True, False, False, 1)</em><a class="headerlink" href="#pyspark.StorageLevel.MEMORY_AND_DISK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyspark.StorageLevel.MEMORY_AND_DISK_2">
<tt class="descname">MEMORY_AND_DISK_2</tt><em class="property"> = StorageLevel(True, True, False, False, 2)</em><a class="headerlink" href="#pyspark.StorageLevel.MEMORY_AND_DISK_2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyspark.StorageLevel.MEMORY_AND_DISK_SER">
<tt class="descname">MEMORY_AND_DISK_SER</tt><em class="property"> = StorageLevel(True, True, False, False, 1)</em><a class="headerlink" href="#pyspark.StorageLevel.MEMORY_AND_DISK_SER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyspark.StorageLevel.MEMORY_AND_DISK_SER_2">
<tt class="descname">MEMORY_AND_DISK_SER_2</tt><em class="property"> = StorageLevel(True, True, False, False, 2)</em><a class="headerlink" href="#pyspark.StorageLevel.MEMORY_AND_DISK_SER_2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyspark.StorageLevel.MEMORY_ONLY">
<tt class="descname">MEMORY_ONLY</tt><em class="property"> = StorageLevel(False, True, False, False, 1)</em><a class="headerlink" href="#pyspark.StorageLevel.MEMORY_ONLY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyspark.StorageLevel.MEMORY_ONLY_2">
<tt class="descname">MEMORY_ONLY_2</tt><em class="property"> = StorageLevel(False, True, False, False, 2)</em><a class="headerlink" href="#pyspark.StorageLevel.MEMORY_ONLY_2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyspark.StorageLevel.MEMORY_ONLY_SER">
<tt class="descname">MEMORY_ONLY_SER</tt><em class="property"> = StorageLevel(False, True, False, False, 1)</em><a class="headerlink" href="#pyspark.StorageLevel.MEMORY_ONLY_SER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyspark.StorageLevel.MEMORY_ONLY_SER_2">
<tt class="descname">MEMORY_ONLY_SER_2</tt><em class="property"> = StorageLevel(False, True, False, False, 2)</em><a class="headerlink" href="#pyspark.StorageLevel.MEMORY_ONLY_SER_2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pyspark.StorageLevel.OFF_HEAP">
<tt class="descname">OFF_HEAP</tt><em class="property"> = StorageLevel(True, True, True, False, 1)</em><a class="headerlink" href="#pyspark.StorageLevel.OFF_HEAP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyspark.Broadcast">
<em class="property">class </em><tt class="descclassname">pyspark.</tt><tt class="descname">Broadcast</tt><big>(</big><em>sc=None</em>, <em>value=None</em>, <em>pickle_registry=None</em>, <em>path=None</em><big>)</big><a class="headerlink" href="#pyspark.Broadcast" title="Permalink to this definition">¶</a></dt>
<dd><p>A broadcast variable created with <a class="reference internal" href="#pyspark.SparkContext.broadcast" title="pyspark.SparkContext.broadcast"><tt class="xref py py-class docutils literal"><span class="pre">SparkContext.broadcast()</span></tt></a>.
Access its value through <tt class="xref py py-class docutils literal"><span class="pre">value</span></tt>.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyspark.context</span> <span class="kn">import</span> <span class="n">SparkContext</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span> <span class="o">=</span> <span class="n">SparkContext</span><span class="p">(</span><span class="s">&#39;local&#39;</span><span class="p">,</span> <span class="s">&#39;test&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">broadcast</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">value</span>
<span class="go">[1, 2, 3, 4, 5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">flatMap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">b</span><span class="o">.</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="go">[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">unpersist</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">large_broadcast</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10000</span><span class="p">))</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyspark.Broadcast.destroy">
<tt class="descname">destroy</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.Broadcast.destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Destroy all data and metadata related to this broadcast variable.
Use this with caution; once a broadcast variable has been destroyed,
it cannot be used again. This method blocks until destroy has
completed.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.Broadcast.dump">
<tt class="descname">dump</tt><big>(</big><em>value</em>, <em>f</em><big>)</big><a class="headerlink" href="#pyspark.Broadcast.dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyspark.Broadcast.load">
<tt class="descname">load</tt><big>(</big><em>path</em><big>)</big><a class="headerlink" href="#pyspark.Broadcast.load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyspark.Broadcast.unpersist">
<tt class="descname">unpersist</tt><big>(</big><em>blocking=False</em><big>)</big><a class="headerlink" href="#pyspark.Broadcast.unpersist" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete cached copies of this broadcast on the executors. If the
broadcast is used after this is called, it will need to be
re-sent to each executor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>blocking</strong> &#8211; Whether to block until unpersisting has completed</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="pyspark.Broadcast.value">
<tt class="descname">value</tt><a class="headerlink" href="#pyspark.Broadcast.value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the broadcasted value</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyspark.Accumulator">
<em class="property">class </em><tt class="descclassname">pyspark.</tt><tt class="descname">Accumulator</tt><big>(</big><em>aid</em>, <em>value</em>, <em>accum_param</em><big>)</big><a class="headerlink" href="#pyspark.Accumulator" title="Permalink to this definition">¶</a></dt>
<dd><p>A shared variable that can be accumulated, i.e., has a commutative and associative &#8220;add&#8221;
operation. Worker tasks on a Spark cluster can add values to an Accumulator with the <cite>+=</cite>
operator, but only the driver program is allowed to access its value, using <a class="reference internal" href="#pyspark.Accumulator.value" title="pyspark.Accumulator.value"><tt class="xref py py-class docutils literal"><span class="pre">value</span></tt></a>.
Updates from the workers get propagated automatically to the driver program.</p>
<p>While <a class="reference internal" href="#pyspark.SparkContext" title="pyspark.SparkContext"><tt class="xref py py-class docutils literal"><span class="pre">SparkContext</span></tt></a> supports accumulators for primitive data types like <tt class="xref py py-class docutils literal"><span class="pre">int</span></tt> and
<tt class="xref py py-class docutils literal"><span class="pre">float</span></tt>, users can also define accumulators for custom types by providing a custom
<a class="reference internal" href="#pyspark.AccumulatorParam" title="pyspark.AccumulatorParam"><tt class="xref py py-class docutils literal"><span class="pre">AccumulatorParam</span></tt></a> object. Refer to the doctest of this module for an example.</p>
<dl class="method">
<dt id="pyspark.Accumulator.add">
<tt class="descname">add</tt><big>(</big><em>term</em><big>)</big><a class="headerlink" href="#pyspark.Accumulator.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a term to this accumulator&#8217;s value</p>
</dd></dl>

<dl class="attribute">
<dt id="pyspark.Accumulator.value">
<tt class="descname">value</tt><a class="headerlink" href="#pyspark.Accumulator.value" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the accumulator&#8217;s value; only usable in driver program</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyspark.AccumulatorParam">
<em class="property">class </em><tt class="descclassname">pyspark.</tt><tt class="descname">AccumulatorParam</tt><a class="headerlink" href="#pyspark.AccumulatorParam" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper object that defines how to accumulate values of a given type.</p>
<dl class="method">
<dt id="pyspark.AccumulatorParam.addInPlace">
<tt class="descname">addInPlace</tt><big>(</big><em>value1</em>, <em>value2</em><big>)</big><a class="headerlink" href="#pyspark.AccumulatorParam.addInPlace" title="Permalink to this definition">¶</a></dt>
<dd><p>Add two values of the accumulator&#8217;s data type, returning a new value;
for efficiency, can also update <tt class="xref py py-class docutils literal"><span class="pre">value1</span></tt> in place and return it.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.AccumulatorParam.zero">
<tt class="descname">zero</tt><big>(</big><em>value</em><big>)</big><a class="headerlink" href="#pyspark.AccumulatorParam.zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Provide a &#8220;zero value&#8221; for the type, compatible in dimensions with the
provided <tt class="xref py py-class docutils literal"><span class="pre">value</span></tt> (e.g., a zero vector)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyspark.MarshalSerializer">
<em class="property">class </em><tt class="descclassname">pyspark.</tt><tt class="descname">MarshalSerializer</tt><a class="headerlink" href="#pyspark.MarshalSerializer" title="Permalink to this definition">¶</a></dt>
<dd><p>Serializes objects using Python&#8217;s Marshal serializer:</p>
<blockquote>
<div><a class="reference external" href="http://docs.python.org/2/library/marshal.html">http://docs.python.org/2/library/marshal.html</a></div></blockquote>
<p>This serializer is faster than PickleSerializer but supports fewer datatypes.</p>
<dl class="method">
<dt id="pyspark.MarshalSerializer.dumps">
<tt class="descname">dumps</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#pyspark.MarshalSerializer.dumps" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyspark.MarshalSerializer.loads">
<tt class="descname">loads</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#pyspark.MarshalSerializer.loads" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyspark.PickleSerializer">
<em class="property">class </em><tt class="descclassname">pyspark.</tt><tt class="descname">PickleSerializer</tt><a class="headerlink" href="#pyspark.PickleSerializer" title="Permalink to this definition">¶</a></dt>
<dd><p>Serializes objects using Python&#8217;s pickle serializer:</p>
<blockquote>
<div><a class="reference external" href="http://docs.python.org/2/library/pickle.html">http://docs.python.org/2/library/pickle.html</a></div></blockquote>
<p>This serializer supports nearly any Python object, but may
not be as fast as more specialized serializers.</p>
<dl class="method">
<dt id="pyspark.PickleSerializer.dumps">
<tt class="descname">dumps</tt><big>(</big><em>obj</em><big>)</big><a class="headerlink" href="#pyspark.PickleSerializer.dumps" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pyspark.PickleSerializer.loads">
<tt class="descname">loads</tt><big>(</big><em>obj</em>, <em>encoding=None</em><big>)</big><a class="headerlink" href="#pyspark.PickleSerializer.loads" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyspark.StatusTracker">
<em class="property">class </em><tt class="descclassname">pyspark.</tt><tt class="descname">StatusTracker</tt><big>(</big><em>jtracker</em><big>)</big><a class="headerlink" href="#pyspark.StatusTracker" title="Permalink to this definition">¶</a></dt>
<dd><p>Low-level status reporting APIs for monitoring job and stage progress.</p>
<p>These APIs intentionally provide very weak consistency semantics;
consumers of these APIs should be prepared to handle empty / missing
information. For example, a job&#8217;s stage ids may be known but the status
API may not have any information about the details of those stages, so
<cite>getStageInfo</cite> could potentially return <cite>None</cite> for a valid stage id.</p>
<p>To limit memory usage, these APIs only provide information on recent
jobs / stages.  These APIs will provide information for the last
<cite>spark.ui.retainedStages</cite> stages and <cite>spark.ui.retainedJobs</cite> jobs.</p>
<dl class="method">
<dt id="pyspark.StatusTracker.getActiveJobsIds">
<tt class="descname">getActiveJobsIds</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.StatusTracker.getActiveJobsIds" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array containing the ids of all active jobs.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.StatusTracker.getActiveStageIds">
<tt class="descname">getActiveStageIds</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.StatusTracker.getActiveStageIds" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array containing the ids of all active stages.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.StatusTracker.getJobIdsForGroup">
<tt class="descname">getJobIdsForGroup</tt><big>(</big><em>jobGroup=None</em><big>)</big><a class="headerlink" href="#pyspark.StatusTracker.getJobIdsForGroup" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of all known jobs in a particular job group.  If
<cite>jobGroup</cite> is None, then returns all known jobs that are not
associated with a job group.</p>
<p>The returned list may contain running, failed, and completed jobs,
and may vary across invocations of this method. This method does
not guarantee the order of the elements in its result.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.StatusTracker.getJobInfo">
<tt class="descname">getJobInfo</tt><big>(</big><em>jobId</em><big>)</big><a class="headerlink" href="#pyspark.StatusTracker.getJobInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="#pyspark.SparkJobInfo" title="pyspark.SparkJobInfo"><tt class="xref py py-class docutils literal"><span class="pre">SparkJobInfo</span></tt></a> object, or None if the job info
could not be found or was garbage collected.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.StatusTracker.getStageInfo">
<tt class="descname">getStageInfo</tt><big>(</big><em>stageId</em><big>)</big><a class="headerlink" href="#pyspark.StatusTracker.getStageInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <a class="reference internal" href="#pyspark.SparkStageInfo" title="pyspark.SparkStageInfo"><tt class="xref py py-class docutils literal"><span class="pre">SparkStageInfo</span></tt></a> object, or None if the stage
info could not be found or was garbage collected.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyspark.SparkJobInfo">
<em class="property">class </em><tt class="descclassname">pyspark.</tt><tt class="descname">SparkJobInfo</tt><a class="headerlink" href="#pyspark.SparkJobInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Exposes information about Spark Jobs.</p>
</dd></dl>

<dl class="class">
<dt id="pyspark.SparkStageInfo">
<em class="property">class </em><tt class="descclassname">pyspark.</tt><tt class="descname">SparkStageInfo</tt><a class="headerlink" href="#pyspark.SparkStageInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Exposes information about Spark Stages.</p>
</dd></dl>

<dl class="class">
<dt id="pyspark.Profiler">
<em class="property">class </em><tt class="descclassname">pyspark.</tt><tt class="descname">Profiler</tt><big>(</big><em>ctx</em><big>)</big><a class="headerlink" href="#pyspark.Profiler" title="Permalink to this definition">¶</a></dt>
<dd><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">DeveloperApi</p>
</div>
<p>PySpark supports custom profilers, this is to allow for different profilers to
be used as well as outputting to different formats than what is provided in the
BasicProfiler.</p>
<dl class="docutils">
<dt>A custom profiler has to define or inherit the following methods:</dt>
<dd>profile - will produce a system profile of some sort.
stats - return the collected stats.
dump - dumps the profiles to a path
add - adds a profile to the existing accumulated profile</dd>
</dl>
<p>The profiler class is chosen when creating a SparkContext</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyspark</span> <span class="kn">import</span> <span class="n">SparkConf</span><span class="p">,</span> <span class="n">SparkContext</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pyspark</span> <span class="kn">import</span> <span class="n">BasicProfiler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">MyCustomProfiler</span><span class="p">(</span><span class="n">BasicProfiler</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
<span class="gp">... </span>        <span class="k">print</span><span class="p">(</span><span class="s">&quot;My custom profiles for RDD:</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">id</span><span class="p">)</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conf</span> <span class="o">=</span> <span class="n">SparkConf</span><span class="p">()</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&quot;spark.python.profile&quot;</span><span class="p">,</span> <span class="s">&quot;true&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span> <span class="o">=</span> <span class="n">SparkContext</span><span class="p">(</span><span class="s">&#39;local&#39;</span><span class="p">,</span> <span class="s">&#39;test&#39;</span><span class="p">,</span> <span class="n">conf</span><span class="o">=</span><span class="n">conf</span><span class="p">,</span> <span class="n">profiler_cls</span><span class="o">=</span><span class="n">MyCustomProfiler</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">))</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
<span class="go">1000</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">show_profiles</span><span class="p">()</span>
<span class="go">My custom profiles for RDD:1</span>
<span class="go">My custom profiles for RDD:3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
</pre></div>
</div>
<dl class="method">
<dt id="pyspark.Profiler.dump">
<tt class="descname">dump</tt><big>(</big><em>id</em>, <em>path</em><big>)</big><a class="headerlink" href="#pyspark.Profiler.dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Dump the profile into path, id is the RDD id</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.Profiler.profile">
<tt class="descname">profile</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#pyspark.Profiler.profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Do profiling on the function <cite>func</cite></p>
</dd></dl>

<dl class="method">
<dt id="pyspark.Profiler.show">
<tt class="descname">show</tt><big>(</big><em>id</em><big>)</big><a class="headerlink" href="#pyspark.Profiler.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Print the profile stats to stdout, id is the RDD id</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.Profiler.stats">
<tt class="descname">stats</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.Profiler.stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the collected profiling stats (pstats.Stats)</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pyspark.BasicProfiler">
<em class="property">class </em><tt class="descclassname">pyspark.</tt><tt class="descname">BasicProfiler</tt><big>(</big><em>ctx</em><big>)</big><a class="headerlink" href="#pyspark.BasicProfiler" title="Permalink to this definition">¶</a></dt>
<dd><p>BasicProfiler is the default profiler, which is implemented based on
cProfile and Accumulator</p>
<dl class="method">
<dt id="pyspark.BasicProfiler.profile">
<tt class="descname">profile</tt><big>(</big><em>func</em><big>)</big><a class="headerlink" href="#pyspark.BasicProfiler.profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs and profiles the method to_profile passed in. A profile object is returned.</p>
</dd></dl>

<dl class="method">
<dt id="pyspark.BasicProfiler.stats">
<tt class="descname">stats</tt><big>(</big><big>)</big><a class="headerlink" href="#pyspark.BasicProfiler.stats" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/spark-logo-hd.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">pyspark package</a><ul>
<li><a class="reference internal" href="#subpackages">Subpackages</a></li>
<li><a class="reference internal" href="#module-pyspark">Contents</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Welcome to Spark Python API Docs!</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pyspark.sql.html"
                        title="next chapter">pyspark.sql module</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/pyspark.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="pyspark.sql.html" title="pyspark.sql module"
             >next</a></li>
        <li class="right" >
          <a href="index.html" title="Welcome to Spark Python API Docs!"
             >previous</a> |</li>
    
        <li><a href="index.html">PySpark 2.0.0 documentation</a> &raquo;</li>
 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright .
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>