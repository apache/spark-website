<!DOCTYPE html >
<html>
        <head>
          <title>streaming - Spark 2.4.4 ScalaDoc - org.apache.spark.sql.streaming</title>
          <meta name="description" content="streaming - Spark 2.4.4 ScalaDoc - org.apache.spark.sql.streaming" />
          <meta name="keywords" content="streaming Spark 2.4.4 ScalaDoc org.apache.spark.sql.streaming" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript" src="../../../../../lib/jquery.js" id="jquery-js"></script>
      <script type="text/javascript" src="../../../../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../../../lib/tools.tooltip.js"></script>
      
      <script type="text/javascript">
         if(top === self) {
            var url = '../../../../../index.html';
            var hash = 'org.apache.spark.sql.streaming.package';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="value">
      <div id="definition">
        <img alt="Package" src="../../../../../lib/package_big.png" />
        <p id="owner"><a href="../../../../package.html" class="extype" name="org">org</a>.<a href="../../../package.html" class="extype" name="org.apache">apache</a>.<a href="../../package.html" class="extype" name="org.apache.spark">spark</a>.<a href="../package.html" class="extype" name="org.apache.spark.sql">sql</a></p>
        <h1>streaming</h1><span class="permalink">
      <a href="../../../../../index.html#org.apache.spark.sql.streaming.package" title="Permalink" target="_top">
        <img src="../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">package</span>
      </span>
      <span class="symbol">
        <span class="name">streaming</span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        
        
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div id="types" class="types members">
              <h3>Type Members</h3>
              <ol><li name="org.apache.spark.sql.streaming.DataStreamReader" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="DataStreamReaderextendsLogging"></a>
      <a id="DataStreamReader:DataStreamReader"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="DataStreamReader.html"><span class="name">DataStreamReader</span></a><span class="result"> extends <a href="../../internal/Logging.html" class="extype" name="org.apache.spark.internal.Logging">Logging</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../../index.html#org.apache.spark.sql.streaming.package@DataStreamReaderextendsLogging" title="Permalink" target="_top">
        <img src="../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Interface used to load a streaming <code>Dataset</code> from external storage systems (e.g.</p><div class="fullcomment"><div class="comment cmt"><p>Interface used to load a streaming <code>Dataset</code> from external storage systems (e.g. file systems,
key-value stores, etc). Use <code>SparkSession.readStream</code> to access this.
</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@Evolving</span><span class="args">()</span>
              
        </dd><dt>Since</dt><dd><p>2.0.0</p></dd></dl></div>
    </li><li name="org.apache.spark.sql.streaming.DataStreamWriter" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="DataStreamWriter[T]extendsAnyRef"></a>
      <a id="DataStreamWriter[T]:DataStreamWriter[T]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="DataStreamWriter.html"><span class="name">DataStreamWriter</span></a><span class="tparams">[<span name="T">T</span>]</span><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../../index.html#org.apache.spark.sql.streaming.package@DataStreamWriter[T]extendsAnyRef" title="Permalink" target="_top">
        <img src="../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Interface used to write a streaming <code>Dataset</code> to external storage systems (e.g.</p><div class="fullcomment"><div class="comment cmt"><p>Interface used to write a streaming <code>Dataset</code> to external storage systems (e.g. file systems,
key-value stores, etc). Use <code>Dataset.writeStream</code> to access this.
</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@Evolving</span><span class="args">()</span>
              
        </dd><dt>Since</dt><dd><p>2.0.0</p></dd></dl></div>
    </li><li name="org.apache.spark.sql.streaming.GroupState" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="GroupState[S]extendsLogicalGroupState[S]"></a>
      <a id="GroupState[S]:GroupState[S]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="GroupState.html"><span class="name">GroupState</span></a><span class="tparams">[<span name="S">S</span>]</span><span class="result"> extends <span class="extype" name="org.apache.spark.sql.catalyst.plans.logical.LogicalGroupState">LogicalGroupState</span>[<span class="extype" name="org.apache.spark.sql.streaming.GroupState.S">S</span>]</span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../../index.html#org.apache.spark.sql.streaming.package@GroupState[S]extendsLogicalGroupState[S]" title="Permalink" target="_top">
        <img src="../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">:: Experimental ::</p><div class="fullcomment"><div class="comment cmt"><p>:: Experimental ::</p><p>Wrapper class for interacting with per-group state data in <code>mapGroupsWithState</code> and
<code>flatMapGroupsWithState</code> operations on <code>KeyValueGroupedDataset</code>.</p><p>Detail description on <code>[map/flatMap]GroupsWithState</code> operation
--------------------------------------------------------------
Both, <code>mapGroupsWithState</code> and <code>flatMapGroupsWithState</code> in <code>KeyValueGroupedDataset</code>
will invoke the user-given function on each group (defined by the grouping function in
<code>Dataset.groupByKey()</code>) while maintaining user-defined per-group state between invocations.
For a static batch Dataset, the function will be invoked once per group. For a streaming
Dataset, the function will be invoked for each group repeatedly in every trigger.
That is, in every batch of the <code>StreamingQuery</code>,
the function will be invoked once for each group that has data in the trigger. Furthermore,
if timeout is set, then the function will invoked on timed out groups (more detail below).</p><p>The function is invoked with following parameters.</p><ul><li>The key of the group.</li><li>An iterator containing all the values for this group.</li><li>A user-defined state object set by previous invocations of the given function.</li></ul><p>In case of a batch Dataset, there is only one invocation and state object will be empty as
there is no prior state. Essentially, for batch Datasets, <code>[map/flatMap]GroupsWithState</code>
is equivalent to <code>[map/flatMap]Groups</code> and any updates to the state and/or timeouts have
no effect.</p><p>The major difference between <code>mapGroupsWithState</code> and <code>flatMapGroupsWithState</code> is that the
former allows the function to return one and only one record, whereas the latter
allows the function to return any number of records (including no records). Furthermore, the
<code>flatMapGroupsWithState</code> is associated with an operation output mode, which can be either
<code>Append</code> or <code>Update</code>. Semantically, this defines whether the output records of one trigger
is effectively replacing the previously output records (from previous triggers) or is appending
to the list of previously output records. Essentially, this defines how the Result Table (refer
to the semantics in the programming guide) is updated, and allows us to reason about the
semantics of later operations.</p><p>Important points to note about the function (both mapGroupsWithState and flatMapGroupsWithState).</p><ul><li>In a trigger, the function will be called only the groups present in the batch. So do not
   assume that the function will be called in every trigger for every group that has state.</li><li>There is no guaranteed ordering of values in the iterator in the function, neither with
   batch, nor with streaming Datasets.</li><li>All the data will be shuffled before applying the function.</li><li>If timeout is set, then the function will also be called with no values.
   See more details on <code>GroupStateTimeout</code> below.</li></ul><p>Important points to note about using <code>GroupState</code>.</p><ul><li>The value of the state cannot be null. So updating state with null will throw
   <code>IllegalArgumentException</code>.</li><li>Operations on <code>GroupState</code> are not thread-safe. This is to avoid memory barriers.</li><li>If <code>remove()</code> is called, then <code>exists()</code> will return <code>false</code>,
   <code>get()</code> will throw <code>NoSuchElementException</code> and <code>getOption()</code> will return <code>None</code></li><li>After that, if <code>update(newState)</code> is called, then <code>exists()</code> will again return <code>true</code>,
   <code>get()</code> and <code>getOption()</code>will return the updated value.</li></ul><p>Important points to note about using <code>GroupStateTimeout</code>.</p><ul><li>The timeout type is a global param across all the groups (set as <code>timeout</code> param in
   <code>[map|flatMap]GroupsWithState</code>, but the exact timeout duration/timestamp is configurable per
   group by calling <code>setTimeout...()</code> in <code>GroupState</code>.</li><li>Timeouts can be either based on processing time (i.e.
   <code>GroupStateTimeout.ProcessingTimeTimeout</code>) or event time (i.e.
   <code>GroupStateTimeout.EventTimeTimeout</code>).</li><li>With <code>ProcessingTimeTimeout</code>, the timeout duration can be set by calling
   <code>GroupState.setTimeoutDuration</code>. The timeout will occur when the clock has advanced by the set
   duration. Guarantees provided by this timeout with a duration of D ms are as follows:<ul><li>Timeout will never be occur before the clock time has advanced by D ms</li><li>Timeout will occur eventually when there is a trigger in the query
     (i.e. after D ms). So there is a no strict upper bound on when the timeout would occur.
     For example, the trigger interval of the query will affect when the timeout actually occurs.
     If there is no data in the stream (for any group) for a while, then their will not be
     any trigger and timeout function call will not occur until there is data.</li><li>Since the processing time timeout is based on the clock time, it is affected by the
     variations in the system clock (i.e. time zone changes, clock skew, etc.).</li></ul></li><li>With <code>EventTimeTimeout</code>, the user also has to specify the the the event time watermark in
   the query using <code>Dataset.withWatermark()</code>. With this setting, data that is older than the
   watermark are filtered out. The timeout can be set for a group by setting a timeout timestamp
   using<code>GroupState.setTimeoutTimestamp()</code>, and the timeout would occur when the watermark
   advances beyond the set timestamp. You can control the timeout delay by two parameters -
   (i) watermark delay and an additional duration beyond the timestamp in the event (which
   is guaranteed to be newer than watermark due to the filtering). Guarantees provided by this
   timeout are as follows:<ul><li>Timeout will never be occur before watermark has exceeded the set timeout.</li><li>Similar to processing time timeouts, there is a no strict upper bound on the delay when
     the timeout actually occurs. The watermark can advance only when there is data in the
     stream, and the event time of the data has actually advanced.</li></ul></li><li>When the timeout occurs for a group, the function is called for that group with no values, and
   <code>GroupState.hasTimedOut()</code> set to true.</li><li>The timeout is reset every time the function is called on a group, that is,
   when the group has new data, or the group has timed out. So the user has to set the timeout
   duration every time the function is called, otherwise there will not be any timeout set.</li></ul><p>Scala example of using GroupState in <code>mapGroupsWithState</code>:</p><pre><span class="cmt">// A mapping function that maintains an integer state for string keys and returns a string.</span>
<span class="cmt">// Additionally, it sets a timeout to remove the state if it has not received data for an hour.</span>
<span class="kw">def</span> mappingFunction(key: <span class="std">String</span>, value: Iterator[<span class="std">Int</span>], state: GroupState[<span class="std">Int</span>]): <span class="std">String</span> = {

  <span class="kw">if</span> (state.hasTimedOut) {                <span class="cmt">// If called when timing out, remove the state</span>
    state.remove()

  } <span class="kw">else</span> <span class="kw">if</span> (state.exists) {              <span class="cmt">// If state exists, use it for processing</span>
    <span class="kw">val</span> existingState = state.get         <span class="cmt">// Get the existing state</span>
    <span class="kw">val</span> shouldRemove = ...                <span class="cmt">// Decide whether to remove the state</span>
    <span class="kw">if</span> (shouldRemove) {
      state.remove()                      <span class="cmt">// Remove the state</span>

    } <span class="kw">else</span> {
      <span class="kw">val</span> newState = ...
      state.update(newState)              <span class="cmt">// Set the new state</span>
      state.setTimeoutDuration(<span class="lit">"1 hour"</span>)  <span class="cmt">// Set the timeout</span>
    }

  } <span class="kw">else</span> {
    <span class="kw">val</span> initialState = ...
    state.update(initialState)            <span class="cmt">// Set the initial state</span>
    state.setTimeoutDuration(<span class="lit">"1 hour"</span>)    <span class="cmt">// Set the timeout</span>
  }
  ...
  <span class="cmt">// return something</span>
}

dataset
  .groupByKey(...)
  .mapGroupsWithState(GroupStateTimeout.ProcessingTimeTimeout)(mappingFunction)</pre><p>Java example of using <code>GroupState</code>:</p><pre><span class="cmt">// A mapping function that maintains an integer state for string keys and returns a string.</span>
<span class="cmt">// Additionally, it sets a timeout to remove the state if it has not received data for an hour.</span>
MapGroupsWithStateFunction&lt;<span class="std">String</span>, Integer, Integer, <span class="std">String</span>&gt; mappingFunction =
   <span class="kw">new</span> MapGroupsWithStateFunction&lt;<span class="std">String</span>, Integer, Integer, <span class="std">String</span>&gt;() {

     @Override
     public <span class="std">String</span> call(<span class="std">String</span> key, Iterator&lt;Integer&gt; value, GroupState&lt;Integer&gt; state) {
       <span class="kw">if</span> (state.hasTimedOut()) {            <span class="cmt">// If called when timing out, remove the state</span>
         state.remove();

       } <span class="kw">else</span> <span class="kw">if</span> (state.exists()) {            <span class="cmt">// If state exists, use it for processing</span>
         int existingState = state.get();      <span class="cmt">// Get the existing state</span>
         boolean shouldRemove = ...;           <span class="cmt">// Decide whether to remove the state</span>
         <span class="kw">if</span> (shouldRemove) {
           state.remove();                     <span class="cmt">// Remove the state</span>

         } <span class="kw">else</span> {
           int newState = ...;
           state.update(newState);             <span class="cmt">// Set the new state</span>
           state.setTimeoutDuration(<span class="lit">"1 hour"</span>); <span class="cmt">// Set the timeout</span>
         }

       } <span class="kw">else</span> {
         int initialState = ...;               <span class="cmt">// Set the initial state</span>
         state.update(initialState);
         state.setTimeoutDuration(<span class="lit">"1 hour"</span>);   <span class="cmt">// Set the timeout</span>
       }
       ...
        <span class="cmt">// return something</span>
     }
   };

dataset
    .groupByKey(...)
    .mapGroupsWithState(
        mappingFunction, Encoders.INT, Encoders.STRING, GroupStateTimeout.ProcessingTimeTimeout);</pre></div><dl class="paramcmts block"><dt class="tparam">S</dt><dd class="cmt"><p>User-defined type of the state to be stored for each group. Must be encodable into
          Spark SQL types (see <code>Encoder</code> for more details).</p></dd></dl><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@Experimental</span><span class="args">()</span>
              
                <span class="name">@Evolving</span><span class="args">()</span>
              
        </dd><dt>Since</dt><dd><p>2.2.0</p></dd></dl></div>
    </li><li name="org.apache.spark.sql.streaming.GroupStateTimeout" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="GroupStateTimeoutextendsObject"></a>
      <a id="GroupStateTimeout:GroupStateTimeout"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="GroupStateTimeout.html"><span class="name">GroupStateTimeout</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../../index.html#org.apache.spark.sql.streaming.package@GroupStateTimeoutextendsObject" title="Permalink" target="_top">
        <img src="../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      
    </li><li name="org.apache.spark.sql.streaming.OutputMode" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="OutputModeextendsObject"></a>
      <a id="OutputMode:OutputMode"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="OutputMode.html"><span class="name">OutputMode</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../../index.html#org.apache.spark.sql.streaming.package@OutputModeextendsObject" title="Permalink" target="_top">
        <img src="../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      
    </li><li name="org.apache.spark.sql.streaming.SinkProgress" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SinkProgressextendsSerializable"></a>
      <a id="SinkProgress:SinkProgress"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="SinkProgress.html"><span class="name">SinkProgress</span></a><span class="result"> extends <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../../index.html#org.apache.spark.sql.streaming.package@SinkProgressextendsSerializable" title="Permalink" target="_top">
        <img src="../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Information about progress made for a sink in the execution of a <a href="StreamingQuery.html" class="extype" name="org.apache.spark.sql.streaming.StreamingQuery">StreamingQuery</a>
during a trigger.</p><div class="fullcomment"><div class="comment cmt"><p>Information about progress made for a sink in the execution of a <a href="StreamingQuery.html" class="extype" name="org.apache.spark.sql.streaming.StreamingQuery">StreamingQuery</a>
during a trigger. See <a href="StreamingQueryProgress.html" class="extype" name="org.apache.spark.sql.streaming.StreamingQueryProgress">StreamingQueryProgress</a> for more information.
</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@Evolving</span><span class="args">()</span>
              
        </dd><dt>Since</dt><dd><p>2.1.0</p></dd></dl></div>
    </li><li name="org.apache.spark.sql.streaming.SourceProgress" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="SourceProgressextendsSerializable"></a>
      <a id="SourceProgress:SourceProgress"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="SourceProgress.html"><span class="name">SourceProgress</span></a><span class="result"> extends <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../../index.html#org.apache.spark.sql.streaming.package@SourceProgressextendsSerializable" title="Permalink" target="_top">
        <img src="../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Information about progress made for a source in the execution of a <a href="StreamingQuery.html" class="extype" name="org.apache.spark.sql.streaming.StreamingQuery">StreamingQuery</a>
during a trigger.</p><div class="fullcomment"><div class="comment cmt"><p>Information about progress made for a source in the execution of a <a href="StreamingQuery.html" class="extype" name="org.apache.spark.sql.streaming.StreamingQuery">StreamingQuery</a>
during a trigger. See <a href="StreamingQueryProgress.html" class="extype" name="org.apache.spark.sql.streaming.StreamingQueryProgress">StreamingQueryProgress</a> for more information.
</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@Evolving</span><span class="args">()</span>
              
        </dd><dt>Since</dt><dd><p>2.1.0</p></dd></dl></div>
    </li><li name="org.apache.spark.sql.streaming.StateOperatorProgress" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="StateOperatorProgressextendsSerializable"></a>
      <a id="StateOperatorProgress:StateOperatorProgress"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="StateOperatorProgress.html"><span class="name">StateOperatorProgress</span></a><span class="result"> extends <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../../index.html#org.apache.spark.sql.streaming.package@StateOperatorProgressextendsSerializable" title="Permalink" target="_top">
        <img src="../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Information about updates made to stateful operators in a <a href="StreamingQuery.html" class="extype" name="org.apache.spark.sql.streaming.StreamingQuery">StreamingQuery</a> during a trigger.</p><div class="fullcomment"><div class="comment cmt"><p>Information about updates made to stateful operators in a <a href="StreamingQuery.html" class="extype" name="org.apache.spark.sql.streaming.StreamingQuery">StreamingQuery</a> during a trigger.
</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@Evolving</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="org.apache.spark.sql.streaming.StreamingQuery" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="StreamingQueryextendsAnyRef"></a>
      <a id="StreamingQuery:StreamingQuery"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="StreamingQuery.html"><span class="name">StreamingQuery</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../../index.html#org.apache.spark.sql.streaming.package@StreamingQueryextendsAnyRef" title="Permalink" target="_top">
        <img src="../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A handle to a query that is executing continuously in the background as new data arrives.</p><div class="fullcomment"><div class="comment cmt"><p>A handle to a query that is executing continuously in the background as new data arrives.
All these methods are thread-safe.</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@Evolving</span><span class="args">()</span>
              
        </dd><dt>Since</dt><dd><p>2.0.0</p></dd></dl></div>
    </li><li name="org.apache.spark.sql.streaming.StreamingQueryException" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="StreamingQueryExceptionextendsException"></a>
      <a id="StreamingQueryException:StreamingQueryException"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="StreamingQueryException.html"><span class="name">StreamingQueryException</span></a><span class="result"> extends <span class="extype" name="scala.Exception">Exception</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../../index.html#org.apache.spark.sql.streaming.package@StreamingQueryExceptionextendsException" title="Permalink" target="_top">
        <img src="../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Exception that stopped a <a href="StreamingQuery.html" class="extype" name="org.apache.spark.sql.streaming.StreamingQuery">StreamingQuery</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Exception that stopped a <a href="StreamingQuery.html" class="extype" name="org.apache.spark.sql.streaming.StreamingQuery">StreamingQuery</a>. Use <code>cause</code> get the actual exception
that caused the failure.</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@Evolving</span><span class="args">()</span>
              
        </dd><dt>Since</dt><dd><p>2.0.0</p></dd></dl></div>
    </li><li name="org.apache.spark.sql.streaming.StreamingQueryListener" visbl="pub" data-isabs="true" fullComment="yes" group="Ungrouped">
      <a id="StreamingQueryListenerextendsAnyRef"></a>
      <a id="StreamingQueryListener:StreamingQueryListener"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="StreamingQueryListener.html"><span class="name">StreamingQueryListener</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../../index.html#org.apache.spark.sql.streaming.package@StreamingQueryListenerextendsAnyRef" title="Permalink" target="_top">
        <img src="../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Interface for listening to events related to <a href="StreamingQuery.html" class="extype" name="org.apache.spark.sql.streaming.StreamingQuery">StreamingQueries</a>.</p><div class="fullcomment"><div class="comment cmt"><p>Interface for listening to events related to <a href="StreamingQuery.html" class="extype" name="org.apache.spark.sql.streaming.StreamingQuery">StreamingQueries</a>.</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@Evolving</span><span class="args">()</span>
              
        </dd><dt>Since</dt><dd><p>2.0.0</p></dd><dt>Note</dt><dd><span class="cmt"><p>The methods are not thread-safe as they may be called from different threads.</p></span></dd></dl></div>
    </li><li name="org.apache.spark.sql.streaming.StreamingQueryManager" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="StreamingQueryManagerextendsLogging"></a>
      <a id="StreamingQueryManager:StreamingQueryManager"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="StreamingQueryManager.html"><span class="name">StreamingQueryManager</span></a><span class="result"> extends <a href="../../internal/Logging.html" class="extype" name="org.apache.spark.internal.Logging">Logging</a></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../../index.html#org.apache.spark.sql.streaming.package@StreamingQueryManagerextendsLogging" title="Permalink" target="_top">
        <img src="../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A class to manage all the <a href="StreamingQuery.html" class="extype" name="org.apache.spark.sql.streaming.StreamingQuery">StreamingQuery</a> active in a <code>SparkSession</code>.</p><div class="fullcomment"><div class="comment cmt"><p>A class to manage all the <a href="StreamingQuery.html" class="extype" name="org.apache.spark.sql.streaming.StreamingQuery">StreamingQuery</a> active in a <code>SparkSession</code>.
</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@Evolving</span><span class="args">()</span>
              
        </dd><dt>Since</dt><dd><p>2.0.0</p></dd></dl></div>
    </li><li name="org.apache.spark.sql.streaming.StreamingQueryProgress" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="StreamingQueryProgressextendsSerializable"></a>
      <a id="StreamingQueryProgress:StreamingQueryProgress"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="StreamingQueryProgress.html"><span class="name">StreamingQueryProgress</span></a><span class="result"> extends <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../../index.html#org.apache.spark.sql.streaming.package@StreamingQueryProgressextendsSerializable" title="Permalink" target="_top">
        <img src="../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Information about progress made in the execution of a <a href="StreamingQuery.html" class="extype" name="org.apache.spark.sql.streaming.StreamingQuery">StreamingQuery</a> during
a trigger.</p><div class="fullcomment"><div class="comment cmt"><p>Information about progress made in the execution of a <a href="StreamingQuery.html" class="extype" name="org.apache.spark.sql.streaming.StreamingQuery">StreamingQuery</a> during
a trigger. Each event relates to processing done for a single trigger of the streaming
query. Events are emitted even when no new data is available to be processed.
</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@Evolving</span><span class="args">()</span>
              
        </dd><dt>Since</dt><dd><p>2.1.0</p></dd></dl></div>
    </li><li name="org.apache.spark.sql.streaming.StreamingQueryStatus" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="StreamingQueryStatusextendsSerializable"></a>
      <a id="StreamingQueryStatus:StreamingQueryStatus"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="StreamingQueryStatus.html"><span class="name">StreamingQueryStatus</span></a><span class="result"> extends <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../../index.html#org.apache.spark.sql.streaming.package@StreamingQueryStatusextendsSerializable" title="Permalink" target="_top">
        <img src="../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Reports information about the instantaneous status of a streaming query.</p><div class="fullcomment"><div class="comment cmt"><p>Reports information about the instantaneous status of a streaming query.
</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@Evolving</span><span class="args">()</span>
              
        </dd><dt>Since</dt><dd><p>2.1.0</p></dd></dl></div>
    </li><li name="org.apache.spark.sql.streaming.Trigger" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="TriggerextendsObject"></a>
      <a id="Trigger:Trigger"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="Trigger.html"><span class="name">Trigger</span></a><span class="result"> extends <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../../index.html#org.apache.spark.sql.streaming.package@TriggerextendsObject" title="Permalink" target="_top">
        <img src="../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      
    </li><li name="org.apache.spark.sql.streaming.ProcessingTime" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ProcessingTimeextendsTriggerwithProductwithSerializable"></a>
      <a id="ProcessingTime:ProcessingTime"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="ProcessingTime.html"><span class="name deprecated" title="Deprecated: (Since version 2.2.0) use Trigger.ProcessingTime(intervalMs)">ProcessingTime</span></a><span class="params">(<span name="intervalMs">intervalMs: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result"> extends <a href="Trigger.html" class="extype" name="org.apache.spark.sql.streaming.Trigger">Trigger</a> with <span class="extype" name="scala.Product">Product</span> with <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../../index.html#org.apache.spark.sql.streaming.package@ProcessingTimeextendsTriggerwithProductwithSerializable" title="Permalink" target="_top">
        <img src="../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">A trigger that runs a query periodically based on the processing time.</p><div class="fullcomment"><div class="comment cmt"><p>A trigger that runs a query periodically based on the processing time. If <code>interval</code> is 0,
the query will run as fast as possible.</p><p>Scala Example:</p><pre>df.writeStream.trigger(ProcessingTime(<span class="lit">"10 seconds"</span>))

<span class="kw">import</span> scala.concurrent.duration._
df.writeStream.trigger(ProcessingTime(<span class="num">10.</span>seconds))</pre><p>Java Example:</p><pre>df.writeStream.trigger(ProcessingTime.create(<span class="lit">"10 seconds"</span>))

<span class="kw">import</span> java.util.concurrent.TimeUnit
df.writeStream.trigger(ProcessingTime.create(<span class="num">10</span>, TimeUnit.SECONDS))</pre></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@Evolving</span><span class="args">()</span>
              
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.2.0)</i> use Trigger.ProcessingTime(intervalMs)</p></dd><dt>Since</dt><dd><p>2.0.0</p></dd></dl></div>
    </li></ol>
            </div>

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="org.apache.spark.sql.streaming.StreamingQueryListener" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="StreamingQueryListener"></a>
      <a id="StreamingQueryListener:StreamingQueryListener"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="StreamingQueryListener$.html"><span class="name">StreamingQueryListener</span></a>
      </span>
      </h4><span class="permalink">
      <a href="../../../../../index.html#org.apache.spark.sql.streaming.package@StreamingQueryListener" title="Permalink" target="_top">
        <img src="../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Companion object of <a href="StreamingQueryListener.html" class="extype" name="org.apache.spark.sql.streaming.StreamingQueryListener">StreamingQueryListener</a> that defines the listener events.</p><div class="fullcomment"><div class="comment cmt"><p>Companion object of <a href="StreamingQueryListener.html" class="extype" name="org.apache.spark.sql.streaming.StreamingQueryListener">StreamingQueryListener</a> that defines the listener events.</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@Evolving</span><span class="args">()</span>
              
        </dd><dt>Since</dt><dd><p>2.0.0</p></dd></dl></div>
    </li></ol>
            </div>

        

        <div id="values" class="values members">
              <h3>Deprecated Value Members</h3>
              <ol><li name="org.apache.spark.sql.streaming.ProcessingTime" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ProcessingTime"></a>
      <a id="ProcessingTime:ProcessingTime"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="ProcessingTime$.html"><span class="name deprecated" title="Deprecated: (Since version 2.2.0) use Trigger.ProcessingTime(intervalMs)">ProcessingTime</span></a><span class="result"> extends <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4><span class="permalink">
      <a href="../../../../../index.html#org.apache.spark.sql.streaming.package@ProcessingTime" title="Permalink" target="_top">
        <img src="../../../../../lib/permalink.png" alt="Permalink" />
      </a>
    </span>
      <p class="shortcomment cmt">Used to create <a href="ProcessingTime.html" class="extype" name="org.apache.spark.sql.streaming.ProcessingTime">ProcessingTime</a> triggers for <a href="StreamingQuery.html" class="extype" name="org.apache.spark.sql.streaming.StreamingQuery">StreamingQuery</a>s.</p><div class="fullcomment"><div class="comment cmt"><p>Used to create <a href="ProcessingTime.html" class="extype" name="org.apache.spark.sql.streaming.ProcessingTime">ProcessingTime</a> triggers for <a href="StreamingQuery.html" class="extype" name="org.apache.spark.sql.streaming.StreamingQuery">StreamingQuery</a>s.
</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@Evolving</span><span class="args">()</span>
              
                <span class="name">@deprecated</span>
              
        </dd><dt>Deprecated</dt><dd class="cmt"><p><i>(Since version 2.2.0)</i> use Trigger.ProcessingTime(intervalMs)</p></dd><dt>Since</dt><dd><p>2.0.0</p></dd></dl></div>
    </li></ol>
            </div>
        </div>

        <div id="inheritedMembers">
        
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>
