<table class="table">
  <thead>
    <tr>
      <th style="width:25%">Function</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>expr1 % expr2</td>
      <td>Returns the remainder after `expr1`/`expr2`.</td>
    </tr>
    <tr>
      <td>expr1 * expr2</td>
      <td>Returns `expr1`*`expr2`.</td>
    </tr>
    <tr>
      <td>expr1 + expr2</td>
      <td>Returns `expr1`+`expr2`.</td>
    </tr>
    <tr>
      <td>expr1 - expr2</td>
      <td>Returns `expr1`-`expr2`.</td>
    </tr>
    <tr>
      <td>expr1 / expr2</td>
      <td>Returns `expr1`/`expr2`. It always performs floating point division.</td>
    </tr>
    <tr>
      <td>abs(expr)</td>
      <td>Returns the absolute value of the numeric or interval value.</td>
    </tr>
    <tr>
      <td>acos(expr)</td>
      <td>Returns the inverse cosine (a.k.a. arc cosine) of `expr`, as if computed by
      `java.lang.Math.acos`.</td>
    </tr>
    <tr>
      <td>acosh(expr)</td>
      <td>Returns inverse hyperbolic cosine of `expr`.</td>
    </tr>
    <tr>
      <td>asin(expr)</td>
      <td>Returns the inverse sine (a.k.a. arc sine) the arc sin of `expr`,
      as if computed by `java.lang.Math.asin`.</td>
    </tr>
    <tr>
      <td>asinh(expr)</td>
      <td>Returns inverse hyperbolic sine of `expr`.</td>
    </tr>
    <tr>
      <td>atan(expr)</td>
      <td>Returns the inverse tangent (a.k.a. arc tangent) of `expr`, as if computed by
      `java.lang.Math.atan`</td>
    </tr>
    <tr>
      <td>atan2(exprY, exprX)</td>
      <td>Returns the angle in radians between the positive x-axis of a plane
      and the point given by the coordinates (`exprX`, `exprY`), as if computed by
      `java.lang.Math.atan2`.</td>
    </tr>
    <tr>
      <td>atanh(expr)</td>
      <td>Returns inverse hyperbolic tangent of `expr`.</td>
    </tr>
    <tr>
      <td>bin(expr)</td>
      <td>Returns the string representation of the long value `expr` represented in binary.</td>
    </tr>
    <tr>
      <td>bround(expr, d)</td>
      <td>Returns `expr` rounded to `d` decimal places using HALF_EVEN rounding mode.</td>
    </tr>
    <tr>
      <td>cbrt(expr)</td>
      <td>Returns the cube root of `expr`.</td>
    </tr>
    <tr>
      <td>ceil(expr[, scale])</td>
      <td>Returns the smallest number after rounding up that is not smaller than `expr`. An optional `scale` parameter can be specified to control the rounding behavior.</td>
    </tr>
    <tr>
      <td>ceiling(expr[, scale])</td>
      <td>Returns the smallest number after rounding up that is not smaller than `expr`. An optional `scale` parameter can be specified to control the rounding behavior.</td>
    </tr>
    <tr>
      <td>conv(num, from_base, to_base)</td>
      <td>Convert `num` from `from_base` to `to_base`.</td>
    </tr>
    <tr>
      <td>cos(expr)</td>
      <td>Returns the cosine of `expr`, as if computed by
      `java.lang.Math.cos`.</td>
    </tr>
    <tr>
      <td>cosh(expr)</td>
      <td>Returns the hyperbolic cosine of `expr`, as if computed by
        `java.lang.Math.cosh`.</td>
    </tr>
    <tr>
      <td>cot(expr)</td>
      <td>Returns the cotangent of `expr`, as if computed by `1/java.lang.Math.tan`.</td>
    </tr>
    <tr>
      <td>csc(expr)</td>
      <td>Returns the cosecant of `expr`, as if computed by `1/java.lang.Math.sin`.</td>
    </tr>
    <tr>
      <td>degrees(expr)</td>
      <td>Converts radians to degrees.</td>
    </tr>
    <tr>
      <td>expr1 div expr2</td>
      <td>Divide `expr1` by `expr2`. It returns NULL if an operand is NULL or `expr2` is 0. The result is casted to long.</td>
    </tr>
    <tr>
      <td>e()</td>
      <td>Returns Euler's number, e.</td>
    </tr>
    <tr>
      <td>exp(expr)</td>
      <td>Returns e to the power of `expr`.</td>
    </tr>
    <tr>
      <td>expm1(expr) - Returns exp(`expr`)</td>
      <td>1.</td>
    </tr>
    <tr>
      <td>factorial(expr)</td>
      <td>Returns the factorial of `expr`. `expr` is [0..20]. Otherwise, null.</td>
    </tr>
    <tr>
      <td>floor(expr[, scale])</td>
      <td>Returns the largest number after rounding down that is not greater than `expr`. An optional `scale` parameter can be specified to control the rounding behavior.</td>
    </tr>
    <tr>
      <td>greatest(expr, ...)</td>
      <td>Returns the greatest value of all parameters, skipping null values.</td>
    </tr>
    <tr>
      <td>hex(expr)</td>
      <td>Converts `expr` to hexadecimal.</td>
    </tr>
    <tr>
      <td>hypot(expr1, expr2)</td>
      <td>Returns sqrt(`expr1`**2 + `expr2`**2).</td>
    </tr>
    <tr>
      <td>least(expr, ...)</td>
      <td>Returns the least value of all parameters, skipping null values.</td>
    </tr>
    <tr>
      <td>ln(expr)</td>
      <td>Returns the natural logarithm (base e) of `expr`.</td>
    </tr>
    <tr>
      <td>log(base, expr)</td>
      <td>Returns the logarithm of `expr` with `base`.</td>
    </tr>
    <tr>
      <td>log10(expr)</td>
      <td>Returns the logarithm of `expr` with base 10.</td>
    </tr>
    <tr>
      <td>log1p(expr)</td>
      <td>Returns log(1 + `expr`).</td>
    </tr>
    <tr>
      <td>log2(expr)</td>
      <td>Returns the logarithm of `expr` with base 2.</td>
    </tr>
    <tr>
      <td>expr1 mod expr2</td>
      <td>Returns the remainder after `expr1`/`expr2`.</td>
    </tr>
    <tr>
      <td>negative(expr)</td>
      <td>Returns the negated value of `expr`.</td>
    </tr>
    <tr>
      <td>pi()</td>
      <td>Returns pi.</td>
    </tr>
    <tr>
      <td>pmod(expr1, expr2)</td>
      <td>Returns the positive value of `expr1` mod `expr2`.</td>
    </tr>
    <tr>
      <td>positive(expr)</td>
      <td>Returns the value of `expr`.</td>
    </tr>
    <tr>
      <td>pow(expr1, expr2)</td>
      <td>Raises `expr1` to the power of `expr2`.</td>
    </tr>
    <tr>
      <td>power(expr1, expr2)</td>
      <td>Raises `expr1` to the power of `expr2`.</td>
    </tr>
    <tr>
      <td>radians(expr)</td>
      <td>Converts degrees to radians.</td>
    </tr>
    <tr>
      <td>rand([seed])</td>
      <td>Returns a random value with independent and identically distributed (i.i.d.) uniformly distributed values in [0, 1).</td>
    </tr>
    <tr>
      <td>randn([seed])</td>
      <td>Returns a random value with independent and identically distributed (i.i.d.) values drawn from the standard normal distribution.</td>
    </tr>
    <tr>
      <td>random([seed])</td>
      <td>Returns a random value with independent and identically distributed (i.i.d.) uniformly distributed values in [0, 1).</td>
    </tr>
    <tr>
      <td>rint(expr)</td>
      <td>Returns the double value that is closest in value to the argument and is equal to a mathematical integer.</td>
    </tr>
    <tr>
      <td>round(expr, d)</td>
      <td>Returns `expr` rounded to `d` decimal places using HALF_UP rounding mode.</td>
    </tr>
    <tr>
      <td>sec(expr)</td>
      <td>Returns the secant of `expr`, as if computed by `1/java.lang.Math.cos`.</td>
    </tr>
    <tr>
      <td>shiftleft(base, expr)</td>
      <td>Bitwise left shift.</td>
    </tr>
    <tr>
      <td>sign(expr)</td>
      <td>Returns -1.0, 0.0 or 1.0 as `expr` is negative, 0 or positive.</td>
    </tr>
    <tr>
      <td>signum(expr)</td>
      <td>Returns -1.0, 0.0 or 1.0 as `expr` is negative, 0 or positive.</td>
    </tr>
    <tr>
      <td>sin(expr)</td>
      <td>Returns the sine of `expr`, as if computed by `java.lang.Math.sin`.</td>
    </tr>
    <tr>
      <td>sinh(expr)</td>
      <td>Returns hyperbolic sine of `expr`, as if computed by `java.lang.Math.sinh`.</td>
    </tr>
    <tr>
      <td>sqrt(expr)</td>
      <td>Returns the square root of `expr`.</td>
    </tr>
    <tr>
      <td>tan(expr)</td>
      <td>Returns the tangent of `expr`, as if computed by `java.lang.Math.tan`.</td>
    </tr>
    <tr>
      <td>tanh(expr)</td>
      <td>Returns the hyperbolic tangent of `expr`, as if computed by
      `java.lang.Math.tanh`.</td>
    </tr>
    <tr>
      <td>try_add(expr1, expr2)</td>
      <td>Returns the sum of `expr1`and `expr2` and the result is null on overflow. The acceptable input types are the same with the `+` operator.</td>
    </tr>
    <tr>
      <td>try_divide(dividend, divisor)</td>
      <td>Returns `dividend`/`divisor`. It always performs floating point division. Its result is always null if `expr2` is 0. `dividend` must be a numeric or an interval. `divisor` must be a numeric.</td>
    </tr>
    <tr>
      <td>try_multiply(expr1, expr2)</td>
      <td>Returns `expr1`*`expr2` and the result is null on overflow. The acceptable input types are the same with the `*` operator.</td>
    </tr>
    <tr>
      <td>try_subtract(expr1, expr2)</td>
      <td>Returns `expr1`-`expr2` and the result is null on overflow. The acceptable input types are the same with the `-` operator.</td>
    </tr>
    <tr>
      <td>unhex(expr)</td>
      <td>Converts hexadecimal `expr` to binary.</td>
    </tr>
    <tr>
      <td>width_bucket(value, min_value, max_value, num_bucket)</td>
      <td>Returns the bucket number to which
      `value` would be assigned in an equiwidth histogram with `num_bucket` buckets,
      in the range `min_value` to `max_value`."</td>
    </tr>
  </tbody>
</table>
