
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>pyspark.pandas.window &#8212; PySpark 3.3.1 documentation</title>
    
  <link rel="stylesheet" href="../../../_static/css/index.73d71520a4ca3b99cfee5594769eaaae.css">

    
  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../../../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../../../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/pyspark.css" />
    
  <link rel="preload" as="script" href="../../../_static/js/index.3da636dd464baa7582d2.js">

    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="canonical" href="https://spark.apache.org/docs/latest/api/python/_modules/pyspark/pandas/window.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    <!-- Matomo -->
    <script type="text/javascript">
        var _paq = window._paq = window._paq || [];
        /* tracker methods like "setCustomDimension" should be called before "trackPageView" */
        _paq.push(["disableCookies"]);
        _paq.push(['trackPageView']);
        _paq.push(['enableLinkTracking']);
        (function() {
            var u="https://analytics.apache.org/";
            _paq.push(['setTrackerUrl', u+'matomo.php']);
            _paq.push(['setSiteId', '40']);
            var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
            g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
        })();
    </script>
    <!-- End Matomo Code -->
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main">
<div class="container-xl">

    <a class="navbar-brand" href="../../../index.html">
    
      <img src="../../../_static/spark-logo-reverse.png" class="logo" alt="logo" />
    
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-menu" aria-controls="navbar-menu" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar-menu" class="col-lg-9 collapse navbar-collapse">
      <ul id="navbar-main-elements" class="navbar-nav mr-auto">
        
        
        <li class="nav-item ">
            <a class="nav-link" href="../../../getting_started/index.html">Getting Started</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../../user_guide/index.html">User Guide</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../../reference/index.html">API Reference</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../../development/index.html">Development</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../../migration_guide/index.html">Migration Guide</a>
        </li>
        
        
      </ul>


      

      <ul class="navbar-nav">
        
        
      </ul>
    </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
          <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">

    <div class="bd-toc-item active">
    
  
    <ul class="nav bd-sidenav">
        
        
        
        
        
        
        
        
        
        
        
      </ul>
  
  </nav>
          </div>
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
              

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
    </ul>
</nav>


              
          </div>
          

          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for pyspark.pandas.window</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># Licensed to the Apache Software Foundation (ASF) under one or more</span>
<span class="c1"># contributor license agreements.  See the NOTICE file distributed with</span>
<span class="c1"># this work for additional information regarding copyright ownership.</span>
<span class="c1"># The ASF licenses this file to You under the Apache License, Version 2.0</span>
<span class="c1"># (the &quot;License&quot;); you may not use this file except in compliance with</span>
<span class="c1"># the License.  You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#    http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1">#</span>
<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span>

<span class="kn">from</span> <span class="nn">pyspark.sql</span> <span class="kn">import</span> <span class="n">Window</span>
<span class="kn">from</span> <span class="nn">pyspark.sql</span> <span class="kn">import</span> <span class="n">functions</span> <span class="k">as</span> <span class="n">F</span>
<span class="kn">from</span> <span class="nn">pyspark.pandas.missing.window</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">MissingPandasLikeRolling</span><span class="p">,</span>
    <span class="n">MissingPandasLikeRollingGroupby</span><span class="p">,</span>
    <span class="n">MissingPandasLikeExpanding</span><span class="p">,</span>
    <span class="n">MissingPandasLikeExpandingGroupby</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># For running doctests and reference resolution in PyCharm.</span>
<span class="kn">from</span> <span class="nn">pyspark</span> <span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">ps</span>  <span class="c1"># noqa: F401</span>
<span class="kn">from</span> <span class="nn">pyspark.pandas._typing</span> <span class="kn">import</span> <span class="n">FrameLike</span>
<span class="kn">from</span> <span class="nn">pyspark.pandas.groupby</span> <span class="kn">import</span> <span class="n">GroupBy</span><span class="p">,</span> <span class="n">DataFrameGroupBy</span>
<span class="kn">from</span> <span class="nn">pyspark.pandas.internal</span> <span class="kn">import</span> <span class="n">NATURAL_ORDER_COLUMN_NAME</span><span class="p">,</span> <span class="n">SPARK_INDEX_NAME_FORMAT</span>
<span class="kn">from</span> <span class="nn">pyspark.pandas.spark</span> <span class="kn">import</span> <span class="n">functions</span> <span class="k">as</span> <span class="n">SF</span>
<span class="kn">from</span> <span class="nn">pyspark.pandas.utils</span> <span class="kn">import</span> <span class="n">scol_for</span>
<span class="kn">from</span> <span class="nn">pyspark.sql.column</span> <span class="kn">import</span> <span class="n">Column</span>
<span class="kn">from</span> <span class="nn">pyspark.sql.window</span> <span class="kn">import</span> <span class="n">WindowSpec</span>


<span class="k">class</span> <span class="nc">RollingAndExpanding</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">FrameLike</span><span class="p">],</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="p">:</span> <span class="n">WindowSpec</span><span class="p">,</span> <span class="n">min_periods</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_window</span> <span class="o">=</span> <span class="n">window</span>
        <span class="c1"># This unbounded Window is later used to handle &#39;min_periods&#39; for now.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unbounded_window</span> <span class="o">=</span> <span class="n">Window</span><span class="o">.</span><span class="n">orderBy</span><span class="p">(</span><span class="n">NATURAL_ORDER_COLUMN_NAME</span><span class="p">)</span><span class="o">.</span><span class="n">rowsBetween</span><span class="p">(</span>
            <span class="n">Window</span><span class="o">.</span><span class="n">unboundedPreceding</span><span class="p">,</span> <span class="n">Window</span><span class="o">.</span><span class="n">currentRow</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_min_periods</span> <span class="o">=</span> <span class="n">min_periods</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_apply_as_series_or_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Column</span><span class="p">],</span> <span class="n">Column</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps a function that handles Spark column in order</span>
<span class="sd">        to support it in both pandas-on-Spark Series and DataFrame.</span>
<span class="sd">        Note that the given `func` name should be same as the API&#39;s method name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="n">scol</span><span class="p">:</span> <span class="n">Column</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">when</span><span class="p">(</span>
                <span class="n">F</span><span class="o">.</span><span class="n">row_number</span><span class="p">()</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unbounded_window</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_periods</span><span class="p">,</span>
                <span class="n">F</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">scol</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window</span><span class="p">),</span>
            <span class="p">)</span><span class="o">.</span><span class="n">otherwise</span><span class="p">(</span><span class="n">SF</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_as_series_or_frame</span><span class="p">(</span><span class="nb">sum</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="n">scol</span><span class="p">:</span> <span class="n">Column</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">when</span><span class="p">(</span>
                <span class="n">F</span><span class="o">.</span><span class="n">row_number</span><span class="p">()</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unbounded_window</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_periods</span><span class="p">,</span>
                <span class="n">F</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">scol</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window</span><span class="p">),</span>
            <span class="p">)</span><span class="o">.</span><span class="n">otherwise</span><span class="p">(</span><span class="n">SF</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_as_series_or_frame</span><span class="p">(</span><span class="nb">min</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="n">scol</span><span class="p">:</span> <span class="n">Column</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">when</span><span class="p">(</span>
                <span class="n">F</span><span class="o">.</span><span class="n">row_number</span><span class="p">()</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unbounded_window</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_periods</span><span class="p">,</span>
                <span class="n">F</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">scol</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window</span><span class="p">),</span>
            <span class="p">)</span><span class="o">.</span><span class="n">otherwise</span><span class="p">(</span><span class="n">SF</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_as_series_or_frame</span><span class="p">(</span><span class="nb">max</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">scol</span><span class="p">:</span> <span class="n">Column</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">when</span><span class="p">(</span>
                <span class="n">F</span><span class="o">.</span><span class="n">row_number</span><span class="p">()</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unbounded_window</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_periods</span><span class="p">,</span>
                <span class="n">F</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">scol</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window</span><span class="p">),</span>
            <span class="p">)</span><span class="o">.</span><span class="n">otherwise</span><span class="p">(</span><span class="n">SF</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_as_series_or_frame</span><span class="p">(</span><span class="n">mean</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="n">scol</span><span class="p">:</span> <span class="n">Column</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">when</span><span class="p">(</span>
                <span class="n">F</span><span class="o">.</span><span class="n">row_number</span><span class="p">()</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unbounded_window</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_periods</span><span class="p">,</span>
                <span class="n">F</span><span class="o">.</span><span class="n">stddev</span><span class="p">(</span><span class="n">scol</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window</span><span class="p">),</span>
            <span class="p">)</span><span class="o">.</span><span class="n">otherwise</span><span class="p">(</span><span class="n">SF</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_as_series_or_frame</span><span class="p">(</span><span class="n">std</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="n">scol</span><span class="p">:</span> <span class="n">Column</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">when</span><span class="p">(</span>
                <span class="n">F</span><span class="o">.</span><span class="n">row_number</span><span class="p">()</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unbounded_window</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_periods</span><span class="p">,</span>
                <span class="n">F</span><span class="o">.</span><span class="n">variance</span><span class="p">(</span><span class="n">scol</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window</span><span class="p">),</span>
            <span class="p">)</span><span class="o">.</span><span class="n">otherwise</span><span class="p">(</span><span class="n">SF</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_as_series_or_frame</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">RollingLike</span><span class="p">(</span><span class="n">RollingAndExpanding</span><span class="p">[</span><span class="n">FrameLike</span><span class="p">]):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">window</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">min_periods</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">window</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;window must be &gt;= 0&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">min_periods</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">min_periods</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;min_periods must be &gt;= 0&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">min_periods</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># TODO: &#39;min_periods&#39; is not equivalent in pandas because it does not count NA as</span>
            <span class="c1">#  a value.</span>
            <span class="n">min_periods</span> <span class="o">=</span> <span class="n">window</span>

        <span class="n">window_spec</span> <span class="o">=</span> <span class="n">Window</span><span class="o">.</span><span class="n">orderBy</span><span class="p">(</span><span class="n">NATURAL_ORDER_COLUMN_NAME</span><span class="p">)</span><span class="o">.</span><span class="n">rowsBetween</span><span class="p">(</span>
            <span class="n">Window</span><span class="o">.</span><span class="n">currentRow</span> <span class="o">-</span> <span class="p">(</span><span class="n">window</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Window</span><span class="o">.</span><span class="n">currentRow</span>
        <span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">window_spec</span><span class="p">,</span> <span class="n">min_periods</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="n">scol</span><span class="p">:</span> <span class="n">Column</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">scol</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_as_series_or_frame</span><span class="p">(</span><span class="n">count</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span>


<span class="k">class</span> <span class="nc">Rolling</span><span class="p">(</span><span class="n">RollingLike</span><span class="p">[</span><span class="n">FrameLike</span><span class="p">]):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">psdf_or_psser</span><span class="p">:</span> <span class="n">FrameLike</span><span class="p">,</span>
        <span class="n">window</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">min_periods</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pyspark.pandas.frame</span> <span class="kn">import</span> <span class="n">DataFrame</span>
        <span class="kn">from</span> <span class="nn">pyspark.pandas.series</span> <span class="kn">import</span> <span class="n">Series</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">min_periods</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_psdf_or_psser</span> <span class="o">=</span> <span class="n">psdf_or_psser</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">psdf_or_psser</span><span class="p">,</span> <span class="p">(</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">Series</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;psdf_or_psser must be a series or dataframe; however, got: </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">psdf_or_psser</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">MissingPandasLikeRolling</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
            <span class="n">property_or_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">MissingPandasLikeRolling</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">property_or_func</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">property_or_func</span><span class="o">.</span><span class="n">fget</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">property_or_func</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_apply_as_series_or_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Column</span><span class="p">],</span> <span class="n">Column</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psdf_or_psser</span><span class="o">.</span><span class="n">_apply_series_op</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">psser</span><span class="p">:</span> <span class="n">psser</span><span class="o">.</span><span class="n">_with_new_scol</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">psser</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span><span class="p">)),</span>  <span class="c1"># TODO: dtype?</span>
            <span class="n">should_resolve</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Rolling.count"><a class="viewcode-back" href="../../../reference/pyspark.pandas/api/pyspark.pandas.window.Rolling.count.html#pyspark.pandas.window.Rolling.count">[docs]</a>    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The rolling count of any non-NaN observations inside the window.</span>

<span class="sd">        .. note:: the current implementation of this API uses Spark&#39;s Window without</span>
<span class="sd">            specifying partition specification. This leads to move all data into</span>
<span class="sd">            single partition in single machine and could cause serious</span>
<span class="sd">            performance degradation. Avoid this method against very large dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series.expanding : Calling object with Series data.</span>
<span class="sd">        DataFrame.expanding : Calling object with DataFrames.</span>
<span class="sd">        Series.count : Count of the full Series.</span>
<span class="sd">        DataFrame.count : Count of the full DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = ps.Series([2, 3, float(&quot;nan&quot;), 10])</span>
<span class="sd">        &gt;&gt;&gt; s.rolling(1).count()</span>
<span class="sd">        0    1.0</span>
<span class="sd">        1    1.0</span>
<span class="sd">        2    0.0</span>
<span class="sd">        3    1.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; s.rolling(3).count()</span>
<span class="sd">        0    1.0</span>
<span class="sd">        1    2.0</span>
<span class="sd">        2    2.0</span>
<span class="sd">        3    2.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; s.to_frame().rolling(1).count()</span>
<span class="sd">             0</span>
<span class="sd">        0  1.0</span>
<span class="sd">        1  1.0</span>
<span class="sd">        2  0.0</span>
<span class="sd">        3  1.0</span>

<span class="sd">        &gt;&gt;&gt; s.to_frame().rolling(3).count()</span>
<span class="sd">             0</span>
<span class="sd">        0  1.0</span>
<span class="sd">        1  2.0</span>
<span class="sd">        2  2.0</span>
<span class="sd">        3  2.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">count</span><span class="p">()</span></div>

<div class="viewcode-block" id="Rolling.sum"><a class="viewcode-back" href="../../../reference/pyspark.pandas/api/pyspark.pandas.window.Rolling.sum.html#pyspark.pandas.window.Rolling.sum">[docs]</a>    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate rolling summation of given DataFrame or Series.</span>

<span class="sd">        .. note:: the current implementation of this API uses Spark&#39;s Window without</span>
<span class="sd">            specifying partition specification. This leads to move all data into</span>
<span class="sd">            single partition in single machine and could cause serious</span>
<span class="sd">            performance degradation. Avoid this method against very large dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Same type as the input, with the same index, containing the</span>
<span class="sd">            rolling summation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.expanding : Calling object with Series data.</span>
<span class="sd">        DataFrame.expanding : Calling object with DataFrames.</span>
<span class="sd">        Series.sum : Reducing sum for Series.</span>
<span class="sd">        DataFrame.sum : Reducing sum for DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = ps.Series([4, 3, 5, 2, 6])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    4</span>
<span class="sd">        1    3</span>
<span class="sd">        2    5</span>
<span class="sd">        3    2</span>
<span class="sd">        4    6</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; s.rolling(2).sum()</span>
<span class="sd">        0    NaN</span>
<span class="sd">        1    7.0</span>
<span class="sd">        2    8.0</span>
<span class="sd">        3    7.0</span>
<span class="sd">        4    8.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; s.rolling(3).sum()</span>
<span class="sd">        0     NaN</span>
<span class="sd">        1     NaN</span>
<span class="sd">        2    12.0</span>
<span class="sd">        3    10.0</span>
<span class="sd">        4    13.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        For DataFrame, each rolling summation is computed column-wise.</span>

<span class="sd">        &gt;&gt;&gt; df = ps.DataFrame({&quot;A&quot;: s.to_numpy(), &quot;B&quot;: s.to_numpy() ** 2})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A   B</span>
<span class="sd">        0  4  16</span>
<span class="sd">        1  3   9</span>
<span class="sd">        2  5  25</span>
<span class="sd">        3  2   4</span>
<span class="sd">        4  6  36</span>

<span class="sd">        &gt;&gt;&gt; df.rolling(2).sum()</span>
<span class="sd">             A     B</span>
<span class="sd">        0  NaN   NaN</span>
<span class="sd">        1  7.0  25.0</span>
<span class="sd">        2  8.0  34.0</span>
<span class="sd">        3  7.0  29.0</span>
<span class="sd">        4  8.0  40.0</span>

<span class="sd">        &gt;&gt;&gt; df.rolling(3).sum()</span>
<span class="sd">              A     B</span>
<span class="sd">        0   NaN   NaN</span>
<span class="sd">        1   NaN   NaN</span>
<span class="sd">        2  12.0  50.0</span>
<span class="sd">        3  10.0  38.0</span>
<span class="sd">        4  13.0  65.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span></div>

<div class="viewcode-block" id="Rolling.min"><a class="viewcode-back" href="../../../reference/pyspark.pandas/api/pyspark.pandas.window.Rolling.min.html#pyspark.pandas.window.Rolling.min">[docs]</a>    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the rolling minimum.</span>

<span class="sd">        .. note:: the current implementation of this API uses Spark&#39;s Window without</span>
<span class="sd">            specifying partition specification. This leads to move all data into</span>
<span class="sd">            single partition in single machine and could cause serious</span>
<span class="sd">            performance degradation. Avoid this method against very large dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Returned object type is determined by the caller of the rolling</span>
<span class="sd">            calculation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.rolling : Calling object with a Series.</span>
<span class="sd">        DataFrame.rolling : Calling object with a DataFrame.</span>
<span class="sd">        Series.min : Similar method for Series.</span>
<span class="sd">        DataFrame.min : Similar method for DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = ps.Series([4, 3, 5, 2, 6])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    4</span>
<span class="sd">        1    3</span>
<span class="sd">        2    5</span>
<span class="sd">        3    2</span>
<span class="sd">        4    6</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; s.rolling(2).min()</span>
<span class="sd">        0    NaN</span>
<span class="sd">        1    3.0</span>
<span class="sd">        2    3.0</span>
<span class="sd">        3    2.0</span>
<span class="sd">        4    2.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; s.rolling(3).min()</span>
<span class="sd">        0    NaN</span>
<span class="sd">        1    NaN</span>
<span class="sd">        2    3.0</span>
<span class="sd">        3    2.0</span>
<span class="sd">        4    2.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        For DataFrame, each rolling minimum is computed column-wise.</span>

<span class="sd">        &gt;&gt;&gt; df = ps.DataFrame({&quot;A&quot;: s.to_numpy(), &quot;B&quot;: s.to_numpy() ** 2})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A   B</span>
<span class="sd">        0  4  16</span>
<span class="sd">        1  3   9</span>
<span class="sd">        2  5  25</span>
<span class="sd">        3  2   4</span>
<span class="sd">        4  6  36</span>

<span class="sd">        &gt;&gt;&gt; df.rolling(2).min()</span>
<span class="sd">             A    B</span>
<span class="sd">        0  NaN  NaN</span>
<span class="sd">        1  3.0  9.0</span>
<span class="sd">        2  3.0  9.0</span>
<span class="sd">        3  2.0  4.0</span>
<span class="sd">        4  2.0  4.0</span>

<span class="sd">        &gt;&gt;&gt; df.rolling(3).min()</span>
<span class="sd">             A    B</span>
<span class="sd">        0  NaN  NaN</span>
<span class="sd">        1  NaN  NaN</span>
<span class="sd">        2  3.0  9.0</span>
<span class="sd">        3  2.0  4.0</span>
<span class="sd">        4  2.0  4.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">min</span><span class="p">()</span></div>

<div class="viewcode-block" id="Rolling.max"><a class="viewcode-back" href="../../../reference/pyspark.pandas/api/pyspark.pandas.window.Rolling.max.html#pyspark.pandas.window.Rolling.max">[docs]</a>    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the rolling maximum.</span>

<span class="sd">        .. note:: the current implementation of this API uses Spark&#39;s Window without</span>
<span class="sd">            specifying partition specification. This leads to move all data into</span>
<span class="sd">            single partition in single machine and could cause serious</span>
<span class="sd">            performance degradation. Avoid this method against very large dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Return type is determined by the caller.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.rolling : Series rolling.</span>
<span class="sd">        DataFrame.rolling : DataFrame rolling.</span>
<span class="sd">        Series.max : Similar method for Series.</span>
<span class="sd">        DataFrame.max : Similar method for DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = ps.Series([4, 3, 5, 2, 6])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    4</span>
<span class="sd">        1    3</span>
<span class="sd">        2    5</span>
<span class="sd">        3    2</span>
<span class="sd">        4    6</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; s.rolling(2).max()</span>
<span class="sd">        0    NaN</span>
<span class="sd">        1    4.0</span>
<span class="sd">        2    5.0</span>
<span class="sd">        3    5.0</span>
<span class="sd">        4    6.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; s.rolling(3).max()</span>
<span class="sd">        0    NaN</span>
<span class="sd">        1    NaN</span>
<span class="sd">        2    5.0</span>
<span class="sd">        3    5.0</span>
<span class="sd">        4    6.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        For DataFrame, each rolling maximum is computed column-wise.</span>

<span class="sd">        &gt;&gt;&gt; df = ps.DataFrame({&quot;A&quot;: s.to_numpy(), &quot;B&quot;: s.to_numpy() ** 2})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A   B</span>
<span class="sd">        0  4  16</span>
<span class="sd">        1  3   9</span>
<span class="sd">        2  5  25</span>
<span class="sd">        3  2   4</span>
<span class="sd">        4  6  36</span>

<span class="sd">        &gt;&gt;&gt; df.rolling(2).max()</span>
<span class="sd">             A     B</span>
<span class="sd">        0  NaN   NaN</span>
<span class="sd">        1  4.0  16.0</span>
<span class="sd">        2  5.0  25.0</span>
<span class="sd">        3  5.0  25.0</span>
<span class="sd">        4  6.0  36.0</span>

<span class="sd">        &gt;&gt;&gt; df.rolling(3).max()</span>
<span class="sd">             A     B</span>
<span class="sd">        0  NaN   NaN</span>
<span class="sd">        1  NaN   NaN</span>
<span class="sd">        2  5.0  25.0</span>
<span class="sd">        3  5.0  25.0</span>
<span class="sd">        4  6.0  36.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span></div>

<div class="viewcode-block" id="Rolling.mean"><a class="viewcode-back" href="../../../reference/pyspark.pandas/api/pyspark.pandas.window.Rolling.mean.html#pyspark.pandas.window.Rolling.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the rolling mean of the values.</span>

<span class="sd">        .. note:: the current implementation of this API uses Spark&#39;s Window without</span>
<span class="sd">            specifying partition specification. This leads to move all data into</span>
<span class="sd">            single partition in single machine and could cause serious</span>
<span class="sd">            performance degradation. Avoid this method against very large dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Returned object type is determined by the caller of the rolling</span>
<span class="sd">            calculation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.rolling : Calling object with Series data.</span>
<span class="sd">        DataFrame.rolling : Calling object with DataFrames.</span>
<span class="sd">        Series.mean : Equivalent method for Series.</span>
<span class="sd">        DataFrame.mean : Equivalent method for DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = ps.Series([4, 3, 5, 2, 6])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    4</span>
<span class="sd">        1    3</span>
<span class="sd">        2    5</span>
<span class="sd">        3    2</span>
<span class="sd">        4    6</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; s.rolling(2).mean()</span>
<span class="sd">        0    NaN</span>
<span class="sd">        1    3.5</span>
<span class="sd">        2    4.0</span>
<span class="sd">        3    3.5</span>
<span class="sd">        4    4.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; s.rolling(3).mean()</span>
<span class="sd">        0         NaN</span>
<span class="sd">        1         NaN</span>
<span class="sd">        2    4.000000</span>
<span class="sd">        3    3.333333</span>
<span class="sd">        4    4.333333</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        For DataFrame, each rolling mean is computed column-wise.</span>

<span class="sd">        &gt;&gt;&gt; df = ps.DataFrame({&quot;A&quot;: s.to_numpy(), &quot;B&quot;: s.to_numpy() ** 2})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A   B</span>
<span class="sd">        0  4  16</span>
<span class="sd">        1  3   9</span>
<span class="sd">        2  5  25</span>
<span class="sd">        3  2   4</span>
<span class="sd">        4  6  36</span>

<span class="sd">        &gt;&gt;&gt; df.rolling(2).mean()</span>
<span class="sd">             A     B</span>
<span class="sd">        0  NaN   NaN</span>
<span class="sd">        1  3.5  12.5</span>
<span class="sd">        2  4.0  17.0</span>
<span class="sd">        3  3.5  14.5</span>
<span class="sd">        4  4.0  20.0</span>

<span class="sd">        &gt;&gt;&gt; df.rolling(3).mean()</span>
<span class="sd">                  A          B</span>
<span class="sd">        0       NaN        NaN</span>
<span class="sd">        1       NaN        NaN</span>
<span class="sd">        2  4.000000  16.666667</span>
<span class="sd">        3  3.333333  12.666667</span>
<span class="sd">        4  4.333333  21.666667</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate rolling standard deviation.</span>

<span class="sd">        .. note:: the current implementation of this API uses Spark&#39;s Window without</span>
<span class="sd">            specifying partition specification. This leads to move all data into</span>
<span class="sd">            single partition in single machine and could cause serious</span>
<span class="sd">            performance degradation. Avoid this method against very large dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Returns the same object type as the caller of the rolling calculation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.rolling : Calling object with Series data.</span>
<span class="sd">        DataFrame.rolling : Calling object with DataFrames.</span>
<span class="sd">        Series.std : Equivalent method for Series.</span>
<span class="sd">        DataFrame.std : Equivalent method for DataFrame.</span>
<span class="sd">        numpy.std : Equivalent method for Numpy array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = ps.Series([5, 5, 6, 7, 5, 5, 5])</span>
<span class="sd">        &gt;&gt;&gt; s.rolling(3).std()</span>
<span class="sd">        0         NaN</span>
<span class="sd">        1         NaN</span>
<span class="sd">        2    0.577350</span>
<span class="sd">        3    1.000000</span>
<span class="sd">        4    1.000000</span>
<span class="sd">        5    1.154701</span>
<span class="sd">        6    0.000000</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        For DataFrame, each rolling standard deviation is computed column-wise.</span>

<span class="sd">        &gt;&gt;&gt; df = ps.DataFrame({&quot;A&quot;: s.to_numpy(), &quot;B&quot;: s.to_numpy() ** 2})</span>
<span class="sd">        &gt;&gt;&gt; df.rolling(2).std()</span>
<span class="sd">                  A          B</span>
<span class="sd">        0       NaN        NaN</span>
<span class="sd">        1  0.000000   0.000000</span>
<span class="sd">        2  0.707107   7.778175</span>
<span class="sd">        3  0.707107   9.192388</span>
<span class="sd">        4  1.414214  16.970563</span>
<span class="sd">        5  0.000000   0.000000</span>
<span class="sd">        6  0.000000   0.000000</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate unbiased rolling variance.</span>

<span class="sd">        .. note:: the current implementation of this API uses Spark&#39;s Window without</span>
<span class="sd">            specifying partition specification. This leads to move all data into</span>
<span class="sd">            single partition in single machine and could cause serious</span>
<span class="sd">            performance degradation. Avoid this method against very large dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Returns the same object type as the caller of the rolling calculation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.rolling : Calling object with Series data.</span>
<span class="sd">        DataFrame.rolling : Calling object with DataFrames.</span>
<span class="sd">        Series.var : Equivalent method for Series.</span>
<span class="sd">        DataFrame.var : Equivalent method for DataFrame.</span>
<span class="sd">        numpy.var : Equivalent method for Numpy array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = ps.Series([5, 5, 6, 7, 5, 5, 5])</span>
<span class="sd">        &gt;&gt;&gt; s.rolling(3).var()</span>
<span class="sd">        0         NaN</span>
<span class="sd">        1         NaN</span>
<span class="sd">        2    0.333333</span>
<span class="sd">        3    1.000000</span>
<span class="sd">        4    1.000000</span>
<span class="sd">        5    1.333333</span>
<span class="sd">        6    0.000000</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        For DataFrame, each unbiased rolling variance is computed column-wise.</span>

<span class="sd">        &gt;&gt;&gt; df = ps.DataFrame({&quot;A&quot;: s.to_numpy(), &quot;B&quot;: s.to_numpy() ** 2})</span>
<span class="sd">        &gt;&gt;&gt; df.rolling(2).var()</span>
<span class="sd">             A      B</span>
<span class="sd">        0  NaN    NaN</span>
<span class="sd">        1  0.0    0.0</span>
<span class="sd">        2  0.5   60.5</span>
<span class="sd">        3  0.5   84.5</span>
<span class="sd">        4  2.0  288.0</span>
<span class="sd">        5  0.0    0.0</span>
<span class="sd">        6  0.0    0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">var</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">RollingGroupby</span><span class="p">(</span><span class="n">RollingLike</span><span class="p">[</span><span class="n">FrameLike</span><span class="p">]):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">groupby</span><span class="p">:</span> <span class="n">GroupBy</span><span class="p">[</span><span class="n">FrameLike</span><span class="p">],</span>
        <span class="n">window</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">min_periods</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">min_periods</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_groupby</span> <span class="o">=</span> <span class="n">groupby</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_window</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window</span><span class="o">.</span><span class="n">partitionBy</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">ser</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span> <span class="k">for</span> <span class="n">ser</span> <span class="ow">in</span> <span class="n">groupby</span><span class="o">.</span><span class="n">_groupkeys</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unbounded_window</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unbounded_window</span><span class="o">.</span><span class="n">partitionBy</span><span class="p">(</span>
            <span class="o">*</span><span class="p">[</span><span class="n">ser</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span> <span class="k">for</span> <span class="n">ser</span> <span class="ow">in</span> <span class="n">groupby</span><span class="o">.</span><span class="n">_groupkeys</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">MissingPandasLikeRollingGroupby</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
            <span class="n">property_or_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">MissingPandasLikeRollingGroupby</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">property_or_func</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">property_or_func</span><span class="o">.</span><span class="n">fget</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">property_or_func</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_apply_as_series_or_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Column</span><span class="p">],</span> <span class="n">Column</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wraps a function that handles Spark column in order</span>
<span class="sd">        to support it in both pandas-on-Spark Series and DataFrame.</span>
<span class="sd">        Note that the given `func` name should be same as the API&#39;s method name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pyspark.pandas</span> <span class="kn">import</span> <span class="n">DataFrame</span>

        <span class="n">groupby</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_groupby</span>
        <span class="n">psdf</span> <span class="o">=</span> <span class="n">groupby</span><span class="o">.</span><span class="n">_psdf</span>

        <span class="c1"># Here we need to include grouped key as an index, and shift previous index.</span>
        <span class="c1">#   [index_column0, index_column1] -&gt; [grouped key, index_column0, index_column1]</span>
        <span class="n">new_index_scols</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Column</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_index_spark_column_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_index_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new_index_fields</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">groupkey</span> <span class="ow">in</span> <span class="n">groupby</span><span class="o">.</span><span class="n">_groupkeys</span><span class="p">:</span>
            <span class="n">index_column_name</span> <span class="o">=</span> <span class="n">SPARK_INDEX_NAME_FORMAT</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_index_scols</span><span class="p">))</span>
            <span class="n">new_index_scols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">groupkey</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">index_column_name</span><span class="p">))</span>
            <span class="n">new_index_spark_column_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_column_name</span><span class="p">)</span>
            <span class="n">new_index_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">groupkey</span><span class="o">.</span><span class="n">_column_label</span><span class="p">)</span>
            <span class="n">new_index_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">groupkey</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">data_fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">index_column_name</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">new_index_scol</span><span class="p">,</span> <span class="n">index_name</span><span class="p">,</span> <span class="n">index_field</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">psdf</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_columns</span><span class="p">,</span>
            <span class="n">psdf</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_names</span><span class="p">,</span>
            <span class="n">psdf</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_fields</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="n">index_column_name</span> <span class="o">=</span> <span class="n">SPARK_INDEX_NAME_FORMAT</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_index_scols</span><span class="p">))</span>
            <span class="n">new_index_scols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_index_scol</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">index_column_name</span><span class="p">))</span>
            <span class="n">new_index_spark_column_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_column_name</span><span class="p">)</span>
            <span class="n">new_index_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_name</span><span class="p">)</span>
            <span class="n">new_index_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_field</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">index_column_name</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">groupby</span><span class="o">.</span><span class="n">_agg_columns_selected</span><span class="p">:</span>
            <span class="n">agg_columns</span> <span class="o">=</span> <span class="n">groupby</span><span class="o">.</span><span class="n">_agg_columns</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># pandas doesn&#39;t keep the groupkey as a column from 1.3 for DataFrameGroupBy</span>
            <span class="n">column_labels_to_exclude</span> <span class="o">=</span> <span class="n">groupby</span><span class="o">.</span><span class="n">_column_labels_to_exclude</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">groupby</span><span class="p">,</span> <span class="n">DataFrameGroupBy</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">groupkey</span> <span class="ow">in</span> <span class="n">groupby</span><span class="o">.</span><span class="n">_groupkeys</span><span class="p">:</span>  <span class="c1"># type: ignore[attr-defined]</span>
                    <span class="n">column_labels_to_exclude</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">groupkey</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">column_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">agg_columns</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">psdf</span><span class="o">.</span><span class="n">_psser_for</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">psdf</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">column_labels</span>
                <span class="k">if</span> <span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">column_labels_to_exclude</span>
            <span class="p">]</span>

        <span class="n">applied</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">agg_column</span> <span class="ow">in</span> <span class="n">agg_columns</span><span class="p">:</span>
            <span class="n">applied</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">agg_column</span><span class="o">.</span><span class="n">_with_new_scol</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">agg_column</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span><span class="p">)))</span>  <span class="c1"># TODO: dtype?</span>

        <span class="c1"># Seems like pandas filters out when grouped key is NA.</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">groupby</span><span class="o">.</span><span class="n">_groupkeys</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span><span class="o">.</span><span class="n">isNotNull</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">groupby</span><span class="o">.</span><span class="n">_groupkeys</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="n">cond</span> <span class="o">|</span> <span class="n">c</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span><span class="o">.</span><span class="n">isNotNull</span><span class="p">()</span>

        <span class="n">sdf</span> <span class="o">=</span> <span class="n">psdf</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_frame</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
            <span class="n">new_index_scols</span> <span class="o">+</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">applied</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">internal</span> <span class="o">=</span> <span class="n">psdf</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
            <span class="n">spark_frame</span><span class="o">=</span><span class="n">sdf</span><span class="p">,</span>
            <span class="n">index_spark_columns</span><span class="o">=</span><span class="p">[</span><span class="n">scol_for</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">new_index_spark_column_names</span><span class="p">],</span>
            <span class="n">index_names</span><span class="o">=</span><span class="n">new_index_names</span><span class="p">,</span>
            <span class="n">index_fields</span><span class="o">=</span><span class="n">new_index_fields</span><span class="p">,</span>
            <span class="n">column_labels</span><span class="o">=</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_column_label</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">applied</span><span class="p">],</span>
            <span class="n">data_spark_columns</span><span class="o">=</span><span class="p">[</span>
                <span class="n">scol_for</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">data_spark_column_names</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">applied</span>
            <span class="p">],</span>
            <span class="n">data_fields</span><span class="o">=</span><span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">data_fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">applied</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">groupby</span><span class="o">.</span><span class="n">_cleanup_and_return</span><span class="p">(</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">internal</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The rolling count of any non-NaN observations inside the window.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Returned object type is determined by the caller of the expanding</span>
<span class="sd">            calculation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.rolling : Calling object with Series data.</span>
<span class="sd">        DataFrame.rolling : Calling object with DataFrames.</span>
<span class="sd">        Series.count : Count of the full Series.</span>
<span class="sd">        DataFrame.count : Count of the full DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = ps.Series([2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5])</span>
<span class="sd">        &gt;&gt;&gt; s.groupby(s).rolling(3).count().sort_index()</span>
<span class="sd">        2  0     1.0</span>
<span class="sd">           1     2.0</span>
<span class="sd">        3  2     1.0</span>
<span class="sd">           3     2.0</span>
<span class="sd">           4     3.0</span>
<span class="sd">        4  5     1.0</span>
<span class="sd">           6     2.0</span>
<span class="sd">           7     3.0</span>
<span class="sd">           8     3.0</span>
<span class="sd">        5  9     1.0</span>
<span class="sd">           10    2.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        For DataFrame, each rolling count is computed column-wise.</span>

<span class="sd">        &gt;&gt;&gt; df = ps.DataFrame({&quot;A&quot;: s.to_numpy(), &quot;B&quot;: s.to_numpy() ** 2})</span>
<span class="sd">        &gt;&gt;&gt; df.groupby(df.A).rolling(2).count().sort_index()  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">                B</span>
<span class="sd">        A</span>
<span class="sd">        2 0   1.0</span>
<span class="sd">          1   2.0</span>
<span class="sd">        3 2   1.0</span>
<span class="sd">          3   2.0</span>
<span class="sd">          4   2.0</span>
<span class="sd">        4 5   1.0</span>
<span class="sd">          6   2.0</span>
<span class="sd">          7   2.0</span>
<span class="sd">          8   2.0</span>
<span class="sd">        5 9   1.0</span>
<span class="sd">          10  2.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The rolling summation of any non-NaN observations inside the window.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Returned object type is determined by the caller of the rolling</span>
<span class="sd">            calculation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.rolling : Calling object with Series data.</span>
<span class="sd">        DataFrame.rolling : Calling object with DataFrames.</span>
<span class="sd">        Series.sum : Sum of the full Series.</span>
<span class="sd">        DataFrame.sum : Sum of the full DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = ps.Series([2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5])</span>
<span class="sd">        &gt;&gt;&gt; s.groupby(s).rolling(3).sum().sort_index()</span>
<span class="sd">        2  0      NaN</span>
<span class="sd">           1      NaN</span>
<span class="sd">        3  2      NaN</span>
<span class="sd">           3      NaN</span>
<span class="sd">           4      9.0</span>
<span class="sd">        4  5      NaN</span>
<span class="sd">           6      NaN</span>
<span class="sd">           7     12.0</span>
<span class="sd">           8     12.0</span>
<span class="sd">        5  9      NaN</span>
<span class="sd">           10     NaN</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        For DataFrame, each rolling summation is computed column-wise.</span>

<span class="sd">        &gt;&gt;&gt; df = ps.DataFrame({&quot;A&quot;: s.to_numpy(), &quot;B&quot;: s.to_numpy() ** 2})</span>
<span class="sd">        &gt;&gt;&gt; df.groupby(df.A).rolling(2).sum().sort_index()  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">                 B</span>
<span class="sd">        A</span>
<span class="sd">        2 0    NaN</span>
<span class="sd">          1    8.0</span>
<span class="sd">        3 2    NaN</span>
<span class="sd">          3   18.0</span>
<span class="sd">          4   18.0</span>
<span class="sd">        4 5    NaN</span>
<span class="sd">          6   32.0</span>
<span class="sd">          7   32.0</span>
<span class="sd">          8   32.0</span>
<span class="sd">        5 9    NaN</span>
<span class="sd">          10  50.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The rolling minimum of any non-NaN observations inside the window.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Returned object type is determined by the caller of the rolling</span>
<span class="sd">            calculation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.rolling : Calling object with Series data.</span>
<span class="sd">        DataFrame.rolling : Calling object with DataFrames.</span>
<span class="sd">        Series.min : Min of the full Series.</span>
<span class="sd">        DataFrame.min : Min of the full DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = ps.Series([2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5])</span>
<span class="sd">        &gt;&gt;&gt; s.groupby(s).rolling(3).min().sort_index()</span>
<span class="sd">        2  0     NaN</span>
<span class="sd">           1     NaN</span>
<span class="sd">        3  2     NaN</span>
<span class="sd">           3     NaN</span>
<span class="sd">           4     3.0</span>
<span class="sd">        4  5     NaN</span>
<span class="sd">           6     NaN</span>
<span class="sd">           7     4.0</span>
<span class="sd">           8     4.0</span>
<span class="sd">        5  9     NaN</span>
<span class="sd">           10    NaN</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        For DataFrame, each rolling minimum is computed column-wise.</span>

<span class="sd">        &gt;&gt;&gt; df = ps.DataFrame({&quot;A&quot;: s.to_numpy(), &quot;B&quot;: s.to_numpy() ** 2})</span>
<span class="sd">        &gt;&gt;&gt; df.groupby(df.A).rolling(2).min().sort_index()  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">                 B</span>
<span class="sd">        A</span>
<span class="sd">        2 0    NaN</span>
<span class="sd">          1    4.0</span>
<span class="sd">        3 2    NaN</span>
<span class="sd">          3    9.0</span>
<span class="sd">          4    9.0</span>
<span class="sd">        4 5    NaN</span>
<span class="sd">          6   16.0</span>
<span class="sd">          7   16.0</span>
<span class="sd">          8   16.0</span>
<span class="sd">        5 9    NaN</span>
<span class="sd">          10  25.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The rolling maximum of any non-NaN observations inside the window.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Returned object type is determined by the caller of the rolling</span>
<span class="sd">            calculation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.rolling : Calling object with Series data.</span>
<span class="sd">        DataFrame.rolling : Calling object with DataFrames.</span>
<span class="sd">        Series.max : Max of the full Series.</span>
<span class="sd">        DataFrame.max : Max of the full DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = ps.Series([2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5])</span>
<span class="sd">        &gt;&gt;&gt; s.groupby(s).rolling(3).max().sort_index()</span>
<span class="sd">        2  0     NaN</span>
<span class="sd">           1     NaN</span>
<span class="sd">        3  2     NaN</span>
<span class="sd">           3     NaN</span>
<span class="sd">           4     3.0</span>
<span class="sd">        4  5     NaN</span>
<span class="sd">           6     NaN</span>
<span class="sd">           7     4.0</span>
<span class="sd">           8     4.0</span>
<span class="sd">        5  9     NaN</span>
<span class="sd">           10    NaN</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        For DataFrame, each rolling maximum is computed column-wise.</span>

<span class="sd">        &gt;&gt;&gt; df = ps.DataFrame({&quot;A&quot;: s.to_numpy(), &quot;B&quot;: s.to_numpy() ** 2})</span>
<span class="sd">        &gt;&gt;&gt; df.groupby(df.A).rolling(2).max().sort_index()  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">                 B</span>
<span class="sd">        A</span>
<span class="sd">        2 0    NaN</span>
<span class="sd">          1    4.0</span>
<span class="sd">        3 2    NaN</span>
<span class="sd">          3    9.0</span>
<span class="sd">          4    9.0</span>
<span class="sd">        4 5    NaN</span>
<span class="sd">          6   16.0</span>
<span class="sd">          7   16.0</span>
<span class="sd">          8   16.0</span>
<span class="sd">        5 9    NaN</span>
<span class="sd">          10  25.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The rolling mean of any non-NaN observations inside the window.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Returned object type is determined by the caller of the rolling</span>
<span class="sd">            calculation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.rolling : Calling object with Series data.</span>
<span class="sd">        DataFrame.rolling : Calling object with DataFrames.</span>
<span class="sd">        Series.mean : Mean of the full Series.</span>
<span class="sd">        DataFrame.mean : Mean of the full DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = ps.Series([2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5])</span>
<span class="sd">        &gt;&gt;&gt; s.groupby(s).rolling(3).mean().sort_index()</span>
<span class="sd">        2  0     NaN</span>
<span class="sd">           1     NaN</span>
<span class="sd">        3  2     NaN</span>
<span class="sd">           3     NaN</span>
<span class="sd">           4     3.0</span>
<span class="sd">        4  5     NaN</span>
<span class="sd">           6     NaN</span>
<span class="sd">           7     4.0</span>
<span class="sd">           8     4.0</span>
<span class="sd">        5  9     NaN</span>
<span class="sd">           10    NaN</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        For DataFrame, each rolling mean is computed column-wise.</span>

<span class="sd">        &gt;&gt;&gt; df = ps.DataFrame({&quot;A&quot;: s.to_numpy(), &quot;B&quot;: s.to_numpy() ** 2})</span>
<span class="sd">        &gt;&gt;&gt; df.groupby(df.A).rolling(2).mean().sort_index()  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">                 B</span>
<span class="sd">        A</span>
<span class="sd">        2 0    NaN</span>
<span class="sd">          1    4.0</span>
<span class="sd">        3 2    NaN</span>
<span class="sd">          3    9.0</span>
<span class="sd">          4    9.0</span>
<span class="sd">        4 5    NaN</span>
<span class="sd">          6   16.0</span>
<span class="sd">          7   16.0</span>
<span class="sd">          8   16.0</span>
<span class="sd">        5 9    NaN</span>
<span class="sd">          10  25.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate rolling standard deviation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Returns the same object type as the caller of the rolling calculation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.rolling : Calling object with Series data.</span>
<span class="sd">        DataFrame.rolling : Calling object with DataFrames.</span>
<span class="sd">        Series.std : Equivalent method for Series.</span>
<span class="sd">        DataFrame.std : Equivalent method for DataFrame.</span>
<span class="sd">        numpy.std : Equivalent method for Numpy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate unbiased rolling variance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Returns the same object type as the caller of the rolling calculation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.rolling : Calling object with Series data.</span>
<span class="sd">        DataFrame.rolling : Calling object with DataFrames.</span>
<span class="sd">        Series.var : Equivalent method for Series.</span>
<span class="sd">        DataFrame.var : Equivalent method for DataFrame.</span>
<span class="sd">        numpy.var : Equivalent method for Numpy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">var</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">ExpandingLike</span><span class="p">(</span><span class="n">RollingAndExpanding</span><span class="p">[</span><span class="n">FrameLike</span><span class="p">]):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_periods</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">min_periods</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;min_periods must be &gt;= 0&quot;</span><span class="p">)</span>

        <span class="n">window</span> <span class="o">=</span> <span class="n">Window</span><span class="o">.</span><span class="n">orderBy</span><span class="p">(</span><span class="n">NATURAL_ORDER_COLUMN_NAME</span><span class="p">)</span><span class="o">.</span><span class="n">rowsBetween</span><span class="p">(</span>
            <span class="n">Window</span><span class="o">.</span><span class="n">unboundedPreceding</span><span class="p">,</span> <span class="n">Window</span><span class="o">.</span><span class="n">currentRow</span>
        <span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">min_periods</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="n">scol</span><span class="p">:</span> <span class="n">Column</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Column</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">when</span><span class="p">(</span>
                <span class="n">F</span><span class="o">.</span><span class="n">row_number</span><span class="p">()</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_unbounded_window</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_min_periods</span><span class="p">,</span>
                <span class="n">F</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">scol</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_window</span><span class="p">),</span>
            <span class="p">)</span><span class="o">.</span><span class="n">otherwise</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_apply_as_series_or_frame</span><span class="p">(</span><span class="n">count</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">)</span>  <span class="c1"># type: ignore[attr-defined]</span>


<span class="k">class</span> <span class="nc">Expanding</span><span class="p">(</span><span class="n">ExpandingLike</span><span class="p">[</span><span class="n">FrameLike</span><span class="p">]):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">psdf_or_psser</span><span class="p">:</span> <span class="n">FrameLike</span><span class="p">,</span> <span class="n">min_periods</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pyspark.pandas.frame</span> <span class="kn">import</span> <span class="n">DataFrame</span>
        <span class="kn">from</span> <span class="nn">pyspark.pandas.series</span> <span class="kn">import</span> <span class="n">Series</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">min_periods</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">psdf_or_psser</span><span class="p">,</span> <span class="p">(</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">Series</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;psdf_or_psser must be a series or dataframe; however, got: </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">psdf_or_psser</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_psdf_or_psser</span> <span class="o">=</span> <span class="n">psdf_or_psser</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">MissingPandasLikeExpanding</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
            <span class="n">property_or_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">MissingPandasLikeExpanding</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">property_or_func</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">property_or_func</span><span class="o">.</span><span class="n">fget</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">property_or_func</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="c1"># TODO: when add &#39;center&#39; and &#39;axis&#39; parameter, should add to here too.</span>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;Expanding [min_periods=</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_min_periods</span><span class="p">)</span>

    <span class="n">_apply_as_series_or_frame</span> <span class="o">=</span> <span class="n">Rolling</span><span class="o">.</span><span class="n">_apply_as_series_or_frame</span>

<div class="viewcode-block" id="Expanding.count"><a class="viewcode-back" href="../../../reference/pyspark.pandas/api/pyspark.pandas.window.Expanding.count.html#pyspark.pandas.window.Expanding.count">[docs]</a>    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The expanding count of any non-NaN observations inside the window.</span>

<span class="sd">        .. note:: the current implementation of this API uses Spark&#39;s Window without</span>
<span class="sd">            specifying partition specification. This leads to move all data into</span>
<span class="sd">            single partition in single machine and could cause serious</span>
<span class="sd">            performance degradation. Avoid this method against very large dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Returned object type is determined by the caller of the expanding</span>
<span class="sd">            calculation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.expanding : Calling object with Series data.</span>
<span class="sd">        DataFrame.expanding : Calling object with DataFrames.</span>
<span class="sd">        Series.count : Count of the full Series.</span>
<span class="sd">        DataFrame.count : Count of the full DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = ps.Series([2, 3, float(&quot;nan&quot;), 10])</span>
<span class="sd">        &gt;&gt;&gt; s.expanding().count()</span>
<span class="sd">        0    1.0</span>
<span class="sd">        1    2.0</span>
<span class="sd">        2    2.0</span>
<span class="sd">        3    3.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; s.to_frame().expanding().count()</span>
<span class="sd">             0</span>
<span class="sd">        0  1.0</span>
<span class="sd">        1  2.0</span>
<span class="sd">        2  2.0</span>
<span class="sd">        3  3.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">count</span><span class="p">()</span></div>

<div class="viewcode-block" id="Expanding.sum"><a class="viewcode-back" href="../../../reference/pyspark.pandas/api/pyspark.pandas.window.Expanding.sum.html#pyspark.pandas.window.Expanding.sum">[docs]</a>    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate expanding summation of given DataFrame or Series.</span>

<span class="sd">        .. note:: the current implementation of this API uses Spark&#39;s Window without</span>
<span class="sd">            specifying partition specification. This leads to move all data into</span>
<span class="sd">            single partition in single machine and could cause serious</span>
<span class="sd">            performance degradation. Avoid this method against very large dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Same type as the input, with the same index, containing the</span>
<span class="sd">            expanding summation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.expanding : Calling object with Series data.</span>
<span class="sd">        DataFrame.expanding : Calling object with DataFrames.</span>
<span class="sd">        Series.sum : Reducing sum for Series.</span>
<span class="sd">        DataFrame.sum : Reducing sum for DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = ps.Series([1, 2, 3, 4, 5])</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        0    1</span>
<span class="sd">        1    2</span>
<span class="sd">        2    3</span>
<span class="sd">        3    4</span>
<span class="sd">        4    5</span>
<span class="sd">        dtype: int64</span>

<span class="sd">        &gt;&gt;&gt; s.expanding(3).sum()</span>
<span class="sd">        0     NaN</span>
<span class="sd">        1     NaN</span>
<span class="sd">        2     6.0</span>
<span class="sd">        3    10.0</span>
<span class="sd">        4    15.0</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        For DataFrame, each expanding summation is computed column-wise.</span>

<span class="sd">        &gt;&gt;&gt; df = ps.DataFrame({&quot;A&quot;: s.to_numpy(), &quot;B&quot;: s.to_numpy() ** 2})</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">           A   B</span>
<span class="sd">        0  1   1</span>
<span class="sd">        1  2   4</span>
<span class="sd">        2  3   9</span>
<span class="sd">        3  4  16</span>
<span class="sd">        4  5  25</span>

<span class="sd">        &gt;&gt;&gt; df.expanding(3).sum()</span>
<span class="sd">              A     B</span>
<span class="sd">        0   NaN   NaN</span>
<span class="sd">        1   NaN   NaN</span>
<span class="sd">        2   6.0  14.0</span>
<span class="sd">        3  10.0  30.0</span>
<span class="sd">        4  15.0  55.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span></div>

<div class="viewcode-block" id="Expanding.min"><a class="viewcode-back" href="../../../reference/pyspark.pandas/api/pyspark.pandas.window.Expanding.min.html#pyspark.pandas.window.Expanding.min">[docs]</a>    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the expanding minimum.</span>

<span class="sd">        .. note:: the current implementation of this API uses Spark&#39;s Window without</span>
<span class="sd">            specifying partition specification. This leads to move all data into</span>
<span class="sd">            single partition in single machine and could cause serious</span>
<span class="sd">            performance degradation. Avoid this method against very large dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Returned object type is determined by the caller of the expanding</span>
<span class="sd">            calculation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.expanding : Calling object with a Series.</span>
<span class="sd">        DataFrame.expanding : Calling object with a DataFrame.</span>
<span class="sd">        Series.min : Similar method for Series.</span>
<span class="sd">        DataFrame.min : Similar method for DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Performing a expanding minimum with a window size of 3.</span>

<span class="sd">        &gt;&gt;&gt; s = ps.Series([4, 3, 5, 2, 6])</span>
<span class="sd">        &gt;&gt;&gt; s.expanding(3).min()</span>
<span class="sd">        0    NaN</span>
<span class="sd">        1    NaN</span>
<span class="sd">        2    3.0</span>
<span class="sd">        3    2.0</span>
<span class="sd">        4    2.0</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">min</span><span class="p">()</span></div>

<div class="viewcode-block" id="Expanding.max"><a class="viewcode-back" href="../../../reference/pyspark.pandas/api/pyspark.pandas.window.Expanding.max.html#pyspark.pandas.window.Expanding.max">[docs]</a>    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the expanding maximum.</span>

<span class="sd">        .. note:: the current implementation of this API uses Spark&#39;s Window without</span>
<span class="sd">            specifying partition specification. This leads to move all data into</span>
<span class="sd">            single partition in single machine and could cause serious</span>
<span class="sd">            performance degradation. Avoid this method against very large dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Return type is determined by the caller.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.expanding : Calling object with Series data.</span>
<span class="sd">        DataFrame.expanding : Calling object with DataFrames.</span>
<span class="sd">        Series.max : Similar method for Series.</span>
<span class="sd">        DataFrame.max : Similar method for DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Performing a expanding minimum with a window size of 3.</span>

<span class="sd">        &gt;&gt;&gt; s = ps.Series([4, 3, 5, 2, 6])</span>
<span class="sd">        &gt;&gt;&gt; s.expanding(3).max()</span>
<span class="sd">        0    NaN</span>
<span class="sd">        1    NaN</span>
<span class="sd">        2    5.0</span>
<span class="sd">        3    5.0</span>
<span class="sd">        4    6.0</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span></div>

<div class="viewcode-block" id="Expanding.mean"><a class="viewcode-back" href="../../../reference/pyspark.pandas/api/pyspark.pandas.window.Expanding.mean.html#pyspark.pandas.window.Expanding.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the expanding mean of the values.</span>

<span class="sd">        .. note:: the current implementation of this API uses Spark&#39;s Window without</span>
<span class="sd">            specifying partition specification. This leads to move all data into</span>
<span class="sd">            single partition in single machine and could cause serious</span>
<span class="sd">            performance degradation. Avoid this method against very large dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Returned object type is determined by the caller of the expanding</span>
<span class="sd">            calculation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.expanding : Calling object with Series data.</span>
<span class="sd">        DataFrame.expanding : Calling object with DataFrames.</span>
<span class="sd">        Series.mean : Equivalent method for Series.</span>
<span class="sd">        DataFrame.mean : Equivalent method for DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        The below examples will show expanding mean calculations with window sizes of</span>
<span class="sd">        two and three, respectively.</span>

<span class="sd">        &gt;&gt;&gt; s = ps.Series([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; s.expanding(2).mean()</span>
<span class="sd">        0    NaN</span>
<span class="sd">        1    1.5</span>
<span class="sd">        2    2.0</span>
<span class="sd">        3    2.5</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; s.expanding(3).mean()</span>
<span class="sd">        0    NaN</span>
<span class="sd">        1    NaN</span>
<span class="sd">        2    2.0</span>
<span class="sd">        3    2.5</span>
<span class="sd">        dtype: float64</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate expanding standard deviation.</span>

<span class="sd">        .. note:: the current implementation of this API uses Spark&#39;s Window without</span>
<span class="sd">            specifying partition specification. This leads to move all data into</span>
<span class="sd">            single partition in single machine and could cause serious</span>
<span class="sd">            performance degradation. Avoid this method against very large dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Returns the same object type as the caller of the expanding calculation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.expanding : Calling object with Series data.</span>
<span class="sd">        DataFrame.expanding : Calling object with DataFrames.</span>
<span class="sd">        Series.std : Equivalent method for Series.</span>
<span class="sd">        DataFrame.std : Equivalent method for DataFrame.</span>
<span class="sd">        numpy.std : Equivalent method for Numpy array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = ps.Series([5, 5, 6, 7, 5, 5, 5])</span>
<span class="sd">        &gt;&gt;&gt; s.expanding(3).std()</span>
<span class="sd">        0         NaN</span>
<span class="sd">        1         NaN</span>
<span class="sd">        2    0.577350</span>
<span class="sd">        3    0.957427</span>
<span class="sd">        4    0.894427</span>
<span class="sd">        5    0.836660</span>
<span class="sd">        6    0.786796</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        For DataFrame, each expanding standard deviation variance is computed column-wise.</span>

<span class="sd">        &gt;&gt;&gt; df = ps.DataFrame({&quot;A&quot;: s.to_numpy(), &quot;B&quot;: s.to_numpy() ** 2})</span>
<span class="sd">        &gt;&gt;&gt; df.expanding(2).std()</span>
<span class="sd">                  A          B</span>
<span class="sd">        0       NaN        NaN</span>
<span class="sd">        1  0.000000   0.000000</span>
<span class="sd">        2  0.577350   6.350853</span>
<span class="sd">        3  0.957427  11.412712</span>
<span class="sd">        4  0.894427  10.630146</span>
<span class="sd">        5  0.836660   9.928075</span>
<span class="sd">        6  0.786796   9.327379</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate unbiased expanding variance.</span>

<span class="sd">        .. note:: the current implementation of this API uses Spark&#39;s Window without</span>
<span class="sd">            specifying partition specification. This leads to move all data into</span>
<span class="sd">            single partition in single machine and could cause serious</span>
<span class="sd">            performance degradation. Avoid this method against very large dataset.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Returns the same object type as the caller of the expanding calculation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.expanding : Calling object with Series data.</span>
<span class="sd">        DataFrame.expanding : Calling object with DataFrames.</span>
<span class="sd">        Series.var : Equivalent method for Series.</span>
<span class="sd">        DataFrame.var : Equivalent method for DataFrame.</span>
<span class="sd">        numpy.var : Equivalent method for Numpy array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = ps.Series([5, 5, 6, 7, 5, 5, 5])</span>
<span class="sd">        &gt;&gt;&gt; s.expanding(3).var()</span>
<span class="sd">        0         NaN</span>
<span class="sd">        1         NaN</span>
<span class="sd">        2    0.333333</span>
<span class="sd">        3    0.916667</span>
<span class="sd">        4    0.800000</span>
<span class="sd">        5    0.700000</span>
<span class="sd">        6    0.619048</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        For DataFrame, each unbiased expanding variance is computed column-wise.</span>

<span class="sd">        &gt;&gt;&gt; df = ps.DataFrame({&quot;A&quot;: s.to_numpy(), &quot;B&quot;: s.to_numpy() ** 2})</span>
<span class="sd">        &gt;&gt;&gt; df.expanding(2).var()</span>
<span class="sd">                  A           B</span>
<span class="sd">        0       NaN         NaN</span>
<span class="sd">        1  0.000000    0.000000</span>
<span class="sd">        2  0.333333   40.333333</span>
<span class="sd">        3  0.916667  130.250000</span>
<span class="sd">        4  0.800000  113.000000</span>
<span class="sd">        5  0.700000   98.566667</span>
<span class="sd">        6  0.619048   87.000000</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">var</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">ExpandingGroupby</span><span class="p">(</span><span class="n">ExpandingLike</span><span class="p">[</span><span class="n">FrameLike</span><span class="p">]):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groupby</span><span class="p">:</span> <span class="n">GroupBy</span><span class="p">[</span><span class="n">FrameLike</span><span class="p">],</span> <span class="n">min_periods</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">min_periods</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_groupby</span> <span class="o">=</span> <span class="n">groupby</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_window</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window</span><span class="o">.</span><span class="n">partitionBy</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">ser</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span> <span class="k">for</span> <span class="n">ser</span> <span class="ow">in</span> <span class="n">groupby</span><span class="o">.</span><span class="n">_groupkeys</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_unbounded_window</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_window</span><span class="o">.</span><span class="n">partitionBy</span><span class="p">(</span>
            <span class="o">*</span><span class="p">[</span><span class="n">ser</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span> <span class="k">for</span> <span class="n">ser</span> <span class="ow">in</span> <span class="n">groupby</span><span class="o">.</span><span class="n">_groupkeys</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">MissingPandasLikeExpandingGroupby</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
            <span class="n">property_or_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">MissingPandasLikeExpandingGroupby</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">property_or_func</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">property_or_func</span><span class="o">.</span><span class="n">fget</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">property_or_func</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="n">_apply_as_series_or_frame</span> <span class="o">=</span> <span class="n">RollingGroupby</span><span class="o">.</span><span class="n">_apply_as_series_or_frame</span>

    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The expanding count of any non-NaN observations inside the window.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Returned object type is determined by the caller of the expanding</span>
<span class="sd">            calculation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.expanding : Calling object with Series data.</span>
<span class="sd">        DataFrame.expanding : Calling object with DataFrames.</span>
<span class="sd">        Series.count : Count of the full Series.</span>
<span class="sd">        DataFrame.count : Count of the full DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = ps.Series([2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5])</span>
<span class="sd">        &gt;&gt;&gt; s.groupby(s).expanding(3).count().sort_index()</span>
<span class="sd">        2  0     NaN</span>
<span class="sd">           1     NaN</span>
<span class="sd">        3  2     NaN</span>
<span class="sd">           3     NaN</span>
<span class="sd">           4     3.0</span>
<span class="sd">        4  5     NaN</span>
<span class="sd">           6     NaN</span>
<span class="sd">           7     3.0</span>
<span class="sd">           8     4.0</span>
<span class="sd">        5  9     NaN</span>
<span class="sd">           10    NaN</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        For DataFrame, each expanding count is computed column-wise.</span>

<span class="sd">        &gt;&gt;&gt; df = ps.DataFrame({&quot;A&quot;: s.to_numpy(), &quot;B&quot;: s.to_numpy() ** 2})</span>
<span class="sd">        &gt;&gt;&gt; df.groupby(df.A).expanding(2).count().sort_index()  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">                B</span>
<span class="sd">        A</span>
<span class="sd">        2 0   NaN</span>
<span class="sd">          1   2.0</span>
<span class="sd">        3 2   NaN</span>
<span class="sd">          3   2.0</span>
<span class="sd">          4   3.0</span>
<span class="sd">        4 5   NaN</span>
<span class="sd">          6   2.0</span>
<span class="sd">          7   3.0</span>
<span class="sd">          8   4.0</span>
<span class="sd">        5 9   NaN</span>
<span class="sd">          10  2.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate expanding summation of given DataFrame or Series.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Same type as the input, with the same index, containing the</span>
<span class="sd">            expanding summation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.expanding : Calling object with Series data.</span>
<span class="sd">        DataFrame.expanding : Calling object with DataFrames.</span>
<span class="sd">        Series.sum : Reducing sum for Series.</span>
<span class="sd">        DataFrame.sum : Reducing sum for DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = ps.Series([2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5])</span>
<span class="sd">        &gt;&gt;&gt; s.groupby(s).expanding(3).sum().sort_index()</span>
<span class="sd">        2  0      NaN</span>
<span class="sd">           1      NaN</span>
<span class="sd">        3  2      NaN</span>
<span class="sd">           3      NaN</span>
<span class="sd">           4      9.0</span>
<span class="sd">        4  5      NaN</span>
<span class="sd">           6      NaN</span>
<span class="sd">           7     12.0</span>
<span class="sd">           8     16.0</span>
<span class="sd">        5  9      NaN</span>
<span class="sd">           10     NaN</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        For DataFrame, each expanding summation is computed column-wise.</span>

<span class="sd">        &gt;&gt;&gt; df = ps.DataFrame({&quot;A&quot;: s.to_numpy(), &quot;B&quot;: s.to_numpy() ** 2})</span>
<span class="sd">        &gt;&gt;&gt; df.groupby(df.A).expanding(2).sum().sort_index()  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">                 B</span>
<span class="sd">        A</span>
<span class="sd">        2 0    NaN</span>
<span class="sd">          1    8.0</span>
<span class="sd">        3 2    NaN</span>
<span class="sd">          3   18.0</span>
<span class="sd">          4   27.0</span>
<span class="sd">        4 5    NaN</span>
<span class="sd">          6   32.0</span>
<span class="sd">          7   48.0</span>
<span class="sd">          8   64.0</span>
<span class="sd">        5 9    NaN</span>
<span class="sd">          10  50.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the expanding minimum.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Returned object type is determined by the caller of the expanding</span>
<span class="sd">            calculation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.expanding : Calling object with a Series.</span>
<span class="sd">        DataFrame.expanding : Calling object with a DataFrame.</span>
<span class="sd">        Series.min : Similar method for Series.</span>
<span class="sd">        DataFrame.min : Similar method for DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = ps.Series([2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5])</span>
<span class="sd">        &gt;&gt;&gt; s.groupby(s).expanding(3).min().sort_index()</span>
<span class="sd">        2  0     NaN</span>
<span class="sd">           1     NaN</span>
<span class="sd">        3  2     NaN</span>
<span class="sd">           3     NaN</span>
<span class="sd">           4     3.0</span>
<span class="sd">        4  5     NaN</span>
<span class="sd">           6     NaN</span>
<span class="sd">           7     4.0</span>
<span class="sd">           8     4.0</span>
<span class="sd">        5  9     NaN</span>
<span class="sd">           10    NaN</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        For DataFrame, each expanding minimum is computed column-wise.</span>

<span class="sd">        &gt;&gt;&gt; df = ps.DataFrame({&quot;A&quot;: s.to_numpy(), &quot;B&quot;: s.to_numpy() ** 2})</span>
<span class="sd">        &gt;&gt;&gt; df.groupby(df.A).expanding(2).min().sort_index()  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">                 B</span>
<span class="sd">        A</span>
<span class="sd">        2 0    NaN</span>
<span class="sd">          1    4.0</span>
<span class="sd">        3 2    NaN</span>
<span class="sd">          3    9.0</span>
<span class="sd">          4    9.0</span>
<span class="sd">        4 5    NaN</span>
<span class="sd">          6   16.0</span>
<span class="sd">          7   16.0</span>
<span class="sd">          8   16.0</span>
<span class="sd">        5 9    NaN</span>
<span class="sd">          10  25.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the expanding maximum.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Return type is determined by the caller.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.expanding : Calling object with Series data.</span>
<span class="sd">        DataFrame.expanding : Calling object with DataFrames.</span>
<span class="sd">        Series.max : Similar method for Series.</span>
<span class="sd">        DataFrame.max : Similar method for DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = ps.Series([2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5])</span>
<span class="sd">        &gt;&gt;&gt; s.groupby(s).expanding(3).max().sort_index()</span>
<span class="sd">        2  0     NaN</span>
<span class="sd">           1     NaN</span>
<span class="sd">        3  2     NaN</span>
<span class="sd">           3     NaN</span>
<span class="sd">           4     3.0</span>
<span class="sd">        4  5     NaN</span>
<span class="sd">           6     NaN</span>
<span class="sd">           7     4.0</span>
<span class="sd">           8     4.0</span>
<span class="sd">        5  9     NaN</span>
<span class="sd">           10    NaN</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        For DataFrame, each expanding maximum is computed column-wise.</span>

<span class="sd">        &gt;&gt;&gt; df = ps.DataFrame({&quot;A&quot;: s.to_numpy(), &quot;B&quot;: s.to_numpy() ** 2})</span>
<span class="sd">        &gt;&gt;&gt; df.groupby(df.A).expanding(2).max().sort_index()  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">                 B</span>
<span class="sd">        A</span>
<span class="sd">        2 0    NaN</span>
<span class="sd">          1    4.0</span>
<span class="sd">        3 2    NaN</span>
<span class="sd">          3    9.0</span>
<span class="sd">          4    9.0</span>
<span class="sd">        4 5    NaN</span>
<span class="sd">          6   16.0</span>
<span class="sd">          7   16.0</span>
<span class="sd">          8   16.0</span>
<span class="sd">        5 9    NaN</span>
<span class="sd">          10  25.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the expanding mean of the values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Returned object type is determined by the caller of the expanding</span>
<span class="sd">            calculation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.expanding : Calling object with Series data.</span>
<span class="sd">        DataFrame.expanding : Calling object with DataFrames.</span>
<span class="sd">        Series.mean : Equivalent method for Series.</span>
<span class="sd">        DataFrame.mean : Equivalent method for DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s = ps.Series([2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5])</span>
<span class="sd">        &gt;&gt;&gt; s.groupby(s).expanding(3).mean().sort_index()</span>
<span class="sd">        2  0     NaN</span>
<span class="sd">           1     NaN</span>
<span class="sd">        3  2     NaN</span>
<span class="sd">           3     NaN</span>
<span class="sd">           4     3.0</span>
<span class="sd">        4  5     NaN</span>
<span class="sd">           6     NaN</span>
<span class="sd">           7     4.0</span>
<span class="sd">           8     4.0</span>
<span class="sd">        5  9     NaN</span>
<span class="sd">           10    NaN</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        For DataFrame, each expanding mean is computed column-wise.</span>

<span class="sd">        &gt;&gt;&gt; df = ps.DataFrame({&quot;A&quot;: s.to_numpy(), &quot;B&quot;: s.to_numpy() ** 2})</span>
<span class="sd">        &gt;&gt;&gt; df.groupby(df.A).expanding(2).mean().sort_index()  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">                 B</span>
<span class="sd">        A</span>
<span class="sd">        2 0    NaN</span>
<span class="sd">          1    4.0</span>
<span class="sd">        3 2    NaN</span>
<span class="sd">          3    9.0</span>
<span class="sd">          4    9.0</span>
<span class="sd">        4 5    NaN</span>
<span class="sd">          6   16.0</span>
<span class="sd">          7   16.0</span>
<span class="sd">          8   16.0</span>
<span class="sd">        5 9    NaN</span>
<span class="sd">          10  25.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate expanding standard deviation.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Returns the same object type as the caller of the expanding calculation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.expanding: Calling object with Series data.</span>
<span class="sd">        DataFrame.expanding : Calling object with DataFrames.</span>
<span class="sd">        Series.std : Equivalent method for Series.</span>
<span class="sd">        DataFrame.std : Equivalent method for DataFrame.</span>
<span class="sd">        numpy.std : Equivalent method for Numpy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FrameLike</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate unbiased expanding variance.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series or DataFrame</span>
<span class="sd">            Returns the same object type as the caller of the expanding calculation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.expanding : Calling object with Series data.</span>
<span class="sd">        DataFrame.expanding : Calling object with DataFrames.</span>
<span class="sd">        Series.var : Equivalent method for Series.</span>
<span class="sd">        DataFrame.var : Equivalent method for DataFrame.</span>
<span class="sd">        numpy.var : Equivalent method for Numpy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">var</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_test</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">os</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="kn">from</span> <span class="nn">pyspark.sql</span> <span class="kn">import</span> <span class="n">SparkSession</span>
    <span class="kn">import</span> <span class="nn">pyspark.pandas.window</span>

    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;SPARK_HOME&quot;</span><span class="p">])</span>

    <span class="n">globs</span> <span class="o">=</span> <span class="n">pyspark</span><span class="o">.</span><span class="n">pandas</span><span class="o">.</span><span class="n">window</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">globs</span><span class="p">[</span><span class="s2">&quot;ps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pyspark</span><span class="o">.</span><span class="n">pandas</span>
    <span class="n">spark</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">SparkSession</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">master</span><span class="p">(</span><span class="s2">&quot;local[4]&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">appName</span><span class="p">(</span><span class="s2">&quot;pyspark.pandas.window tests&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">getOrCreate</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="p">(</span><span class="n">failure_count</span><span class="p">,</span> <span class="n">test_count</span><span class="p">)</span> <span class="o">=</span> <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">(</span>
        <span class="n">pyspark</span><span class="o">.</span><span class="n">pandas</span><span class="o">.</span><span class="n">window</span><span class="p">,</span>
        <span class="n">globs</span><span class="o">=</span><span class="n">globs</span><span class="p">,</span>
        <span class="n">optionflags</span><span class="o">=</span><span class="n">doctest</span><span class="o">.</span><span class="n">ELLIPSIS</span> <span class="o">|</span> <span class="n">doctest</span><span class="o">.</span><span class="n">NORMALIZE_WHITESPACE</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">spark</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">failure_count</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">_test</span><span class="p">()</span>
</pre></div>

              </div>
              
              
              <div class='prev-next-bottom'>
                

              </div>
              
          </main>
          

      </div>
    </div>

    
  <script src="../../../_static/js/index.3da636dd464baa7582d2.js"></script>


    <footer class="footer mt-5 mt-md-0">
  <div class="container">
    <p>
          &copy; Copyright .<br/>
        Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.4.<br/>
    </p>
  </div>
</footer>
  </body>
</html>