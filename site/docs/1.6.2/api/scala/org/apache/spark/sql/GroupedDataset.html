<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>GroupedDataset - org.apache.spark.sql.GroupedDataset</title>
          <meta name="description" content="GroupedDataset - org.apache.spark.sql.GroupedDataset" />
          <meta name="keywords" content="GroupedDataset org.apache.spark.sql.GroupedDataset" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <link href="../../../../lib/diagrams.css" media="screen" type="text/css" rel="stylesheet" id="diagrams-css" />
      <script type="text/javascript">
         if(top === self) {
            var url = '../../../../index.html';
            var hash = 'org.apache.spark.sql.GroupedDataset';
            var anchor = window.location.hash;
            var anchor_opt = '';
            if (anchor.length >= 1)
              anchor_opt = '@' + anchor.substring(1);
            window.location.href = url + '#' + hash + anchor_opt;
         }
   	  </script>
    
        </head>
        <body class="type">
      <div id="definition">
        <img src="../../../../lib/class_big.png" />
        <p id="owner"><a href="../../../package.html" class="extype" name="org">org</a>.<a href="../../package.html" class="extype" name="org.apache">apache</a>.<a href="../package.html" class="extype" name="org.apache.spark">spark</a>.<a href="package.html" class="extype" name="org.apache.spark.sql">sql</a></p>
        <h1>GroupedDataset</h1>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <span class="name">GroupedDataset</span><span class="tparams">[<span name="K">K</span>, <span name="V">V</span>]</span><span class="result"> extends <span class="extype" name="scala.Serializable">Serializable</span></span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p>:: Experimental ::
A <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a> has been logically grouped by a user specified grouping key.  Users should not
construct a <a href="" class="extype" name="org.apache.spark.sql.GroupedDataset">GroupedDataset</a> directly, but should instead call <code>groupBy</code> on an existing
<a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>.</p><p>COMPATIBILITY NOTE: Long term we plan to make <span class="extype" name="GroupedDataset)">GroupedDataset)</span> extend <code>GroupedData</code>.  However,
making this change to the class hierarchy would break some function signatures. As such, this
class should be considered a preview of the final API.  Changes will be made to the interface
after Spark 1.6.
</p></div><dl class="attributes block"> <dt>Annotations</dt><dd>
                <span class="name">@<a href="../annotation/Experimental.html" class="extype" name="org.apache.spark.annotation.Experimental">Experimental</a></span><span class="args">()</span>
              
        </dd><dt>Source</dt><dd><a href="https://github.com/apache/spark/tree/v1.6.2/sql/core/src/main/scala/org/apache/spark/sql/GroupedDataset.scala" target="_blank">GroupedDataset.scala</a></dd><dt>Since</dt><dd><p>1.6.0
</p></dd></dl><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><span class="extype" name="scala.Serializable">Serializable</span>, <span class="extype" name="java.io.Serializable">Serializable</span>, <span class="extype" name="scala.AnyRef">AnyRef</span>, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol>
                
                <li class="alpha in"><span>Alphabetic</span></li>
                <li class="inherit out"><span>By inheritance</span></li>
              </ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="org.apache.spark.sql.GroupedDataset"><span>GroupedDataset</span></li><li class="in" name="scala.Serializable"><span>Serializable</span></li><li class="in" name="java.io.Serializable"><span>Serializable</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li>
            </ol>
            <a href="http://docs.scala-lang.org/overviews/scaladoc/usage.html#members" target="_blank">Learn more about member selection</a>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        

        

        <div id="values" class="values members">
              <h3>Value Members</h3>
              <ol><li name="scala.AnyRef#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:AnyRef):Boolean"></a>
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#!=" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="!=(x$1:Any):Boolean"></a>
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="##():Int"></a>
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:AnyRef):Boolean"></a>
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#==" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="==(x$1:Any):Boolean"></a>
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="org.apache.spark.sql.GroupedDataset#agg" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="agg[U1,U2,U3,U4](col1:org.apache.spark.sql.TypedColumn[V,U1],col2:org.apache.spark.sql.TypedColumn[V,U2],col3:org.apache.spark.sql.TypedColumn[V,U3],col4:org.apache.spark.sql.TypedColumn[V,U4]):org.apache.spark.sql.Dataset[(K,U1,U2,U3,U4)]"></a>
      <a id="agg[U1,U2,U3,U4](TypedColumn[V,U1],TypedColumn[V,U2],TypedColumn[V,U3],TypedColumn[V,U4]):Dataset[(K,U1,U2,U3,U4)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">agg</span><span class="tparams">[<span name="U1">U1</span>, <span name="U2">U2</span>, <span name="U3">U3</span>, <span name="U4">U4</span>]</span><span class="params">(<span name="col1">col1: <a href="TypedColumn.html" class="extype" name="org.apache.spark.sql.TypedColumn">TypedColumn</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.V">V</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.agg.U1">U1</span>]</span>, <span name="col2">col2: <a href="TypedColumn.html" class="extype" name="org.apache.spark.sql.TypedColumn">TypedColumn</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.V">V</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.agg.U2">U2</span>]</span>, <span name="col3">col3: <a href="TypedColumn.html" class="extype" name="org.apache.spark.sql.TypedColumn">TypedColumn</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.V">V</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.agg.U3">U3</span>]</span>, <span name="col4">col4: <a href="TypedColumn.html" class="extype" name="org.apache.spark.sql.TypedColumn">TypedColumn</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.V">V</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.agg.U4">U4</span>]</span>)</span><span class="result">: <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>[(<span class="extype" name="org.apache.spark.sql.GroupedDataset.K">K</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.agg.U1">U1</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.agg.U2">U2</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.agg.U3">U3</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.agg.U4">U4</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Computes the given aggregations, returning a <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a> of tuples for each unique key
and the result of computing these aggregations over all elements in the group.</p><div class="fullcomment"><div class="comment cmt"><p>Computes the given aggregations, returning a <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a> of tuples for each unique key
and the result of computing these aggregations over all elements in the group.
</p></div><dl class="attributes block"> <dt>Since</dt><dd><p>1.6.0
</p></dd></dl></div>
    </li><li name="org.apache.spark.sql.GroupedDataset#agg" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="agg[U1,U2,U3](col1:org.apache.spark.sql.TypedColumn[V,U1],col2:org.apache.spark.sql.TypedColumn[V,U2],col3:org.apache.spark.sql.TypedColumn[V,U3]):org.apache.spark.sql.Dataset[(K,U1,U2,U3)]"></a>
      <a id="agg[U1,U2,U3](TypedColumn[V,U1],TypedColumn[V,U2],TypedColumn[V,U3]):Dataset[(K,U1,U2,U3)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">agg</span><span class="tparams">[<span name="U1">U1</span>, <span name="U2">U2</span>, <span name="U3">U3</span>]</span><span class="params">(<span name="col1">col1: <a href="TypedColumn.html" class="extype" name="org.apache.spark.sql.TypedColumn">TypedColumn</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.V">V</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.agg.U1">U1</span>]</span>, <span name="col2">col2: <a href="TypedColumn.html" class="extype" name="org.apache.spark.sql.TypedColumn">TypedColumn</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.V">V</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.agg.U2">U2</span>]</span>, <span name="col3">col3: <a href="TypedColumn.html" class="extype" name="org.apache.spark.sql.TypedColumn">TypedColumn</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.V">V</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.agg.U3">U3</span>]</span>)</span><span class="result">: <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>[(<span class="extype" name="org.apache.spark.sql.GroupedDataset.K">K</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.agg.U1">U1</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.agg.U2">U2</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.agg.U3">U3</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Computes the given aggregations, returning a <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a> of tuples for each unique key
and the result of computing these aggregations over all elements in the group.</p><div class="fullcomment"><div class="comment cmt"><p>Computes the given aggregations, returning a <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a> of tuples for each unique key
and the result of computing these aggregations over all elements in the group.
</p></div><dl class="attributes block"> <dt>Since</dt><dd><p>1.6.0
</p></dd></dl></div>
    </li><li name="org.apache.spark.sql.GroupedDataset#agg" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="agg[U1,U2](col1:org.apache.spark.sql.TypedColumn[V,U1],col2:org.apache.spark.sql.TypedColumn[V,U2]):org.apache.spark.sql.Dataset[(K,U1,U2)]"></a>
      <a id="agg[U1,U2](TypedColumn[V,U1],TypedColumn[V,U2]):Dataset[(K,U1,U2)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">agg</span><span class="tparams">[<span name="U1">U1</span>, <span name="U2">U2</span>]</span><span class="params">(<span name="col1">col1: <a href="TypedColumn.html" class="extype" name="org.apache.spark.sql.TypedColumn">TypedColumn</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.V">V</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.agg.U1">U1</span>]</span>, <span name="col2">col2: <a href="TypedColumn.html" class="extype" name="org.apache.spark.sql.TypedColumn">TypedColumn</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.V">V</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.agg.U2">U2</span>]</span>)</span><span class="result">: <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>[(<span class="extype" name="org.apache.spark.sql.GroupedDataset.K">K</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.agg.U1">U1</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.agg.U2">U2</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Computes the given aggregations, returning a <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a> of tuples for each unique key
and the result of computing these aggregations over all elements in the group.</p><div class="fullcomment"><div class="comment cmt"><p>Computes the given aggregations, returning a <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a> of tuples for each unique key
and the result of computing these aggregations over all elements in the group.
</p></div><dl class="attributes block"> <dt>Since</dt><dd><p>1.6.0
</p></dd></dl></div>
    </li><li name="org.apache.spark.sql.GroupedDataset#agg" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="agg[U1](col1:org.apache.spark.sql.TypedColumn[V,U1]):org.apache.spark.sql.Dataset[(K,U1)]"></a>
      <a id="agg[U1](TypedColumn[V,U1]):Dataset[(K,U1)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">agg</span><span class="tparams">[<span name="U1">U1</span>]</span><span class="params">(<span name="col1">col1: <a href="TypedColumn.html" class="extype" name="org.apache.spark.sql.TypedColumn">TypedColumn</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.V">V</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.agg.U1">U1</span>]</span>)</span><span class="result">: <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>[(<span class="extype" name="org.apache.spark.sql.GroupedDataset.K">K</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.agg.U1">U1</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Computes the given aggregation, returning a <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a> of tuples for each unique key
and the result of computing this aggregation over all elements in the group.</p><div class="fullcomment"><div class="comment cmt"><p>Computes the given aggregation, returning a <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a> of tuples for each unique key
and the result of computing this aggregation over all elements in the group.
</p></div><dl class="attributes block"> <dt>Since</dt><dd><p>1.6.0
</p></dd></dl></div>
    </li><li name="org.apache.spark.sql.GroupedDataset#aggUntyped" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="aggUntyped(columns:org.apache.spark.sql.TypedColumn[_,_]*):org.apache.spark.sql.Dataset[_]"></a>
      <a id="aggUntyped(TypedColumn[_,_]*):Dataset[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">aggUntyped</span><span class="params">(<span name="columns">columns: <a href="TypedColumn.html" class="extype" name="org.apache.spark.sql.TypedColumn">TypedColumn</a>[_, _]*</span>)</span><span class="result">: <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>[_]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Internal helper function for building typed aggregations that return tuples.</p><div class="fullcomment"><div class="comment cmt"><p>Internal helper function for building typed aggregations that return tuples.  For simplicity
and code reuse, we do this without the help of the type system and then use helper functions
that cast appropriately for the user facing interface.
TODO: does not handle aggrecations that return nonflat results,
</p></div><dl class="attributes block"> <dt>Attributes</dt><dd>protected </dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="asInstanceOf[T0]:T0"></a>
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Any.asInstanceOf.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="clone():Object"></a>
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.AnyRef">AnyRef</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.CloneNotSupportedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="org.apache.spark.sql.GroupedDataset#cogroup" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="cogroup[U,R](other:org.apache.spark.sql.GroupedDataset[K,U],f:org.apache.spark.api.java.function.CoGroupFunction[K,V,U,R],encoder:org.apache.spark.sql.Encoder[R]):org.apache.spark.sql.Dataset[R]"></a>
      <a id="cogroup[U,R](GroupedDataset[K,U],CoGroupFunction[K,V,U,R],Encoder[R]):Dataset[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">cogroup</span><span class="tparams">[<span name="U">U</span>, <span name="R">R</span>]</span><span class="params">(<span name="other">other: <a href="" class="extype" name="org.apache.spark.sql.GroupedDataset">GroupedDataset</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.K">K</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.cogroup.U">U</span>]</span>, <span name="f">f: <a href="../api/java/function/CoGroupFunction.html" class="extype" name="org.apache.spark.api.java.function.CoGroupFunction">CoGroupFunction</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.K">K</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.V">V</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.cogroup.U">U</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.cogroup.R">R</span>]</span>, <span name="encoder">encoder: <a href="Encoder.html" class="extype" name="org.apache.spark.sql.Encoder">Encoder</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.cogroup.R">R</span>]</span>)</span><span class="result">: <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.cogroup.R">R</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Applies the given function to each cogrouped data.</p><div class="fullcomment"><div class="comment cmt"><p>Applies the given function to each cogrouped data.  For each unique group, the function will
be passed the grouping key and 2 iterators containing all elements in the group from
<a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a> <code>this</code> and <code>other</code>.  The function can return an iterator containing elements of an
arbitrary type which will be returned as a new <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>.
</p></div><dl class="attributes block"> <dt>Since</dt><dd><p>1.6.0
</p></dd></dl></div>
    </li><li name="org.apache.spark.sql.GroupedDataset#cogroup" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="cogroup[U,R](other:org.apache.spark.sql.GroupedDataset[K,U])(f:(K,Iterator[V],Iterator[U])=&gt;TraversableOnce[R])(implicitevidence$4:org.apache.spark.sql.Encoder[R]):org.apache.spark.sql.Dataset[R]"></a>
      <a id="cogroup[U,R](GroupedDataset[K,U])((K,Iterator[V],Iterator[U])⇒TraversableOnce[R])(Encoder[R]):Dataset[R]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">cogroup</span><span class="tparams">[<span name="U">U</span>, <span name="R">R</span>]</span><span class="params">(<span name="other">other: <a href="" class="extype" name="org.apache.spark.sql.GroupedDataset">GroupedDataset</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.K">K</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.cogroup.U">U</span>]</span>)</span><span class="params">(<span name="f">f: (<span class="extype" name="org.apache.spark.sql.GroupedDataset.K">K</span>, <span class="extype" name="scala.Iterator">Iterator</span>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.V">V</span>], <span class="extype" name="scala.Iterator">Iterator</span>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.cogroup.U">U</span>]) ⇒ <span class="extype" name="scala.TraversableOnce">TraversableOnce</span>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.cogroup.R">R</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="Encoder.html" class="extype" name="org.apache.spark.sql.Encoder">Encoder</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.cogroup.R">R</span>]</span>)</span><span class="result">: <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.cogroup.R">R</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Applies the given function to each cogrouped data.</p><div class="fullcomment"><div class="comment cmt"><p>Applies the given function to each cogrouped data.  For each unique group, the function will
be passed the grouping key and 2 iterators containing all elements in the group from
<a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a> <code>this</code> and <code>other</code>.  The function can return an iterator containing elements of an
arbitrary type which will be returned as a new <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>.
</p></div><dl class="attributes block"> <dt>Since</dt><dd><p>1.6.0
</p></dd></dl></div>
    </li><li name="org.apache.spark.sql.GroupedDataset#count" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="count():org.apache.spark.sql.Dataset[(K,Long)]"></a>
      <a id="count():Dataset[(K,Long)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">count</span><span class="params">()</span><span class="result">: <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>[(<span class="extype" name="org.apache.spark.sql.GroupedDataset.K">K</span>, <span class="extype" name="scala.Long">Long</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a> that contains a tuple with each key and the number of items present
for that key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a> that contains a tuple with each key and the number of items present
for that key.
</p></div><dl class="attributes block"> <dt>Since</dt><dd><p>1.6.0
</p></dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="eq(x$1:AnyRef):Boolean"></a>
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="equals(x$1:Any):Boolean"></a>
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="finalize():Unit"></a>
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../../java$lang.html" class="extype" name="java.lang">java.lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="symbol">classOf[java.lang.Throwable]</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="org.apache.spark.sql.GroupedDataset#flatMapGroups" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="flatMapGroups[U](f:org.apache.spark.api.java.function.FlatMapGroupsFunction[K,V,U],encoder:org.apache.spark.sql.Encoder[U]):org.apache.spark.sql.Dataset[U]"></a>
      <a id="flatMapGroups[U](FlatMapGroupsFunction[K,V,U],Encoder[U]):Dataset[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flatMapGroups</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: <a href="../api/java/function/FlatMapGroupsFunction.html" class="extype" name="org.apache.spark.api.java.function.FlatMapGroupsFunction">FlatMapGroupsFunction</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.K">K</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.V">V</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.flatMapGroups.U">U</span>]</span>, <span name="encoder">encoder: <a href="Encoder.html" class="extype" name="org.apache.spark.sql.Encoder">Encoder</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.flatMapGroups.U">U</span>]</span>)</span><span class="result">: <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.flatMapGroups.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Applies the given function to each group of data.</p><div class="fullcomment"><div class="comment cmt"><p>Applies the given function to each group of data.  For each unique group, the function will
be passed the group key and an iterator that contains all of the elements in the group. The
function can return an iterator containing elements of an arbitrary type which will be returned
as a new <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>.</p><p>This function does not support partial aggregation, and as a result requires shuffling all
the data in the <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>. If an application intends to perform an aggregation over each
key, it is best to use the reduce function or an
<a href="expressions/Aggregator.html" class="extype" name="org.apache.spark.sql.expressions.Aggregator">Aggregator</a>.</p><p>Internally, the implementation will spill to disk if any given group is too large to fit into
memory.  However, users must take care to avoid materializing the whole iterator for a group
(for example, by calling <code>toList</code>) unless they are sure that this is possible given the memory
constraints of their cluster.
</p></div><dl class="attributes block"> <dt>Since</dt><dd><p>1.6.0
</p></dd></dl></div>
    </li><li name="org.apache.spark.sql.GroupedDataset#flatMapGroups" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="flatMapGroups[U](f:(K,Iterator[V])=&gt;TraversableOnce[U])(implicitevidence$2:org.apache.spark.sql.Encoder[U]):org.apache.spark.sql.Dataset[U]"></a>
      <a id="flatMapGroups[U]((K,Iterator[V])⇒TraversableOnce[U])(Encoder[U]):Dataset[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">flatMapGroups</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="org.apache.spark.sql.GroupedDataset.K">K</span>, <span class="extype" name="scala.Iterator">Iterator</span>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.V">V</span>]) ⇒ <span class="extype" name="scala.TraversableOnce">TraversableOnce</span>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.flatMapGroups.U">U</span>]</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="Encoder.html" class="extype" name="org.apache.spark.sql.Encoder">Encoder</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.flatMapGroups.U">U</span>]</span>)</span><span class="result">: <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.flatMapGroups.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Applies the given function to each group of data.</p><div class="fullcomment"><div class="comment cmt"><p>Applies the given function to each group of data.  For each unique group, the function will
be passed the group key and an iterator that contains all of the elements in the group. The
function can return an iterator containing elements of an arbitrary type which will be returned
as a new <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>.</p><p>This function does not support partial aggregation, and as a result requires shuffling all
the data in the <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>. If an application intends to perform an aggregation over each
key, it is best to use the reduce function or an
<a href="expressions/Aggregator.html" class="extype" name="org.apache.spark.sql.expressions.Aggregator">Aggregator</a>.</p><p>Internally, the implementation will spill to disk if any given group is too large to fit into
memory.  However, users must take care to avoid materializing the whole iterator for a group
(for example, by calling <code>toList</code>) unless they are sure that this is possible given the memory
constraints of their cluster.
</p></div><dl class="attributes block"> <dt>Since</dt><dd><p>1.6.0
</p></dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="getClass():Class[_]"></a>
      <a id="getClass():Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.Class">Class</span>[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="hashCode():Int"></a>
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="org.apache.spark.sql.GroupedDataset#keyAs" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="keyAs[L](implicitevidence$1:org.apache.spark.sql.Encoder[L]):org.apache.spark.sql.GroupedDataset[L,V]"></a>
      <a id="keyAs[L](Encoder[L]):GroupedDataset[L,V]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">keyAs</span><span class="tparams">[<span name="L">L</span>]</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="Encoder.html" class="extype" name="org.apache.spark.sql.Encoder">Encoder</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.keyAs.L">L</span>]</span>)</span><span class="result">: <a href="" class="extype" name="org.apache.spark.sql.GroupedDataset">GroupedDataset</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.keyAs.L">L</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.V">V</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a new <a href="" class="extype" name="org.apache.spark.sql.GroupedDataset">GroupedDataset</a> where the type of the key has been mapped to the specified
type.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a new <a href="" class="extype" name="org.apache.spark.sql.GroupedDataset">GroupedDataset</a> where the type of the key has been mapped to the specified
type. The mapping of key columns to the type follows the same rules as <code>as</code> on <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>.
</p></div><dl class="attributes block"> <dt>Since</dt><dd><p>1.6.0
</p></dd></dl></div>
    </li><li name="org.apache.spark.sql.GroupedDataset#keys" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="keys:org.apache.spark.sql.Dataset[K]"></a>
      <a id="keys:Dataset[K]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">keys</span><span class="result">: <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.K">K</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a> that contains each unique key.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a> that contains each unique key.
</p></div><dl class="attributes block"> <dt>Since</dt><dd><p>1.6.0
</p></dd></dl></div>
    </li><li name="org.apache.spark.sql.GroupedDataset#mapGroups" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mapGroups[U](f:org.apache.spark.api.java.function.MapGroupsFunction[K,V,U],encoder:org.apache.spark.sql.Encoder[U]):org.apache.spark.sql.Dataset[U]"></a>
      <a id="mapGroups[U](MapGroupsFunction[K,V,U],Encoder[U]):Dataset[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mapGroups</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: <a href="../api/java/function/MapGroupsFunction.html" class="extype" name="org.apache.spark.api.java.function.MapGroupsFunction">MapGroupsFunction</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.K">K</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.V">V</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.mapGroups.U">U</span>]</span>, <span name="encoder">encoder: <a href="Encoder.html" class="extype" name="org.apache.spark.sql.Encoder">Encoder</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.mapGroups.U">U</span>]</span>)</span><span class="result">: <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.mapGroups.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Applies the given function to each group of data.</p><div class="fullcomment"><div class="comment cmt"><p>Applies the given function to each group of data.  For each unique group, the function will
be passed the group key and an iterator that contains all of the elements in the group. The
function can return an element of arbitrary type which will be returned as a new <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>.</p><p>This function does not support partial aggregation, and as a result requires shuffling all
the data in the <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>. If an application intends to perform an aggregation over each
key, it is best to use the reduce function or an
<a href="expressions/Aggregator.html" class="extype" name="org.apache.spark.sql.expressions.Aggregator">Aggregator</a>.</p><p>Internally, the implementation will spill to disk if any given group is too large to fit into
memory.  However, users must take care to avoid materializing the whole iterator for a group
(for example, by calling <code>toList</code>) unless they are sure that this is possible given the memory
constraints of their cluster.
</p></div><dl class="attributes block"> <dt>Since</dt><dd><p>1.6.0
</p></dd></dl></div>
    </li><li name="org.apache.spark.sql.GroupedDataset#mapGroups" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="mapGroups[U](f:(K,Iterator[V])=&gt;U)(implicitevidence$3:org.apache.spark.sql.Encoder[U]):org.apache.spark.sql.Dataset[U]"></a>
      <a id="mapGroups[U]((K,Iterator[V])⇒U)(Encoder[U]):Dataset[U]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">mapGroups</span><span class="tparams">[<span name="U">U</span>]</span><span class="params">(<span name="f">f: (<span class="extype" name="org.apache.spark.sql.GroupedDataset.K">K</span>, <span class="extype" name="scala.Iterator">Iterator</span>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.V">V</span>]) ⇒ <span class="extype" name="org.apache.spark.sql.GroupedDataset.mapGroups.U">U</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="arg0">arg0: <a href="Encoder.html" class="extype" name="org.apache.spark.sql.Encoder">Encoder</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.mapGroups.U">U</span>]</span>)</span><span class="result">: <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.mapGroups.U">U</span>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Applies the given function to each group of data.</p><div class="fullcomment"><div class="comment cmt"><p>Applies the given function to each group of data.  For each unique group, the function will
be passed the group key and an iterator that contains all of the elements in the group. The
function can return an element of arbitrary type which will be returned as a new <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>.</p><p>This function does not support partial aggregation, and as a result requires shuffling all
the data in the <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>. If an application intends to perform an aggregation over each
key, it is best to use the reduce function or an
<a href="expressions/Aggregator.html" class="extype" name="org.apache.spark.sql.expressions.Aggregator">Aggregator</a>.</p><p>Internally, the implementation will spill to disk if any given group is too large to fit into
memory.  However, users must take care to avoid materializing the whole iterator for a group
(for example, by calling <code>toList</code>) unless they are sure that this is possible given the memory
constraints of their cluster.
</p></div><dl class="attributes block"> <dt>Since</dt><dd><p>1.6.0
</p></dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="ne(x$1:AnyRef):Boolean"></a>
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.AnyRef">AnyRef</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notify():Unit"></a>
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="notifyAll():Unit"></a>
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="org.apache.spark.sql.GroupedDataset#queryExecution" visbl="pub" data-isabs="false" fullComment="no" group="Ungrouped">
      <a id="queryExecution:org.apache.spark.sql.execution.QueryExecution"></a>
      <a id="queryExecution:QueryExecution"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">val</span>
      </span>
      <span class="symbol">
        <span class="name">queryExecution</span><span class="result">: <span class="extype" name="org.apache.spark.sql.execution.QueryExecution">QueryExecution</span></span>
      </span>
      </h4>
      
    </li><li name="org.apache.spark.sql.GroupedDataset#reduce" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="reduce(f:org.apache.spark.api.java.function.ReduceFunction[V]):org.apache.spark.sql.Dataset[(K,V)]"></a>
      <a id="reduce(ReduceFunction[V]):Dataset[(K,V)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduce</span><span class="params">(<span name="f">f: <a href="../api/java/function/ReduceFunction.html" class="extype" name="org.apache.spark.api.java.function.ReduceFunction">ReduceFunction</a>[<span class="extype" name="org.apache.spark.sql.GroupedDataset.V">V</span>]</span>)</span><span class="result">: <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>[(<span class="extype" name="org.apache.spark.sql.GroupedDataset.K">K</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.V">V</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Reduces the elements of each group of data using the specified binary function.</p><div class="fullcomment"><div class="comment cmt"><p>Reduces the elements of each group of data using the specified binary function.
The given function must be commutative and associative or the result may be non-deterministic.
</p></div><dl class="attributes block"> <dt>Since</dt><dd><p>1.6.0
</p></dd></dl></div>
    </li><li name="org.apache.spark.sql.GroupedDataset#reduce" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="reduce(f:(V,V)=&gt;V):org.apache.spark.sql.Dataset[(K,V)]"></a>
      <a id="reduce((V,V)⇒V):Dataset[(K,V)]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">reduce</span><span class="params">(<span name="f">f: (<span class="extype" name="org.apache.spark.sql.GroupedDataset.V">V</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.V">V</span>) ⇒ <span class="extype" name="org.apache.spark.sql.GroupedDataset.V">V</span></span>)</span><span class="result">: <a href="Dataset.html" class="extype" name="org.apache.spark.sql.Dataset">Dataset</a>[(<span class="extype" name="org.apache.spark.sql.GroupedDataset.K">K</span>, <span class="extype" name="org.apache.spark.sql.GroupedDataset.V">V</span>)]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Reduces the elements of each group of data using the specified binary function.</p><div class="fullcomment"><div class="comment cmt"><p>Reduces the elements of each group of data using the specified binary function.
The given function must be commutative and associative or the result may be non-deterministic.
</p></div><dl class="attributes block"> <dt>Since</dt><dd><p>1.6.0
</p></dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="synchronized[T0](x$1:=&gt;T0):T0"></a>
      <a id="synchronized[T0](⇒T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>)</span><span class="result">: <span class="extype" name="java.lang.AnyRef.synchronized.T0">T0</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="toString():String"></a>
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait():Unit"></a>
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long,x$2:Int):Unit"></a>
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes" group="Ungrouped">
      <a id="wait(x$1:Long):Unit"></a>
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">(<span>
      
      <span class="defval" name="classOf[java.lang.InterruptedException]">...</span>
    </span>)</span>
              
        </dd></dl></div>
    </li></ol>
            </div>

        

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="scala.Serializable">
              <h3>Inherited from <span class="extype" name="scala.Serializable">Serializable</span></h3>
            </div><div class="parent" name="java.io.Serializable">
              <h3>Inherited from <span class="extype" name="java.io.Serializable">Serializable</span></h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from <span class="extype" name="scala.AnyRef">AnyRef</span></h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

        <div id="groupedMembers">
        <div class="group" name="Ungrouped">
              <h3>Ungrouped</h3>
              
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>
      <script defer="defer" type="text/javascript" id="jquery-js" src="../../../../lib/jquery.js"></script><script defer="defer" type="text/javascript" id="jquery-ui-js" src="../../../../lib/jquery-ui.js"></script><script defer="defer" type="text/javascript" id="tools-tooltip-js" src="../../../../lib/tools.tooltip.js"></script><script defer="defer" type="text/javascript" id="template-js" src="../../../../lib/template.js"></script>
    </body>
      </html>