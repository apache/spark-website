<table class="table">
  <thead>
    <tr>
      <th style="width:25%">Function</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>array_contains(array, value)</td>
      <td>Returns true if the array contains the value.</td>
    </tr>
    <tr>
      <td>array_distinct(array)</td>
      <td>Removes duplicate values from the array.</td>
    </tr>
    <tr>
      <td>array_except(array1, array2)</td>
      <td>Returns an array of the elements in array1 but not in array2,
    without duplicates.</td>
    </tr>
    <tr>
      <td>array_intersect(array1, array2)</td>
      <td>Returns an array of the elements in the intersection of array1 and
    array2, without duplicates.</td>
    </tr>
    <tr>
      <td>array_join(array, delimiter[, nullReplacement])</td>
      <td>Concatenates the elements of the given array
      using the delimiter and an optional string to replace nulls. If no value is set for
      nullReplacement, any null value is filtered.</td>
    </tr>
    <tr>
      <td>array_max(array)</td>
      <td>Returns the maximum value in the array. NULL elements are skipped.</td>
    </tr>
    <tr>
      <td>array_min(array)</td>
      <td>Returns the minimum value in the array. NULL elements are skipped.</td>
    </tr>
    <tr>
      <td>array_position(array, element)</td>
      <td>Returns the (1-based) index of the first element of the array as long.</td>
    </tr>
    <tr>
      <td>array_remove(array, element)</td>
      <td>Remove all elements that equal to element from array.</td>
    </tr>
    <tr>
      <td>array_repeat(element, count)</td>
      <td>Returns the array containing element count times.</td>
    </tr>
    <tr>
      <td>array_union(array1, array2)</td>
      <td>Returns an array of the elements in the union of array1 and array2,
      without duplicates.</td>
    </tr>
    <tr>
      <td>arrays_overlap(a1, a2)</td>
      <td>Returns true if a1 contains at least a non-null element present also in a2. If the arrays have no common element and they are both non-empty and either of them contains a null element null is returned, false otherwise.</td>
    </tr>
    <tr>
      <td>arrays_zip(a1, a2, ...)</td>
      <td>Returns a merged array of structs in which the N-th struct contains all
    N-th values of input arrays.</td>
    </tr>
    <tr>
      <td>concat(col1, col2, ..., colN)</td>
      <td>Returns the concatenation of col1, col2, ..., colN.</td>
    </tr>
    <tr>
      <td>flatten(arrayOfArrays)</td>
      <td>Transforms an array of arrays into a single array.</td>
    </tr>
    <tr>
      <td>reverse(array)</td>
      <td>Returns a reversed string or an array with reverse order of elements.</td>
    </tr>
    <tr>
      <td>sequence(start, stop, step)</td>
      <td>Generates an array of elements from start to stop (inclusive),
      incrementing by step. The type of the returned elements is the same as the type of argument
      expressions.

      Supported types are: byte, short, integer, long, date, timestamp.

      The start and stop expressions must resolve to the same type.
      If start and stop expressions resolve to the 'date' or 'timestamp' type
      then the step expression must resolve to the 'interval' type, otherwise to the same type
      as the start and stop expressions.</td>
    </tr>
    <tr>
      <td>shuffle(array)</td>
      <td>Returns a random permutation of the given array.</td>
    </tr>
    <tr>
      <td>slice(x, start, length)</td>
      <td>Subsets array x starting from index start (array indices start at 1, or starting from the end if start is negative) with the specified length.</td>
    </tr>
    <tr>
      <td>sort_array(array[, ascendingOrder])</td>
      <td>Sorts the input array in ascending or descending order
      according to the natural ordering of the array elements. Null elements will be placed
      at the beginning of the returned array in ascending order or at the end of the returned
      array in descending order.</td>
    </tr>
  </tbody>
</table>
