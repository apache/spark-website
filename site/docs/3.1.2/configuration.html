
<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Configuration - Spark 3.1.2 Documentation</title>
        

        

        <link rel="stylesheet" href="css/bootstrap.min.css">
        <style>
            body {
                padding-top: 60px;
                padding-bottom: 40px;
            }
        </style>
        <meta name="viewport" content="width=device-width">
        <link rel="stylesheet" href="css/main.css">

        <script src="js/vendor/modernizr-2.6.1-respond-1.1.0.min.js"></script>

        <link rel="stylesheet" href="css/pygments-default.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
        <link rel="stylesheet" href="css/docsearch.css">

        
        <!-- Google analytics script -->
        <script type="text/javascript">
          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-32518208-2']);
          _gaq.push(['_trackPageview']);

          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();
        </script>
        

    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="https://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->

        <!-- This code is taken from http://twitter.github.com/bootstrap/examples/hero.html -->

        <nav class="navbar fixed-top navbar-expand-md navbar-light bg-light" id="topbar">
            <div class="container">
                <div class="navbar-header">
                    <div class="navbar-brand"><a href="index.html">
                        <img src="img/spark-logo-hd.png" style="height:50px;"/></a><span class="version">3.1.2</span>
                    </div>
                </div>
                <button class="navbar-toggler" type="button" data-toggle="collapse"
                        data-target="#navbarCollapse" aria-controls="navbarCollapse"
                        aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse" id="navbarCollapse">
                    <ul class="navbar-nav">
                        <!--TODO(andyk): Add class="active" attribute to li some how.-->
                        <li class="nav-item"><a href="index.html" class="nav-link">Overview</a></li>

                        <li class="nav-item dropdown">
                            <a href="#" class="nav-link dropdown-toggle" id="navbarQuickStart" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Programming Guides</a>
                            <div class="dropdown-menu" aria-labelledby="navbarQuickStart">
                                <a class="dropdown-item" href="quick-start.html">Quick Start</a>
                                <a class="dropdown-item" href="rdd-programming-guide.html">RDDs, Accumulators, Broadcasts Vars</a>
                                <a class="dropdown-item" href="sql-programming-guide.html">SQL, DataFrames, and Datasets</a>
                                <a class="dropdown-item" href="structured-streaming-programming-guide.html">Structured Streaming</a>
                                <a class="dropdown-item" href="streaming-programming-guide.html">Spark Streaming (DStreams)</a>
                                <a class="dropdown-item" href="ml-guide.html">MLlib (Machine Learning)</a>
                                <a class="dropdown-item" href="graphx-programming-guide.html">GraphX (Graph Processing)</a>
                                <a class="dropdown-item" href="sparkr.html">SparkR (R on Spark)</a>
                                <a class="dropdown-item" href="api/python/getting_started/index.html">PySpark (Python on Spark)</a>
                            </div>
                        </li>

                        <li class="nav-item dropdown">
                            <a href="#" class="nav-link dropdown-toggle" id="navbarAPIDocs" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">API Docs</a>
                            <div class="dropdown-menu" aria-labelledby="navbarAPIDocs">
                                <a class="dropdown-item" href="api/scala/org/apache/spark/index.html">Scala</a>
                                <a class="dropdown-item" href="api/java/index.html">Java</a>
                                <a class="dropdown-item" href="api/python/index.html">Python</a>
                                <a class="dropdown-item" href="api/R/index.html">R</a>
                                <a class="dropdown-item" href="api/sql/index.html">SQL, Built-in Functions</a>
                            </div>
                        </li>

                        <li class="nav-item dropdown">
                            <a href="#" class="nav-link dropdown-toggle" id="navbarDeploying" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Deploying</a>
                            <div class="dropdown-menu" aria-labelledby="navbarDeploying">
                                <a class="dropdown-item" href="cluster-overview.html">Overview</a>
                                <a class="dropdown-item" href="submitting-applications.html">Submitting Applications</a>
                                <div class="dropdown-divider"></div>
                                <a class="dropdown-item" href="spark-standalone.html">Spark Standalone</a>
                                <a class="dropdown-item" href="running-on-mesos.html">Mesos</a>
                                <a class="dropdown-item" href="running-on-yarn.html">YARN</a>
                                <a class="dropdown-item" href="running-on-kubernetes.html">Kubernetes</a>
                            </div>
                        </li>

                        <li class="nav-item dropdown">
                            <a href="#" class="nav-link dropdown-toggle" id="navbarMore" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">More</a>
                            <div class="dropdown-menu" aria-labelledby="navbarMore">
                                <a class="dropdown-item" href="configuration.html">Configuration</a>
                                <a class="dropdown-item" href="monitoring.html">Monitoring</a>
                                <a class="dropdown-item" href="tuning.html">Tuning Guide</a>
                                <a class="dropdown-item" href="job-scheduling.html">Job Scheduling</a>
                                <a class="dropdown-item" href="security.html">Security</a>
                                <a class="dropdown-item" href="hardware-provisioning.html">Hardware Provisioning</a>
                                <a class="dropdown-item" href="migration-guide.html">Migration Guide</a>
                                <div class="dropdown-divider"></div>
                                <a class="dropdown-item" href="building-spark.html">Building Spark</a>
                                <a class="dropdown-item" href="https://spark.apache.org/contributing.html">Contributing to Spark</a>
                                <a class="dropdown-item" href="https://spark.apache.org/third-party-projects.html">Third Party Projects</a>
                            </div>
                        </li>

                        <li class="nav-item">
                            <input type="text" id="docsearch-input" placeholder="Search the docsâ€¦">
                        </li>
                    </ul>
                    <!--<span class="navbar-text navbar-right"><span class="version-text">v3.1.2</span></span>-->
                </div>
            </div>
        </nav>

        <div class="container-wrapper">

            
                <div class="content mr-3" id="content">
                    
                        <h1 class="title">Spark Configuration</h1>
                    

                    <ul id="markdown-toc">
  <li><a href="#spark-properties" id="markdown-toc-spark-properties">Spark Properties</a>    <ul>
      <li><a href="#dynamically-loading-spark-properties" id="markdown-toc-dynamically-loading-spark-properties">Dynamically Loading Spark Properties</a></li>
      <li><a href="#viewing-spark-properties" id="markdown-toc-viewing-spark-properties">Viewing Spark Properties</a></li>
      <li><a href="#available-properties" id="markdown-toc-available-properties">Available Properties</a>        <ul>
          <li><a href="#application-properties" id="markdown-toc-application-properties">Application Properties</a></li>
          <li><a href="#runtime-environment" id="markdown-toc-runtime-environment">Runtime Environment</a></li>
          <li><a href="#shuffle-behavior" id="markdown-toc-shuffle-behavior">Shuffle Behavior</a></li>
          <li><a href="#spark-ui" id="markdown-toc-spark-ui">Spark UI</a></li>
          <li><a href="#compression-and-serialization" id="markdown-toc-compression-and-serialization">Compression and Serialization</a></li>
          <li><a href="#memory-management" id="markdown-toc-memory-management">Memory Management</a></li>
          <li><a href="#execution-behavior" id="markdown-toc-execution-behavior">Execution Behavior</a></li>
          <li><a href="#executor-metrics" id="markdown-toc-executor-metrics">Executor Metrics</a></li>
          <li><a href="#networking" id="markdown-toc-networking">Networking</a></li>
          <li><a href="#scheduling" id="markdown-toc-scheduling">Scheduling</a></li>
          <li><a href="#barrier-execution-mode" id="markdown-toc-barrier-execution-mode">Barrier Execution Mode</a></li>
          <li><a href="#dynamic-allocation" id="markdown-toc-dynamic-allocation">Dynamic Allocation</a></li>
          <li><a href="#thread-configurations" id="markdown-toc-thread-configurations">Thread Configurations</a></li>
          <li><a href="#security" id="markdown-toc-security">Security</a></li>
          <li><a href="#spark-sql" id="markdown-toc-spark-sql">Spark SQL</a>            <ul>
              <li><a href="#runtime-sql-configuration" id="markdown-toc-runtime-sql-configuration">Runtime SQL Configuration</a></li>
              <li><a href="#static-sql-configuration" id="markdown-toc-static-sql-configuration">Static SQL Configuration</a></li>
            </ul>
          </li>
          <li><a href="#spark-streaming" id="markdown-toc-spark-streaming">Spark Streaming</a></li>
          <li><a href="#sparkr" id="markdown-toc-sparkr">SparkR</a></li>
          <li><a href="#graphx" id="markdown-toc-graphx">GraphX</a></li>
          <li><a href="#deploy" id="markdown-toc-deploy">Deploy</a></li>
          <li><a href="#cluster-managers" id="markdown-toc-cluster-managers">Cluster Managers</a>            <ul>
              <li><a href="#yarn" id="markdown-toc-yarn">YARN</a></li>
              <li><a href="#mesos" id="markdown-toc-mesos">Mesos</a></li>
              <li><a href="#kubernetes" id="markdown-toc-kubernetes">Kubernetes</a></li>
              <li><a href="#standalone-mode" id="markdown-toc-standalone-mode">Standalone Mode</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#environment-variables" id="markdown-toc-environment-variables">Environment Variables</a></li>
  <li><a href="#configuring-logging" id="markdown-toc-configuring-logging">Configuring Logging</a></li>
  <li><a href="#overriding-configuration-directory" id="markdown-toc-overriding-configuration-directory">Overriding configuration directory</a></li>
  <li><a href="#inheriting-hadoop-cluster-configuration" id="markdown-toc-inheriting-hadoop-cluster-configuration">Inheriting Hadoop Cluster Configuration</a></li>
  <li><a href="#custom-hadoophive-configuration" id="markdown-toc-custom-hadoophive-configuration">Custom Hadoop/Hive Configuration</a></li>
  <li><a href="#custom-resource-scheduling-and-configuration-overview" id="markdown-toc-custom-resource-scheduling-and-configuration-overview">Custom Resource Scheduling and Configuration Overview</a></li>
  <li><a href="#stage-level-scheduling-overview" id="markdown-toc-stage-level-scheduling-overview">Stage Level Scheduling Overview</a></li>
</ul>

<p>Spark provides three locations to configure the system:</p>

<ul>
  <li><a href="#spark-properties">Spark properties</a> control most application parameters and can be set by using
a <a href="api/scala/org/apache/spark/SparkConf.html">SparkConf</a> object, or through Java
system properties.</li>
  <li><a href="#environment-variables">Environment variables</a> can be used to set per-machine settings, such as
the IP address, through the <code class="language-plaintext highlighter-rouge">conf/spark-env.sh</code> script on each node.</li>
  <li><a href="#configuring-logging">Logging</a> can be configured through <code class="language-plaintext highlighter-rouge">log4j.properties</code>.</li>
</ul>

<h1 id="spark-properties">Spark Properties</h1>

<p>Spark properties control most application settings and are configured separately for each
application. These properties can be set directly on a
<a href="api/scala/org/apache/spark/SparkConf.html">SparkConf</a> passed to your
<code class="language-plaintext highlighter-rouge">SparkContext</code>. <code class="language-plaintext highlighter-rouge">SparkConf</code> allows you to configure some of the common properties
(e.g. master URL and application name), as well as arbitrary key-value pairs through the
<code class="language-plaintext highlighter-rouge">set()</code> method. For example, we could initialize an application with two threads as follows:</p>

<p>Note that we run with local[2], meaning two threads - which represents &#8220;minimal&#8221; parallelism,
which can help detect bugs that only exist when we run in a distributed context.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="nv">conf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SparkConf</span><span class="o">()</span>
             <span class="o">.</span><span class="py">setMaster</span><span class="o">(</span><span class="s">"local[2]"</span><span class="o">)</span>
             <span class="o">.</span><span class="py">setAppName</span><span class="o">(</span><span class="s">"CountingSheep"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">sc</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SparkContext</span><span class="o">(</span><span class="n">conf</span><span class="o">)</span></code></pre></figure>

<p>Note that we can have more than 1 thread in local mode, and in cases like Spark Streaming, we may
actually require more than 1 thread to prevent any sort of starvation issues.</p>

<p>Properties that specify some time duration should be configured with a unit of time.
The following format is accepted:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>25ms (milliseconds)
5s (seconds)
10m or 10min (minutes)
3h (hours)
5d (days)
1y (years)
</code></pre></div></div>

<p>Properties that specify a byte size should be configured with a unit of size.
The following format is accepted:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1b (bytes)
1k or 1kb (kibibytes = 1024 bytes)
1m or 1mb (mebibytes = 1024 kibibytes)
1g or 1gb (gibibytes = 1024 mebibytes)
1t or 1tb (tebibytes = 1024 gibibytes)
1p or 1pb (pebibytes = 1024 tebibytes)
</code></pre></div></div>

<p>While numbers without units are generally interpreted as bytes, a few are interpreted as KiB or MiB.
See documentation of individual configuration properties. Specifying units is desirable where 
possible.</p>

<h2 id="dynamically-loading-spark-properties">Dynamically Loading Spark Properties</h2>

<p>In some cases, you may want to avoid hard-coding certain configurations in a <code class="language-plaintext highlighter-rouge">SparkConf</code>. For
instance, if you&#8217;d like to run the same application with different masters or different
amounts of memory. Spark allows you to simply create an empty conf:</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="nv">sc</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SparkContext</span><span class="o">(</span><span class="k">new</span> <span class="nc">SparkConf</span><span class="o">())</span></code></pre></figure>

<p>Then, you can supply configuration values at runtime:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">./bin/spark-submit <span class="nt">--name</span> <span class="s2">"My app"</span> <span class="nt">--master</span> <span class="nb">local</span><span class="o">[</span>4] <span class="nt">--conf</span> spark.eventLog.enabled<span class="o">=</span><span class="nb">false</span>
  <span class="nt">--conf</span> <span class="s2">"spark.executor.extraJavaOptions=-XX:+PrintGCDetails -XX:+PrintGCTimeStamps"</span> myApp.jar</code></pre></figure>

<p>The Spark shell and <a href="submitting-applications.html"><code class="language-plaintext highlighter-rouge">spark-submit</code></a>
tool support two ways to load configurations dynamically. The first is command line options,
such as <code class="language-plaintext highlighter-rouge">--master</code>, as shown above. <code class="language-plaintext highlighter-rouge">spark-submit</code> can accept any Spark property using the <code class="language-plaintext highlighter-rouge">--conf/-c</code>
flag, but uses special flags for properties that play a part in launching the Spark application.
Running <code class="language-plaintext highlighter-rouge">./bin/spark-submit --help</code> will show the entire list of these options.</p>

<p><code class="language-plaintext highlighter-rouge">bin/spark-submit</code> will also read configuration options from <code class="language-plaintext highlighter-rouge">conf/spark-defaults.conf</code>, in which
each line consists of a key and a value separated by whitespace. For example:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spark.master            spark://5.6.7.8:7077
spark.executor.memory   4g
spark.eventLog.enabled  true
spark.serializer        org.apache.spark.serializer.KryoSerializer
</code></pre></div></div>

<p>Any values specified as flags or in the properties file will be passed on to the application
and merged with those specified through SparkConf. Properties set directly on the SparkConf
take highest precedence, then flags passed to <code class="language-plaintext highlighter-rouge">spark-submit</code> or <code class="language-plaintext highlighter-rouge">spark-shell</code>, then options
in the <code class="language-plaintext highlighter-rouge">spark-defaults.conf</code> file. A few configuration keys have been renamed since earlier
versions of Spark; in such cases, the older key names are still accepted, but take lower
precedence than any instance of the newer key.</p>

<p>Spark properties mainly can be divided into two kinds: one is related to deploy, like
&#8220;spark.driver.memory&#8221;, &#8220;spark.executor.instances&#8221;, this kind of properties may not be affected when
setting programmatically through <code class="language-plaintext highlighter-rouge">SparkConf</code> in runtime, or the behavior is depending on which
cluster manager and deploy mode you choose, so it would be suggested to set through configuration
file or <code class="language-plaintext highlighter-rouge">spark-submit</code> command line options; another is mainly related to Spark runtime control,
like &#8220;spark.task.maxFailures&#8221;, this kind of properties can be set in either way.</p>

<h2 id="viewing-spark-properties">Viewing Spark Properties</h2>

<p>The application web UI at <code class="language-plaintext highlighter-rouge">http://&lt;driver&gt;:4040</code> lists Spark properties in the &#8220;Environment&#8221; tab.
This is a useful place to check to make sure that your properties have been set correctly. Note
that only values explicitly specified through <code class="language-plaintext highlighter-rouge">spark-defaults.conf</code>, <code class="language-plaintext highlighter-rouge">SparkConf</code>, or the command
line will appear. For all other configuration properties, you can assume the default value is used.</p>

<h2 id="available-properties">Available Properties</h2>

<p>Most of the properties that control internal settings have reasonable default values. Some
of the most common options to set are:</p>

<h3 id="application-properties">Application Properties</h3>

<table class="table">
<tr><th>Property Name</th><th>Default</th><th>Meaning</th><th>Since Version</th></tr>
<tr>
  <td><code>spark.app.name</code></td>
  <td>(none)</td>
  <td>
    The name of your application. This will appear in the UI and in log data.
  </td>
  <td>0.9.0</td>
</tr>
<tr>
  <td><code>spark.driver.cores</code></td>
  <td>1</td>
  <td>
    Number of cores to use for the driver process, only in cluster mode.
  </td>
  <td>1.3.0</td>
</tr>
<tr>
  <td><code>spark.driver.maxResultSize</code></td>
  <td>1g</td>
  <td>
    Limit of total size of serialized results of all partitions for each Spark action (e.g. 
    collect) in bytes. Should be at least 1M, or 0 for unlimited. Jobs will be aborted if the total 
    size is above this limit.
    Having a high limit may cause out-of-memory errors in driver (depends on spark.driver.memory
    and memory overhead of objects in JVM). Setting a proper limit can protect the driver from
    out-of-memory errors.
  </td>
  <td>1.2.0</td>
</tr>
<tr>
  <td><code>spark.driver.memory</code></td>
  <td>1g</td>
  <td>
    Amount of memory to use for the driver process, i.e. where SparkContext is initialized, in the
    same format as JVM memory strings with a size unit suffix ("k", "m", "g" or "t")
    (e.g. <code>512m</code>, <code>2g</code>).
    <br />
    <em>Note:</em> In client mode, this config must not be set through the <code>SparkConf</code>
    directly in your application, because the driver JVM has already started at that point.
    Instead, please set this through the <code>--driver-memory</code> command line option
    or in your default properties file.
  </td>
  <td>1.1.1</td>
</tr>
<tr>
  <td><code>spark.driver.memoryOverhead</code></td>
  <td>driverMemory * 0.10, with minimum of 384 </td>
  <td>
    Amount of non-heap memory to be allocated per driver process in cluster mode, in MiB unless
    otherwise specified. This is memory that accounts for things like VM overheads, interned strings,
    other native overheads, etc. This tends to grow with the container size (typically 6-10%). 
    This option is currently supported on YARN, Mesos and Kubernetes.
    <em>Note:</em> Non-heap memory includes off-heap memory 
    (when <code>spark.memory.offHeap.enabled=true</code>) and memory used by other driver processes
    (e.g. python process that goes with a PySpark driver) and memory used by other non-driver 
    processes running in the same container. The maximum memory size of container to running 
    driver is determined by the sum of <code>spark.driver.memoryOverhead</code> 
    and <code>spark.driver.memory</code>.
  </td>
  <td>2.3.0</td>
</tr>
<tr>
 <td><code>spark.driver.resource.{resourceName}.amount</code></td>
  <td>0</td>
  <td>
    Amount of a particular resource type to use on the driver.
    If this is used, you must also specify the
    <code>spark.driver.resource.{resourceName}.discoveryScript</code>
    for the driver to find the resource on startup.
  </td>
  <td>3.0.0</td>
</tr>
<tr>
 <td><code>spark.driver.resource.{resourceName}.discoveryScript</code></td>
  <td>None</td>
  <td>
    A script for the driver to run to discover a particular resource type. This should
    write to STDOUT a JSON string in the format of the ResourceInformation class. This has a
    name and an array of addresses. For a client-submitted driver, discovery script must assign
    different resource addresses to this driver comparing to other drivers on the same host.
  </td>
  <td>3.0.0</td>
</tr>
<tr>
 <td><code>spark.driver.resource.{resourceName}.vendor</code></td>
  <td>None</td>
  <td>
    Vendor of the resources to use for the driver. This option is currently
    only supported on Kubernetes and is actually both the vendor and domain following
    the Kubernetes device plugin naming convention. (e.g. For GPUs on Kubernetes
    this config would be set to nvidia.com or amd.com)
  </td>
  <td>3.0.0</td>
</tr>
<tr>
 <td><code>spark.resources.discoveryPlugin</code></td>
  <td>org.apache.spark.resource.ResourceDiscoveryScriptPlugin</td>
  <td>
    Comma-separated list of class names implementing
    org.apache.spark.api.resource.ResourceDiscoveryPlugin to load into the application.
    This is for advanced users to replace the resource discovery class with a
    custom implementation. Spark will try each class specified until one of them
    returns the resource information for that resource. It tries the discovery
    script last if none of the plugins return information for that resource.
  </td>
  <td>3.0.0</td>
</tr>
<tr>
  <td><code>spark.executor.memory</code></td>
  <td>1g</td>
  <td>
    Amount of memory to use per executor process, in the same format as JVM memory strings with
    a size unit suffix ("k", "m", "g" or "t") (e.g. <code>512m</code>, <code>2g</code>).
  </td>
  <td>0.7.0</td>
</tr>
<tr>
 <td><code>spark.executor.pyspark.memory</code></td>
  <td>Not set</td>
  <td>
    The amount of memory to be allocated to PySpark in each executor, in MiB
    unless otherwise specified.  If set, PySpark memory for an executor will be
    limited to this amount. If not set, Spark will not limit Python's memory use
    and it is up to the application to avoid exceeding the overhead memory space
    shared with other non-JVM processes. When PySpark is run in YARN or Kubernetes, this memory
    is added to executor resource requests.
    <br />
    <em>Note:</em> This feature is dependent on Python's `resource` module; therefore, the behaviors and 
    limitations are inherited. For instance, Windows does not support resource limiting and actual 
    resource is not limited on MacOS.
  </td>
  <td>2.4.0</td>
</tr>
<tr>
 <td><code>spark.executor.memoryOverhead</code></td>
  <td>executorMemory * 0.10, with minimum of 384 </td>
  <td>
    Amount of additional memory to be allocated per executor process, in MiB unless otherwise specified.
    This is memory that accounts for things like VM overheads, interned strings, other native overheads, etc.
    This tends to grow with the executor size (typically 6-10%). This option is currently supported on YARN and Kubernetes.
    <br />
    <em>Note:</em> Additional memory includes PySpark executor memory 
    (when <code>spark.executor.pyspark.memory</code> is not configured) and memory used by other
    non-executor processes running in the same container. The maximum memory size of container to 
    running executor is determined by the sum of <code>spark.executor.memoryOverhead</code>, 
    <code>spark.executor.memory</code>, <code>spark.memory.offHeap.size</code> and 
    <code>spark.executor.pyspark.memory</code>.
  </td>
  <td>2.3.0</td>
</tr>
<tr>
 <td><code>spark.executor.resource.{resourceName}.amount</code></td>
  <td>0</td>
  <td>
    Amount of a particular resource type to use per executor process.
    If this is used, you must also specify the
    <code>spark.executor.resource.{resourceName}.discoveryScript</code>
    for the executor to find the resource on startup.
  </td>
  <td>3.0.0</td>
</tr>
<tr>
 <td><code>spark.executor.resource.{resourceName}.discoveryScript</code></td>
  <td>None</td>
  <td>
    A script for the executor to run to discover a particular resource type. This should
    write to STDOUT a JSON string in the format of the ResourceInformation class. This has a
    name and an array of addresses.
  </td>
  <td>3.0.0</td>
</tr>
<tr>
 <td><code>spark.executor.resource.{resourceName}.vendor</code></td>
  <td>None</td>
  <td>
    Vendor of the resources to use for the executors. This option is currently
    only supported on Kubernetes and is actually both the vendor and domain following
    the Kubernetes device plugin naming convention. (e.g. For GPUs on Kubernetes
    this config would be set to nvidia.com or amd.com)
  </td>
  <td>3.0.0</td>
</tr>
<tr>
  <td><code>spark.extraListeners</code></td>
  <td>(none)</td>
  <td>
    A comma-separated list of classes that implement <code>SparkListener</code>; when initializing
    SparkContext, instances of these classes will be created and registered with Spark's listener
    bus.  If a class has a single-argument constructor that accepts a SparkConf, that constructor
    will be called; otherwise, a zero-argument constructor will be called. If no valid constructor
    can be found, the SparkContext creation will fail with an exception.
  </td>
  <td>1.3.0</td>
</tr>
<tr>
  <td><code>spark.local.dir</code></td>
  <td>/tmp</td>
  <td>
    Directory to use for "scratch" space in Spark, including map output files and RDDs that get
    stored on disk. This should be on a fast, local disk in your system. It can also be a
    comma-separated list of multiple directories on different disks.

    <br />
    <em>Note:</em> This will be overridden by SPARK_LOCAL_DIRS (Standalone), MESOS_SANDBOX (Mesos) or
    LOCAL_DIRS (YARN) environment variables set by the cluster manager.
  </td>
  <td>0.5.0</td>
</tr>
<tr>
  <td><code>spark.logConf</code></td>
  <td>false</td>
  <td>
    Logs the effective SparkConf as INFO when a SparkContext is started.
  </td>
  <td>0.9.0</td>
</tr>
<tr>
  <td><code>spark.master</code></td>
  <td>(none)</td>
  <td>
    The cluster manager to connect to. See the list of
    <a href="submitting-applications.html#master-urls"> allowed master URL's</a>.
  </td>
  <td>0.9.0</td>
</tr>
<tr>
  <td><code>spark.submit.deployMode</code></td>
  <td>(none)</td>
  <td>
    The deploy mode of Spark driver program, either "client" or "cluster",
    Which means to launch driver program locally ("client")
    or remotely ("cluster") on one of the nodes inside the cluster.
  </td>
  <td>1.5.0</td>
</tr>
<tr>
  <td><code>spark.log.callerContext</code></td>
  <td>(none)</td>
  <td>
    Application information that will be written into Yarn RM log/HDFS audit log when running on Yarn/HDFS.
    Its length depends on the Hadoop configuration <code>hadoop.caller.context.max.size</code>. It should be concise,
    and typically can have up to 50 characters.
  </td>
  <td>2.2.0</td>
</tr>
<tr>
  <td><code>spark.driver.supervise</code></td>
  <td>false</td>
  <td>
    If true, restarts the driver automatically if it fails with a non-zero exit status.
    Only has effect in Spark standalone mode or Mesos cluster deploy mode.
  </td>
  <td>1.3.0</td>
</tr>
<tr>
  <td><code>spark.driver.log.dfsDir</code></td>
  <td>(none)</td>
  <td>
    Base directory in which Spark driver logs are synced, if <code>spark.driver.log.persistToDfs.enabled</code>
    is true. Within this base directory, each application logs the driver logs to an application specific file.
    Users may want to set this to a unified location like an HDFS directory so driver log files can be persisted
    for later usage. This directory should allow any Spark user to read/write files and the Spark History Server
    user to delete files. Additionally, older logs from this directory are cleaned by the
    <a href="monitoring.html#spark-history-server-configuration-options">Spark History Server</a> if
    <code>spark.history.fs.driverlog.cleaner.enabled</code> is true and, if they are older than max age configured
    by setting <code>spark.history.fs.driverlog.cleaner.maxAge</code>.
  </td>
  <td>3.0.0</td>
</tr>
<tr>
  <td><code>spark.driver.log.persistToDfs.enabled</code></td>
  <td>false</td>
  <td>
    If true, spark application running in client mode will write driver logs to a persistent storage, configured
    in <code>spark.driver.log.dfsDir</code>. If <code>spark.driver.log.dfsDir</code> is not configured, driver logs
    will not be persisted. Additionally, enable the cleaner by setting <code>spark.history.fs.driverlog.cleaner.enabled</code>
    to true in <a href="monitoring.html#spark-history-server-configuration-options">Spark History Server</a>.
  </td>
  <td>3.0.0</td>
</tr>
<tr>
  <td><code>spark.driver.log.layout</code></td>
  <td>%d{yy/MM/dd HH:mm:ss.SSS} %t %p %c{1}: %m%n</td>
  <td>
    The layout for the driver logs that are synced to <code>spark.driver.log.dfsDir</code>. If this is not configured,
    it uses the layout for the first appender defined in log4j.properties. If that is also not configured, driver logs
    use the default layout.
  </td>
  <td>3.0.0</td>
</tr>
<tr>
  <td><code>spark.driver.log.allowErasureCoding</code></td>
  <td>false</td>
  <td>
    Whether to allow driver logs to use erasure coding.  On HDFS, erasure coded files will not
    update as quickly as regular replicated files, so they make take longer to reflect changes
    written by the application. Note that even if this is true, Spark will still not force the
    file to use erasure coding, it will simply use file system defaults.
  </td>
  <td>3.0.0</td>
</tr>
</table>

<p>Apart from these, the following properties are also available, and may be useful in some situations:</p>

<h3 id="runtime-environment">Runtime Environment</h3>

<table class="table">
<tr><th>Property Name</th><th>Default</th><th>Meaning</th><th>Since Version</th></tr>
<tr>
  <td><code>spark.driver.extraClassPath</code></td>
  <td>(none)</td>
  <td>
    Extra classpath entries to prepend to the classpath of the driver.

    <br /><em>Note:</em> In client mode, this config must not be set through the <code>SparkConf</code>
    directly in your application, because the driver JVM has already started at that point.
    Instead, please set this through the <code>--driver-class-path</code> command line option or in
    your default properties file.
  </td>
  <td>1.0.0</td>
</tr>
<tr>
  <td><code>spark.driver.defaultJavaOptions</code></td>
  <td>(none)</td>
  <td>
    A string of default JVM options to prepend to <code>spark.driver.extraJavaOptions</code>.
    This is intended to be set by administrators.

    For instance, GC settings or other logging.
    Note that it is illegal to set maximum heap size (-Xmx) settings with this option. Maximum heap
    size settings can be set with <code>spark.driver.memory</code> in the cluster mode and through
    the <code>--driver-memory</code> command line option in the client mode.

    <br /><em>Note:</em> In client mode, this config must not be set through the <code>SparkConf</code>
    directly in your application, because the driver JVM has already started at that point.
    Instead, please set this through the <code>--driver-java-options</code> command line option or in
    your default properties file.
  </td>
  <td>3.0.0</td>
</tr>
<tr>
  <td><code>spark.driver.extraJavaOptions</code></td>
  <td>(none)</td>
  <td>
    A string of extra JVM options to pass to the driver. This is intended to be set by users.

    For instance, GC settings or other logging.
    Note that it is illegal to set maximum heap size (-Xmx) settings with this option. Maximum heap
    size settings can be set with <code>spark.driver.memory</code> in the cluster mode and through
    the <code>--driver-memory</code> command line option in the client mode.

    <br /><em>Note:</em> In client mode, this config must not be set through the <code>SparkConf</code>
    directly in your application, because the driver JVM has already started at that point.
    Instead, please set this through the <code>--driver-java-options</code> command line option or in
    your default properties file.

    <code>spark.driver.defaultJavaOptions</code> will be prepended to this configuration.
  </td>
  <td>1.0.0</td>
</tr>
<tr>
  <td><code>spark.driver.extraLibraryPath</code></td>
  <td>(none)</td>
  <td>
    Set a special library path to use when launching the driver JVM.

    <br /><em>Note:</em> In client mode, this config must not be set through the <code>SparkConf</code>
    directly in your application, because the driver JVM has already started at that point.
    Instead, please set this through the <code>--driver-library-path</code> command line option or in
    your default properties file.
  </td>
  <td>1.0.0</td>
</tr>
<tr>
  <td><code>spark.driver.userClassPathFirst</code></td>
  <td>false</td>
  <td>
    (Experimental) Whether to give user-added jars precedence over Spark's own jars when loading
    classes in the driver. This feature can be used to mitigate conflicts between Spark's
    dependencies and user dependencies. It is currently an experimental feature.

    This is used in cluster mode only.
  </td>
  <td>1.3.0</td>
</tr>
<tr>
  <td><code>spark.executor.extraClassPath</code></td>
  <td>(none)</td>
  <td>
    Extra classpath entries to prepend to the classpath of executors. This exists primarily for
    backwards-compatibility with older versions of Spark. Users typically should not need to set
    this option.
  </td>
  <td>1.0.0</td>
</tr>
<tr>
  <td><code>spark.executor.defaultJavaOptions</code></td>
  <td>(none)</td>
  <td>
    A string of default JVM options to prepend to <code>spark.executor.extraJavaOptions</code>.
    This is intended to be set by administrators.

    For instance, GC settings or other logging.
    Note that it is illegal to set Spark properties or maximum heap size (-Xmx) settings with this
    option. Spark properties should be set using a SparkConf object or the spark-defaults.conf file
    used with the spark-submit script. Maximum heap size settings can be set with spark.executor.memory.

    The following symbols, if present will be interpolated:  will be replaced by
    application ID and  will be replaced by executor ID. For example, to enable
    verbose gc logging to a file named for the executor ID of the app in /tmp, pass a 'value' of:
    <code>-verbose:gc -Xloggc:/tmp/-.gc</code>
  </td>
  <td>3.0.0</td>
</tr>
<tr>
  <td><code>spark.executor.extraJavaOptions</code></td>
  <td>(none)</td>
  <td>
    A string of extra JVM options to pass to executors. This is intended to be set by users.

    For instance, GC settings or other logging.
    Note that it is illegal to set Spark properties or maximum heap size (-Xmx) settings with this
    option. Spark properties should be set using a SparkConf object or the spark-defaults.conf file
    used with the spark-submit script. Maximum heap size settings can be set with spark.executor.memory.

    The following symbols, if present will be interpolated:  will be replaced by
    application ID and  will be replaced by executor ID. For example, to enable
    verbose gc logging to a file named for the executor ID of the app in /tmp, pass a 'value' of:
    <code>-verbose:gc -Xloggc:/tmp/-.gc</code>

    <code>spark.executor.defaultJavaOptions</code> will be prepended to this configuration.
  </td>
  <td>1.0.0</td>
</tr>
<tr>
  <td><code>spark.executor.extraLibraryPath</code></td>
  <td>(none)</td>
  <td>
    Set a special library path to use when launching executor JVM's.
  </td>
  <td>1.0.0</td>
</tr>
<tr>
  <td><code>spark.executor.logs.rolling.maxRetainedFiles</code></td>
  <td>(none)</td>
  <td>
    Sets the number of latest rolling log files that are going to be retained by the system.
    Older log files will be deleted. Disabled by default.
  </td>
  <td>1.1.0</td>
</tr>
<tr>
  <td><code>spark.executor.logs.rolling.enableCompression</code></td>
  <td>false</td>
  <td>
    Enable executor log compression. If it is enabled, the rolled executor logs will be compressed.
    Disabled by default.
  </td>
  <td>2.0.2</td>
</tr>
<tr>
  <td><code>spark.executor.logs.rolling.maxSize</code></td>
  <td>(none)</td>
  <td>
    Set the max size of the file in bytes by which the executor logs will be rolled over.
    Rolling is disabled by default. See <code>spark.executor.logs.rolling.maxRetainedFiles</code>
    for automatic cleaning of old logs.
  </td>
  <td>1.4.0</td>
</tr>
<tr>
  <td><code>spark.executor.logs.rolling.strategy</code></td>
  <td>(none)</td>
  <td>
    Set the strategy of rolling of executor logs. By default it is disabled. It can
    be set to "time" (time-based rolling) or "size" (size-based rolling). For "time",
    use <code>spark.executor.logs.rolling.time.interval</code> to set the rolling interval.
    For "size", use <code>spark.executor.logs.rolling.maxSize</code> to set
    the maximum file size for rolling.
  </td>
  <td>1.1.0</td>
</tr>
<tr>
  <td><code>spark.executor.logs.rolling.time.interval</code></td>
  <td>daily</td>
  <td>
    Set the time interval by which the executor logs will be rolled over.
    Rolling is disabled by default. Valid values are <code>daily</code>, <code>hourly</code>, <code>minutely</code> or
    any interval in seconds. See <code>spark.executor.logs.rolling.maxRetainedFiles</code>
    for automatic cleaning of old logs.
  </td>
  <td>1.1.0</td>
</tr>
<tr>
  <td><code>spark.executor.userClassPathFirst</code></td>
  <td>false</td>
  <td>
    (Experimental) Same functionality as <code>spark.driver.userClassPathFirst</code>, but
    applied to executor instances.
  </td>
  <td>1.3.0</td>
</tr>
<tr>
  <td><code>spark.executorEnv.[EnvironmentVariableName]</code></td>
  <td>(none)</td>
  <td>
    Add the environment variable specified by <code>EnvironmentVariableName</code> to the Executor
    process. The user can specify multiple of these to set multiple environment variables.
  </td>
  <td>0.9.0</td>
</tr>
<tr>
  <td><code>spark.redaction.regex</code></td>
  <td>(?i)secret|password|token</td>
  <td>
    Regex to decide which Spark configuration properties and environment variables in driver and
    executor environments contain sensitive information. When this regex matches a property key or
    value, the value is redacted from the environment UI and various logs like YARN and event logs.
  </td>
  <td>2.1.2</td>
</tr>
<tr>
  <td><code>spark.python.profile</code></td>
  <td>false</td>
  <td>
    Enable profiling in Python worker, the profile result will show up by <code>sc.show_profiles()</code>,
    or it will be displayed before the driver exits. It also can be dumped into disk by
    <code>sc.dump_profiles(path)</code>. If some of the profile results had been displayed manually,
    they will not be displayed automatically before driver exiting.

    By default the <code>pyspark.profiler.BasicProfiler</code> will be used, but this can be overridden by
    passing a profiler class in as a parameter to the <code>SparkContext</code> constructor.
  </td>
  <td>1.2.0</td>
</tr>
<tr>
  <td><code>spark.python.profile.dump</code></td>
  <td>(none)</td>
  <td>
    The directory which is used to dump the profile result before driver exiting.
    The results will be dumped as separated file for each RDD. They can be loaded
    by <code>pstats.Stats()</code>. If this is specified, the profile result will not be displayed
    automatically.
  </td>
  <td>1.2.0</td>
</tr>
<tr>
  <td><code>spark.python.worker.memory</code></td>
  <td>512m</td>
  <td>
    Amount of memory to use per python worker process during aggregation, in the same
    format as JVM memory strings with a size unit suffix ("k", "m", "g" or "t")
    (e.g. <code>512m</code>, <code>2g</code>).
    If the memory used during aggregation goes above this amount, it will spill the data into disks.
  </td>
  <td>1.1.0</td>
</tr>
<tr>
  <td><code>spark.python.worker.reuse</code></td>
  <td>true</td>
  <td>
    Reuse Python worker or not. If yes, it will use a fixed number of Python workers,
    does not need to fork() a Python process for every task. It will be very useful
    if there is a large broadcast, then the broadcast will not need to be transferred
    from JVM to Python worker for every task.
  </td>
  <td>1.2.0</td>
</tr>
<tr>
  <td><code>spark.files</code></td>
  <td></td>
  <td>
    Comma-separated list of files to be placed in the working directory of each executor. Globs are allowed.
  </td>
  <td>1.0.0</td>
</tr>
<tr>
  <td><code>spark.submit.pyFiles</code></td>
  <td></td>
  <td>
    Comma-separated list of .zip, .egg, or .py files to place on the PYTHONPATH for Python apps. Globs are allowed.
  </td>
  <td>1.0.1</td>
</tr>
<tr>
  <td><code>spark.jars</code></td>
  <td></td>
  <td>
    Comma-separated list of jars to include on the driver and executor classpaths. Globs are allowed.
  </td>
  <td>0.9.0</td>
</tr>
<tr>
  <td><code>spark.jars.packages</code></td>
  <td></td>
  <td>
    Comma-separated list of Maven coordinates of jars to include on the driver and executor
    classpaths. The coordinates should be groupId:artifactId:version. If <code>spark.jars.ivySettings</code>
    is given artifacts will be resolved according to the configuration in the file, otherwise artifacts
    will be searched for in the local maven repo, then maven central and finally any additional remote
    repositories given by the command-line option <code>--repositories</code>. For more details, see
    <a href="submitting-applications.html#advanced-dependency-management">Advanced Dependency Management</a>.
  </td>
  <td>1.5.0</td>
</tr>
<tr>
  <td><code>spark.jars.excludes</code></td>
  <td></td>
  <td>
    Comma-separated list of groupId:artifactId, to exclude while resolving the dependencies
    provided in <code>spark.jars.packages</code> to avoid dependency conflicts.
  </td>
  <td>1.5.0</td>
</tr>
<tr>
  <td><code>spark.jars.ivy</code></td>
  <td></td>
  <td>
    Path to specify the Ivy user directory, used for the local Ivy cache and package files from
    <code>spark.jars.packages</code>. This will override the Ivy property <code>ivy.default.ivy.user.dir</code>
    which defaults to ~/.ivy2.
  </td>
  <td>1.3.0</td>
</tr>
<tr>
  <td><code>spark.jars.ivySettings</code></td>
  <td></td>
  <td>
    Path to an Ivy settings file to customize resolution of jars specified using <code>spark.jars.packages</code>
    instead of the built-in defaults, such as maven central. Additional repositories given by the command-line
    option <code>--repositories</code> or <code>spark.jars.repositories</code> will also be included.
    Useful for allowing Spark to resolve artifacts from behind a firewall e.g. via an in-house
    artifact server like Artifactory. Details on the settings file format can be
    found at <a href="http://ant.apache.org/ivy/history/latest-milestone/settings.html">Settings Files</a>
  </td>
  <td>2.2.0</td>
</tr>
 <tr>
  <td><code>spark.jars.repositories</code></td>
  <td></td>
  <td>
    Comma-separated list of additional remote repositories to search for the maven coordinates
    given with <code>--packages</code> or <code>spark.jars.packages</code>.
  </td>
  <td>2.3.0</td>
</tr>
<tr>
  <td><code>spark.archives</code></td>
  <td></td>
  <td>
    Comma-separated list of archives to be extracted into the working directory of each executor.
    .jar, .tar.gz, .tgz and .zip are supported. You can specify the directory name to unpack via
    adding <code>#</code> after the file name to unpack, for example, <code>file.zip#directory</code>.
    This configuration is experimental.
  </td>
  <td>3.1.0</td>
</tr>
<tr>
  <td><code>spark.pyspark.driver.python</code></td>
  <td></td>
  <td>
    Python binary executable to use for PySpark in driver.
    (default is <code>spark.pyspark.python</code>)
  </td>
  <td>2.1.0</td>
</tr>
<tr>
  <td><code>spark.pyspark.python</code></td>
  <td></td>
  <td>
    Python binary executable to use for PySpark in both driver and executors.
  </td>
  <td>2.1.0</td>
</tr>
</table>

<h3 id="shuffle-behavior">Shuffle Behavior</h3>

<table class="table">
<tr><th>Property Name</th><th>Default</th><th>Meaning</th><th>Since Version</th></tr>
<tr>
  <td><code>spark.reducer.maxSizeInFlight</code></td>
  <td>48m</td>
  <td>
    Maximum size of map outputs to fetch simultaneously from each reduce task, in MiB unless 
    otherwise specified. Since each output requires us to create a buffer to receive it, this 
    represents a fixed memory overhead per reduce task, so keep it small unless you have a
    large amount of memory.
  </td>
  <td>1.4.0</td>
</tr>
<tr>
  <td><code>spark.reducer.maxReqsInFlight</code></td>
  <td>Int.MaxValue</td>
  <td>
    This configuration limits the number of remote requests to fetch blocks at any given point.
    When the number of hosts in the cluster increase, it might lead to very large number
    of inbound connections to one or more nodes, causing the workers to fail under load.
    By allowing it to limit the number of fetch requests, this scenario can be mitigated.
  </td>
  <td>2.0.0</td>
</tr>
<tr>
  <td><code>spark.reducer.maxBlocksInFlightPerAddress</code></td>
  <td>Int.MaxValue</td>
  <td>
    This configuration limits the number of remote blocks being fetched per reduce task from a
    given host port. When a large number of blocks are being requested from a given address in a
    single fetch or simultaneously, this could crash the serving executor or Node Manager. This
    is especially useful to reduce the load on the Node Manager when external shuffle is enabled.
    You can mitigate this issue by setting it to a lower value.
  </td>
  <td>2.2.1</td>
</tr>
<tr>
  <td><code>spark.shuffle.compress</code></td>
  <td>true</td>
  <td>
    Whether to compress map output files. Generally a good idea. Compression will use
    <code>spark.io.compression.codec</code>.
  </td>
  <td>0.6.0</td>
</tr>
<tr>
  <td><code>spark.shuffle.file.buffer</code></td>
  <td>32k</td>
  <td>
    Size of the in-memory buffer for each shuffle file output stream, in KiB unless otherwise 
    specified. These buffers reduce the number of disk seeks and system calls made in creating 
    intermediate shuffle files.
  </td>
  <td>1.4.0</td>
</tr>
<tr>
  <td><code>spark.shuffle.io.maxRetries</code></td>
  <td>3</td>
  <td>
    (Netty only) Fetches that fail due to IO-related exceptions are automatically retried if this is
    set to a non-zero value. This retry logic helps stabilize large shuffles in the face of long GC
    pauses or transient network connectivity issues.
  </td>
  <td>1.2.0</td>
</tr>
<tr>
  <td><code>spark.shuffle.io.numConnectionsPerPeer</code></td>
  <td>1</td>
  <td>
    (Netty only) Connections between hosts are reused in order to reduce connection buildup for
    large clusters. For clusters with many hard disks and few hosts, this may result in insufficient
    concurrency to saturate all disks, and so users may consider increasing this value.
  </td>
  <td>1.2.1</td>
</tr>
<tr>
  <td><code>spark.shuffle.io.preferDirectBufs</code></td>
  <td>true</td>
  <td>
    (Netty only) Off-heap buffers are used to reduce garbage collection during shuffle and cache
    block transfer. For environments where off-heap memory is tightly limited, users may wish to
    turn this off to force all allocations from Netty to be on-heap.
  </td>
  <td>1.2.0</td>
</tr>
<tr>
  <td><code>spark.shuffle.io.retryWait</code></td>
  <td>5s</td>
  <td>
    (Netty only) How long to wait between retries of fetches. The maximum delay caused by retrying
    is 15 seconds by default, calculated as <code>maxRetries * retryWait</code>.
  </td>
  <td>1.2.1</td>
</tr>
<tr>
  <td><code>spark.shuffle.io.backLog</code></td>
  <td>-1</td>
  <td>
    Length of the accept queue for the shuffle service. For large applications, this value may
    need to be increased, so that incoming connections are not dropped if the service cannot keep
    up with a large number of connections arriving in a short period of time. This needs to
    be configured wherever the shuffle service itself is running, which may be outside of the
    application (see <code>spark.shuffle.service.enabled</code> option below). If set below 1,
    will fallback to OS default defined by Netty's <code>io.netty.util.NetUtil#SOMAXCONN</code>.
  </td>
  <td>1.1.1</td>
</tr>
<tr>
  <td><code>spark.shuffle.service.enabled</code></td>
  <td>false</td>
  <td>
    Enables the external shuffle service. This service preserves the shuffle files written by
    executors so the executors can be safely removed. The external shuffle service
    must be set up in order to enable it. See
    <a href="job-scheduling.html#configuration-and-setup">dynamic allocation
    configuration and setup documentation</a> for more information.
  </td>
  <td>1.2.0</td>
</tr>
<tr>
  <td><code>spark.shuffle.service.port</code></td>
  <td>7337</td>
  <td>
    Port on which the external shuffle service will run.
  </td>
  <td>1.2.0</td>
</tr>
<tr>
  <td><code>spark.shuffle.service.index.cache.size</code></td>
  <td>100m</td>
  <td>
    Cache entries limited to the specified memory footprint, in bytes unless otherwise specified.
  </td>
  <td>2.3.0</td>
</tr>
<tr>
  <td><code>spark.shuffle.maxChunksBeingTransferred</code></td>
  <td>Long.MAX_VALUE</td>
  <td>
    The max number of chunks allowed to be transferred at the same time on shuffle service.
    Note that new incoming connections will be closed when the max number is hit. The client will
    retry according to the shuffle retry configs (see <code>spark.shuffle.io.maxRetries</code> and
    <code>spark.shuffle.io.retryWait</code>), if those limits are reached the task will fail with
    fetch failure.
  </td>
  <td>2.3.0</td>
</tr>
<tr>
  <td><code>spark.shuffle.sort.bypassMergeThreshold</code></td>
  <td>200</td>
  <td>
    (Advanced) In the sort-based shuffle manager, avoid merge-sorting data if there is no
    map-side aggregation and there are at most this many reduce partitions.
  </td>
  <td>1.1.1</td>
</tr>
<tr>
  <td><code>spark.shuffle.spill.compress</code></td>
  <td>true</td>
  <td>
    Whether to compress data spilled during shuffles. Compression will use
    <code>spark.io.compression.codec</code>.
  </td>
  <td>0.9.0</td>
</tr>
<tr>
  <td><code>spark.shuffle.accurateBlockThreshold</code></td>
  <td>100 * 1024 * 1024</td>
  <td>
    Threshold in bytes above which the size of shuffle blocks in HighlyCompressedMapStatus is 
    accurately recorded. This helps to prevent OOM by avoiding underestimating shuffle 
    block size when fetch shuffle blocks.
  </td>
  <td>2.2.1</td>
</tr>
<tr>
  <td><code>spark.shuffle.registration.timeout</code></td>
  <td>5000</td>
  <td>
    Timeout in milliseconds for registration to the external shuffle service.
  </td>
  <td>2.3.0</td>
</tr>
<tr>
  <td><code>spark.shuffle.registration.maxAttempts</code></td>
  <td>3</td>
  <td>
    When we fail to register to the external shuffle service, we will retry for maxAttempts times.
  </td>
  <td>2.3.0</td>
</tr>
</table>

<h3 id="spark-ui">Spark UI</h3>

<table class="table">
<tr><th>Property Name</th><th>Default</th><th>Meaning</th><th>Since Version</th></tr>
<tr>
  <td><code>spark.eventLog.logBlockUpdates.enabled</code></td>
  <td>false</td>
  <td>
    Whether to log events for every block update, if <code>spark.eventLog.enabled</code> is true.
    *Warning*: This will increase the size of the event log considerably.
  </td>
  <td>2.3.0</td>
</tr>
<tr>
  <td><code>spark.eventLog.longForm.enabled</code></td>
  <td>false</td>
  <td>
    If true, use the long form of call sites in the event log. Otherwise use the short form.
  </td>
  <td>2.4.0</td>
</tr>
<tr>
  <td><code>spark.eventLog.compress</code></td>
  <td>false</td>
  <td>
    Whether to compress logged events, if <code>spark.eventLog.enabled</code> is true.
  </td>
  <td>1.0.0</td>
</tr>
<tr>
  <td><code>spark.eventLog.compression.codec</code></td>
  <td></td>
  <td>
    The codec to compress logged events. If this is not given,
    <code>spark.io.compression.codec</code> will be used.
  </td>
  <td>3.0.0</td>
</tr>
<tr>
  <td><code>spark.eventLog.erasureCoding.enabled</code></td>
  <td>false</td>
  <td>
    Whether to allow event logs to use erasure coding, or turn erasure coding off, regardless of
    filesystem defaults.  On HDFS, erasure coded files will not update as quickly as regular
    replicated files, so the application updates will take longer to appear in the History Server.
    Note that even if this is true, Spark will still not force the file to use erasure coding, it
    will simply use filesystem defaults.
  </td>
  <td>3.0.0</td>
</tr>
<tr>
  <td><code>spark.eventLog.dir</code></td>
  <td>file:///tmp/spark-events</td>
  <td>
    Base directory in which Spark events are logged, if <code>spark.eventLog.enabled</code> is true.
    Within this base directory, Spark creates a sub-directory for each application, and logs the
    events specific to the application in this directory. Users may want to set this to
    a unified location like an HDFS directory so history files can be read by the history server.
  </td>
  <td>1.0.0</td>
</tr>
<tr>
  <td><code>spark.eventLog.enabled</code></td>
  <td>false</td>
  <td>
    Whether to log Spark events, useful for reconstructing the Web UI after the application has
    finished.
  </td>
  <td>1.0.0</td>
</tr>
<tr>
  <td><code>spark.eventLog.overwrite</code></td>
  <td>false</td>
  <td>
    Whether to overwrite any existing files.
  </td>
  <td>1.0.0</td>
</tr>
<tr>
  <td><code>spark.eventLog.buffer.kb</code></td>
  <td>100k</td>
  <td>
    Buffer size to use when writing to output streams, in KiB unless otherwise specified.
  </td>
  <td>1.0.0</td>
</tr>
<tr>
  <td><code>spark.eventLog.rolling.enabled</code></td>
  <td>false</td>
  <td>
    Whether rolling over event log files is enabled. If set to true, it cuts down each event
    log file to the configured size.
  </td>
  <td>3.0.0</td>
</tr>
<tr>
  <td><code>spark.eventLog.rolling.maxFileSize</code></td>
  <td>128m</td>
  <td>
    When <code>spark.eventLog.rolling.enabled=true</code>, specifies the max size of event log file before it's rolled over.
  </td>
  <td>3.0.0</td>
</tr>
<tr>
  <td><code>spark.ui.dagGraph.retainedRootRDDs</code></td>
  <td>Int.MaxValue</td>
  <td>
    How many DAG graph nodes the Spark UI and status APIs remember before garbage collecting.
  </td>
  <td>2.1.0</td>
</tr>
<tr>
  <td><code>spark.ui.enabled</code></td>
  <td>true</td>
  <td>
    Whether to run the web UI for the Spark application.
  </td>
  <td>1.1.1</td>
</tr>
<tr>
  <td><code>spark.ui.killEnabled</code></td>
  <td>true</td>
  <td>
    Allows jobs and stages to be killed from the web UI.
  </td>
  <td>1.0.0</td>
</tr>
<tr>
  <td><code>spark.ui.liveUpdate.period</code></td>
  <td>100ms</td>
  <td>
    How often to update live entities. -1 means "never update" when replaying applications,
    meaning only the last write will happen. For live applications, this avoids a few
    operations that we can live without when rapidly processing incoming task events.
  </td>
  <td>2.3.0</td>
</tr>
<tr>
  <td><code>spark.ui.liveUpdate.minFlushPeriod</code></td>
  <td>1s</td>
  <td>
    Minimum time elapsed before stale UI data is flushed. This avoids UI staleness when incoming
    task events are not fired frequently.
  </td>
  <td>2.4.2</td>
</tr>
<tr>
  <td><code>spark.ui.port</code></td>
  <td>4040</td>
  <td>
    Port for your application's dashboard, which shows memory and workload data.
  </td>
  <td>0.7.0</td>
</tr>
<tr>
  <td><code>spark.ui.retainedJobs</code></td>
  <td>1000</td>
  <td>
    How many jobs the Spark UI and status APIs remember before garbage collecting.
    This is a target maximum, and fewer elements may be retained in some circumstances.
  </td>
  <td>1.2.0</td>
</tr>
<tr>
  <td><code>spark.ui.retainedStages</code></td>
  <td>1000</td>
  <td>
    How many stages the Spark UI and status APIs remember before garbage collecting.
    This is a target maximum, and fewer elements may be retained in some circumstances.
  </td>
  <td>0.9.0</td>
</tr>
<tr>
  <td><code>spark.ui.retainedTasks</code></td>
  <td>100000</td>
  <td>
    How many tasks in one stage the Spark UI and status APIs remember before garbage collecting.
    This is a target maximum, and fewer elements may be retained in some circumstances.
  </td>
  <td>2.0.1</td>
</tr>
<tr>
  <td><code>spark.ui.reverseProxy</code></td>
  <td>false</td>
  <td>
    Enable running Spark Master as reverse proxy for worker and application UIs. In this mode, Spark master will reverse proxy the worker and application UIs to enable access without requiring direct access to their hosts. Use it with caution, as worker and application UI will not be accessible directly, you will only be able to access them through spark master/proxy public URL. This setting affects all the workers and application UIs running in the cluster and must be set on all the workers, drivers and masters.
  </td>
  <td>2.1.0</td>
</tr>
<tr>
  <td><code>spark.ui.reverseProxyUrl</code></td>
  <td></td>
  <td>
    If the Spark UI should be served through another front-end reverse proxy, this is the URL
    for accessing the Spark master UI through that reverse proxy.
    This is useful when running proxy for authentication e.g. an OAuth proxy. The URL may contain
    a path prefix, like <code>http://mydomain.com/path/to/spark/</code>, allowing you to serve the
    UI for multiple Spark clusters and other web applications through the same virtual host and
    port.
    Normally, this should be an absolute URL including scheme (http/https), host and port.
    It is possible to specify a relative URL starting with "/" here. In this case, all URLs
    generated by the Spark UI and Spark REST APIs will be server-relative links -- this will still
    work, as the entire Spark UI is served through the same host and port.
    <br />The setting affects link generation in the Spark UI, but the front-end reverse proxy
    is responsible for
    <ul>
      <li>stripping a path prefix before forwarding the request,</li>
      <li>rewriting redirects which point directly to the Spark master,</li>
      <li>redirecting access from <code>http://mydomain.com/path/to/spark</code> to
      <code>http://mydomain.com/path/to/spark/</code> (trailing slash after path prefix); otherwise
      relative links on the master page do not work correctly.</li>
    </ul>
    This setting affects all the workers and application UIs running in the cluster and must be set
    identically on all the workers, drivers and masters. In is only effective when
    <code>spark.ui.reverseProxy</code> is turned on. This setting is not needed when the Spark
    master web UI is directly reachable.  </td>
  <td>2.1.0</td>
</tr>
<tr>
  <td><code>spark.ui.proxyRedirectUri</code></td>
  <td></td>
  <td>
    Where to address redirects when Spark is running behind a proxy. This will make Spark
    modify redirect responses so they point to the proxy server, instead of the Spark UI's own
    address. This should be only the address of the server, without any prefix paths for the
    application; the prefix should be set either by the proxy server itself (by adding the
    <code>X-Forwarded-Context</code> request header), or by setting the proxy base in the Spark
    app's configuration.
  </td>
  <td>3.0.0</td>
</tr>
<tr>
  <td><code>spark.ui.showConsoleProgress</code></td>
  <td>false</td>
  <td>
    Show the progress bar in the console. The progress bar shows the progress of stages
    that run for longer than 500ms. If multiple stages run at the same time, multiple
    progress bars will be displayed on the same line.
    <br />
    <em>Note:</em> In shell environment, the default value of spark.ui.showConsoleProgress is true.
  </td>
  <td>1.2.1</td>
</tr>
<tr>
  <td><code>spark.ui.custom.executor.log.url</code></td>
  <td>(none)</td>
  <td>
    Specifies custom spark executor log URL for supporting external log service instead of using cluster
    managers' application log URLs in Spark UI. Spark will support some path variables via patterns
    which can vary on cluster manager. Please check the documentation for your cluster manager to
    see which patterns are supported, if any. <p />
    Please note that this configuration also replaces original log urls in event log,
    which will be also effective when accessing the application on history server. The new log urls must be
    permanent, otherwise you might have dead link for executor log urls.
    <p />
    For now, only YARN mode supports this configuration
  </td>
  <td>3.0.0</td>
</tr>
<tr>
  <td><code>spark.worker.ui.retainedExecutors</code></td>
  <td>1000</td>
  <td>
    How many finished executors the Spark UI and status APIs remember before garbage collecting.
  </td>
  <td>1.5.0</td>
</tr>
<tr>
  <td><code>spark.worker.ui.retainedDrivers</code></td>
  <td>1000</td>
  <td>
    How many finished drivers the Spark UI and status APIs remember before garbage collecting.
  </td>
  <td>1.5.0</td>
</tr>
<tr>
  <td><code>spark.sql.ui.retainedExecutions</code></td>
  <td>1000</td>
  <td>
    How many finished executions the Spark UI and status APIs remember before garbage collecting.
  </td>
  <td>1.5.0</td>
</tr>
<tr>
  <td><code>spark.streaming.ui.retainedBatches</code></td>
  <td>1000</td>
  <td>
    How many finished batches the Spark UI and status APIs remember before garbage collecting.
  </td>
  <td>1.0.0</td>
</tr>
<tr>
  <td><code>spark.ui.retainedDeadExecutors</code></td>
  <td>100</td>
  <td>
    How many dead executors the Spark UI and status APIs remember before garbage collecting.
  </td>
  <td>2.0.0</td>
</tr>
<tr>
  <td><code>spark.ui.filters</code></td>
  <td>None</td>
  <td>
    Comma separated list of filter class names to apply to the Spark Web UI. The filter should be a
    standard <a href="http://docs.oracle.com/javaee/6/api/javax/servlet/Filter.html">
    javax servlet Filter</a>.

    <br />Filter parameters can also be specified in the configuration, by setting config entries
    of the form <code>spark.&lt;class name of filter&gt;.param.&lt;param name&gt;=&lt;value&gt;</code>

    <br />For example:
    <br /><code>spark.ui.filters=com.test.filter1</code>
    <br /><code>spark.com.test.filter1.param.name1=foo</code>
    <br /><code>spark.com.test.filter1.param.name2=bar</code>
  </td>
  <td>1.0.0</td>
</tr>
<tr>
  <td><code>spark.ui.requestHeaderSize</code></td>
  <td>8k</td>
  <td>
    The maximum allowed size for a HTTP request header, in bytes unless otherwise specified.
    This setting applies for the Spark History Server too.
  </td>
  <td>2.2.3</td>
</tr>
</table>

<h3 id="compression-and-serialization">Compression and Serialization</h3>

<table class="table">
<tr><th>Property Name</th><th>Default</th><th>Meaning</th><th>Since Version</th></tr>
<tr>
  <td><code>spark.broadcast.compress</code></td>
  <td>true</td>
  <td>
    Whether to compress broadcast variables before sending them. Generally a good idea.
    Compression will use <code>spark.io.compression.codec</code>.
  </td>
  <td>0.6.0</td>
</tr>
<tr>
  <td><code>spark.checkpoint.compress</code></td>
  <td>false</td>
  <td>
    Whether to compress RDD checkpoints. Generally a good idea.
    Compression will use <code>spark.io.compression.codec</code>.
  </td>
  <td>2.2.0</td>
</tr>
<tr>
  <td><code>spark.io.compression.codec</code></td>
  <td>lz4</td>
  <td>
    The codec used to compress internal data such as RDD partitions, event log, broadcast variables
    and shuffle outputs. By default, Spark provides four codecs: <code>lz4</code>, <code>lzf</code>,
    <code>snappy</code>, and <code>zstd</code>. You can also use fully qualified class names to specify the codec,
    e.g.
    <code>org.apache.spark.io.LZ4CompressionCodec</code>,
    <code>org.apache.spark.io.LZFCompressionCodec</code>,
    <code>org.apache.spark.io.SnappyCompressionCodec</code>,
    and <code>org.apache.spark.io.ZStdCompressionCodec</code>.
  </td>
  <td>0.8.0</td>
</tr>
<tr>
  <td><code>spark.io.compression.lz4.blockSize</code></td>
  <td>32k</td>
  <td>
    Block size used in LZ4 compression, in the case when LZ4 compression codec
    is used. Lowering this block size will also lower shuffle memory usage when LZ4 is used.
    Default unit is bytes, unless otherwise specified.
  </td>
  <td>1.4.0</td>
</tr>
<tr>
  <td><code>spark.io.compression.snappy.blockSize</code></td>
  <td>32k</td>
  <td>
    Block size in Snappy compression, in the case when Snappy compression codec is used. 
    Lowering this block size will also lower shuffle memory usage when Snappy is used.
    Default unit is bytes, unless otherwise specified.
  </td>
  <td>1.4.0</td>
</tr>
<tr>
  <td><code>spark.io.compression.zstd.level</code></td>
  <td>1</td>
  <td>
    Compression level for Zstd compression codec. Increasing the compression level will result in better
    compression at the expense of more CPU and memory.
  </td>
  <td>2.3.0</td>
</tr>
<tr>
  <td><code>spark.io.compression.zstd.bufferSize</code></td>
  <td>32k</td>
  <td>
    Buffer size in bytes used in Zstd compression, in the case when Zstd compression codec
    is used. Lowering this size will lower the shuffle memory usage when Zstd is used, but it
    might increase the compression cost because of excessive JNI call overhead.
  </td>
  <td>2.3.0</td>
</tr>
<tr>
  <td><code>spark.kryo.classesToRegister</code></td>
  <td>(none)</td>
  <td>
    If you use Kryo serialization, give a comma-separated list of custom class names to register
    with Kryo.
    See the <a href="tuning.html#data-serialization">tuning guide</a> for more details.
  </td>
  <td>1.2.0</td>
</tr>
<tr>
  <td><code>spark.kryo.referenceTracking</code></td>
  <td>true</td>
  <td>
    Whether to track references to the same object when serializing data with Kryo, which is
    necessary if your object graphs have loops and useful for efficiency if they contain multiple
    copies of the same object. Can be disabled to improve performance if you know this is not the
    case.
  </td>
  <td>0.8.0</td>
</tr>
<tr>
  <td><code>spark.kryo.registrationRequired</code></td>
  <td>false</td>
  <td>
    Whether to require registration with Kryo. If set to 'true', Kryo will throw an exception
    if an unregistered class is serialized. If set to false (the default), Kryo will write
    unregistered class names along with each object. Writing class names can cause
    significant performance overhead, so enabling this option can enforce strictly that a
    user has not omitted classes from registration.
  </td>
  <td>1.1.0</td>
</tr>
<tr>
  <td><code>spark.kryo.registrator</code></td>
  <td>(none)</td>
  <td>
    If you use Kryo serialization, give a comma-separated list of classes that register your custom classes with Kryo. This
    property is useful if you need to register your classes in a custom way, e.g. to specify a custom
    field serializer. Otherwise <code>spark.kryo.classesToRegister</code> is simpler. It should be
    set to classes that extend
    <a href="api/scala/org/apache/spark/serializer/KryoRegistrator.html">
    <code>KryoRegistrator</code></a>.
    See the <a href="tuning.html#data-serialization">tuning guide</a> for more details.
  </td>
  <td>0.5.0</td>
</tr>
<tr>
  <td><code>spark.kryo.unsafe</code></td>
  <td>false</td>
  <td>
    Whether to use unsafe based Kryo serializer. Can be
    substantially faster by using Unsafe Based IO.
  </td>
  <td>2.1.0</td>
</tr>
<tr>
  <td><code>spark.kryoserializer.buffer.max</code></td>
  <td>64m</td>
  <td>
    Maximum allowable size of Kryo serialization buffer, in MiB unless otherwise specified.
    This must be larger than any object you attempt to serialize and must be less than 2048m.
    Increase this if you get a "buffer limit exceeded" exception inside Kryo.
  </td>
  <td>1.4.0</td>
</tr>
<tr>
  <td><code>spark.kryoserializer.buffer</code></td>
  <td>64k</td>
  <td>
    Initial size of Kryo's serialization buffer, in KiB unless otherwise specified. 
    Note that there will be one buffer <i>per core</i> on each worker. This buffer will grow up to
    <code>spark.kryoserializer.buffer.max</code> if needed.
  </td>
  <td>1.4.0</td>
</tr>
<tr>
  <td><code>spark.rdd.compress</code></td>
  <td>false</td>
  <td>
    Whether to compress serialized RDD partitions (e.g. for
    <code>StorageLevel.MEMORY_ONLY_SER</code> in Java
    and Scala or <code>StorageLevel.MEMORY_ONLY</code> in Python).
    Can save substantial space at the cost of some extra CPU time.
    Compression will use <code>spark.io.compression.codec</code>.
  </td>
  <td>0.6.0</td>
</tr>
<tr>
  <td><code>spark.serializer</code></td>
  <td>
    org.apache.spark.serializer.<br />JavaSerializer
  </td>
  <td>
    Class to use for serializing objects that will be sent over the network or need to be cached
    in serialized form. The default of Java serialization works with any Serializable Java object
    but is quite slow, so we recommend <a href="tuning.html">using
    <code>org.apache.spark.serializer.KryoSerializer</code> and configuring Kryo serialization</a>
    when speed is necessary. Can be any subclass of
    <a href="api/scala/org/apache/spark/serializer/Serializer.html">
    <code>org.apache.spark.Serializer</code></a>.
  </td>
  <td>0.5.0</td>
</tr>
<tr>
  <td><code>spark.serializer.objectStreamReset</code></td>
  <td>100</td>
  <td>
    When serializing using org.apache.spark.serializer.JavaSerializer, the serializer caches
    objects to prevent writing redundant data, however that stops garbage collection of those
    objects. By calling 'reset' you flush that info from the serializer, and allow old
    objects to be collected. To turn off this periodic reset set it to -1.
    By default it will reset the serializer every 100 objects.
  </td>
  <td>1.0.0</td>
</tr>
</table>

<h3 id="memory-management">Memory Management</h3>

<table class="table">
<tr><th>Property Name</th><th>Default</th><th>Meaning</th><th>Since Version</th></tr>
<tr>
  <td><code>spark.memory.fraction</code></td>
  <td>0.6</td>
  <td>
    Fraction of (heap space - 300MB) used for execution and storage. The lower this is, the
    more frequently spills and cached data eviction occur. The purpose of this config is to set
    aside memory for internal metadata, user data structures, and imprecise size estimation
    in the case of sparse, unusually large records. Leaving this at the default value is
    recommended. For more detail, including important information about correctly tuning JVM
    garbage collection when increasing this value, see
    <a href="tuning.html#memory-management-overview">this description</a>.
  </td>
  <td>1.6.0</td>
</tr>
<tr>
  <td><code>spark.memory.storageFraction</code></td>
  <td>0.5</td>
  <td>
    Amount of storage memory immune to eviction, expressed as a fraction of the size of the
    region set aside by <code>spark.memory.fraction</code>. The higher this is, the less
    working memory may be available to execution and tasks may spill to disk more often.
    Leaving this at the default value is recommended. For more detail, see
    <a href="tuning.html#memory-management-overview">this description</a>.
  </td>
  <td>1.6.0</td>
</tr>
<tr>
  <td><code>spark.memory.offHeap.enabled</code></td>
  <td>false</td>
  <td>
    If true, Spark will attempt to use off-heap memory for certain operations. If off-heap memory 
    use is enabled, then <code>spark.memory.offHeap.size</code> must be positive.
  </td>
  <td>1.6.0</td>
</tr>
<tr>
  <td><code>spark.memory.offHeap.size</code></td>
  <td>0</td>
  <td>
    The absolute amount of memory which can be used for off-heap allocation, in bytes unless otherwise specified.
    This setting has no impact on heap memory usage, so if your executors' total memory consumption 
    must fit within some hard limit then be sure to shrink your JVM heap size accordingly.
    This must be set to a positive value when <code>spark.memory.offHeap.enabled=true</code>.
  </td>
  <td>1.6.0</td>
</tr>
<tr>
  <td><code>spark.storage.replication.proactive</code></td>
  <td>false</td>
  <td>
    Enables proactive block replication for RDD blocks. Cached RDD block replicas lost due to
    executor failures are replenished if there are any existing available replicas. This tries
    to get the replication level of the block to the initial number.
  </td>
  <td>2.2.0</td>
</tr>
<tr>
  <td><code>spark.cleaner.periodicGC.interval</code></td>
  <td>30min</td>
  <td>
    Controls how often to trigger a garbage collection.<br /><br />
    This context cleaner triggers cleanups only when weak references are garbage collected.
    In long-running applications with large driver JVMs, where there is little memory pressure
    on the driver, this may happen very occasionally or not at all. Not cleaning at all may
    lead to executors running out of disk space after a while.
  </td>
  <td>1.6.0</td>
</tr>
<tr>
  <td><code>spark.cleaner.referenceTracking</code></td>
  <td>true</td>
  <td>
    Enables or disables context cleaning.
  </td>
  <td>1.0.0</td>
</tr>
<tr>
  <td><code>spark.cleaner.referenceTracking.blocking</code></td>
  <td>true</td>
  <td>
    Controls whether the cleaning thread should block on cleanup tasks (other than shuffle, which is controlled by
    <code>spark.cleaner.referenceTracking.blocking.shuffle</code> Spark property).
  </td>
  <td>1.0.0</td>
</tr>
<tr>
  <td><code>spark.cleaner.referenceTracking.blocking.shuffle</code></td>
  <td>false</td>
  <td>
    Controls whether the cleaning thread should block on shuffle cleanup tasks.
  </td>
  <td>1.1.1</td>
</tr>
<tr>
  <td><code>spark.cleaner.referenceTracking.cleanCheckpoints</code></td>
  <td>false</td>
  <td>
    Controls whether to clean checkpoint files if the reference is out of scope.
  </td>
  <td>1.4.0</td>
</tr>
</table>

<h3 id="execution-behavior">Execution Behavior</h3>

<table class="table">
<tr><th>Property Name</th><th>Default</th><th>Meaning</th><th>Since Version</th></tr>
<tr>
  <td><code>spark.broadcast.blockSize</code></td>
  <td>4m</td>
  <td>
    Size of each piece of a block for <code>TorrentBroadcastFactory</code>, in KiB unless otherwise 
    specified. Too large a value decreases parallelism during broadcast (makes it slower); however, 
    if it is too small, <code>BlockManager</code> might take a performance hit.
  </td>
  <td>0.5.0</td>
</tr>
<tr>
  <td><code>spark.broadcast.checksum</code></td>
  <td>true</td>
  <td>
    Whether to enable checksum for broadcast. If enabled, broadcasts will include a checksum, which can
    help detect corrupted blocks, at the cost of computing and sending a little more data. It's possible
    to disable it if the network has other mechanisms to guarantee data won't be corrupted during broadcast.
  </td>
  <td>2.1.1</td>
</tr>
<tr>
  <td><code>spark.executor.cores</code></td>
  <td>
    1 in YARN mode, all the available cores on the worker in
    standalone and Mesos coarse-grained modes.
  </td>
  <td>
    The number of cores to use on each executor.

    In standalone and Mesos coarse-grained modes, for more detail, see
    <a href="spark-standalone.html#Executors Scheduling">this description</a>.
  </td>
  <td>1.0.0</td>
</tr>
<tr>
  <td><code>spark.default.parallelism</code></td>
  <td>
    For distributed shuffle operations like <code>reduceByKey</code> and <code>join</code>, the
    largest number of partitions in a parent RDD.  For operations like <code>parallelize</code>
    with no parent RDDs, it depends on the cluster manager:
    <ul>
      <li>Local mode: number of cores on the local machine</li>
      <li>Mesos fine grained mode: 8</li>
      <li>Others: total number of cores on all executor nodes or 2, whichever is larger</li>
    </ul>
  </td>
  <td>
    Default number of partitions in RDDs returned by transformations like <code>join</code>,
    <code>reduceByKey</code>, and <code>parallelize</code> when not set by user.
  </td>
  <td>0.5.0</td>
</tr>
<tr>
  <td><code>spark.executor.heartbeatInterval</code></td>
  <td>10s</td>
  <td>
    Interval between each executor's heartbeats to the driver.  Heartbeats let
    the driver know that the executor is still alive and update it with metrics for in-progress
    tasks. spark.executor.heartbeatInterval should be significantly less than
    spark.network.timeout
  </td>
  <td>1.1.0</td>
</tr>
<tr>
  <td><code>spark.files.fetchTimeout</code></td>
  <td>60s</td>
  <td>
    Communication timeout to use when fetching files added through SparkContext.addFile() from
    the driver.
  </td>
  <td>1.0.0</td>
</tr>
<tr>
  <td><code>spark.files.useFetchCache</code></td>
  <td>true</td>
  <td>
    If set to true (default), file fetching will use a local cache that is shared by executors
    that belong to the same application, which can improve task launching performance when
    running many executors on the same host. If set to false, these caching optimizations will
    be disabled and all executors will fetch their own copies of files. This optimization may be
    disabled in order to use Spark local directories that reside on NFS filesystems (see
    <a href="https://issues.apache.org/jira/browse/SPARK-6313">SPARK-6313</a> for more details).
  </td>
  <td>1.2.2</td>
</tr>
<tr>
  <td><code>spark.files.overwrite</code></td>
  <td>false</td>
  <td>
    Whether to overwrite files added through SparkContext.addFile() when the target file exists and
    its contents do not match those of the source.
  </td>
  <td>1.0.0</td>
</tr>
<tr>
  <td><code>spark.files.maxPartitionBytes</code></td>
  <td>134217728 (128 MiB)</td>
  <td>
    The maximum number of bytes to pack into a single partition when reading files.
  </td>
  <td>2.1.0</td>
</tr>
<tr>
  <td><code>spark.files.openCostInBytes</code></td>
  <td>4194304 (4 MiB)</td>
  <td>
    The estimated cost to open a file, measured by the number of bytes could be scanned at the same
    time. This is used when putting multiple files into a partition. It is better to overestimate,
    then the partitions with small files will be faster than partitions with bigger files.
  </td>
  <td>2.1.0</td>
</tr>
<tr>
  <td><code>spark.hadoop.cloneConf</code></td>
  <td>false</td>
  <td>
    If set to true, clones a new Hadoop <code>Configuration</code> object for each task.  This
    option should be enabled to work around <code>Configuration</code> thread-safety issues (see
    <a href="https://issues.apache.org/jira/browse/SPARK-2546">SPARK-2546</a> for more details).
    This is disabled by default in order to avoid unexpected performance regressions for jobs that
    are not affected by these issues.
  </td>
  <td>1.0.3</td>
</tr>
<tr>
  <td><code>spark.hadoop.validateOutputSpecs</code></td>
  <td>true</td>
  <td>
    If set to true, validates the output specification (e.g. checking if the output directory already exists)
    used in saveAsHadoopFile and other variants. This can be disabled to silence exceptions due to pre-existing
    output directories. We recommend that users do not disable this except if trying to achieve compatibility
    with previous versions of Spark. Simply use Hadoop's FileSystem API to delete output directories by hand.
    This setting is ignored for jobs generated through Spark Streaming's StreamingContext, since data may
    need to be rewritten to pre-existing output directories during checkpoint recovery.
  </td>
  <td>1.0.1</td>
</tr>
<tr>
  <td><code>spark.storage.memoryMapThreshold</code></td>
  <td>2m</td>
  <td>
    Size of a block above which Spark memory maps when reading a block from disk. Default unit is bytes,
    unless specified otherwise. This prevents Spark from memory mapping very small blocks. In general, 
    memory mapping has high overhead for blocks close to or below the page size of the operating system.
  </td>
  <td>0.9.2</td>
</tr>
<tr>
  <td><code>spark.hadoop.mapreduce.fileoutputcommitter.algorithm.version</code></td>
  <td>1</td>
  <td>
    The file output committer algorithm version, valid algorithm version number: 1 or 2.
    Note that 2 may cause a correctness issue like MAPREDUCE-7282.
  </td>
  <td>2.2.0</td>
</tr>
</table>

<h3 id="executor-metrics">Executor Metrics</h3>

<table class="table">
<tr><th>Property Name</th><th>Default</th><th>Meaning</th><th>Since Version</th></tr>
<tr>
  <td><code>spark.eventLog.logStageExecutorMetrics</code></td>
  <td>false</td>
  <td>
    Whether to write per-stage peaks of executor metrics (for each executor) to the event log.
    <br />
    <em>Note:</em> The metrics are polled (collected) and sent in the executor heartbeat,
    and this is always done; this configuration is only to determine if aggregated metric peaks
    are written to the event log.
  </td>
  <td>3.0.0</td>
</tr>
  <td><code>spark.executor.processTreeMetrics.enabled</code></td>
  <td>false</td>
  <td>
    Whether to collect process tree metrics (from the /proc filesystem) when collecting
    executor metrics.
    <br />
    <em>Note:</em> The process tree metrics are collected only if the /proc filesystem
    exists.
  </td>
  <td>3.0.0</td>
<tr>
  <td><code>spark.executor.metrics.pollingInterval</code></td>
  <td>0</td>
  <td>
    How often to collect executor metrics (in milliseconds).
    <br />
    If 0, the polling is done on executor heartbeats (thus at the heartbeat interval,
    specified by <code>spark.executor.heartbeatInterval</code>).
    If positive, the polling is done at this interval.
  </td>
  <td>3.0.0</td>
</tr>
</table>

<h3 id="networking">Networking</h3>

<table class="table">
<tr><th>Property Name</th><th>Default</th><th>Meaning</th><th>Since Version</th></tr>
<tr>
  <td><code>spark.rpc.message.maxSize</code></td>
  <td>128</td>
  <td>
    Maximum message size (in MiB) to allow in "control plane" communication; generally only applies to map
    output size information sent between executors and the driver. Increase this if you are running
    jobs with many thousands of map and reduce tasks and see messages about the RPC message size.
  </td>
  <td>2.0.0</td>
</tr>
<tr>
  <td><code>spark.blockManager.port</code></td>
  <td>(random)</td>
  <td>
    Port for all block managers to listen on. These exist on both the driver and the executors.
  </td>
  <td>1.1.0</td>
</tr>
<tr>
  <td><code>spark.driver.blockManager.port</code></td>
  <td>(value of spark.blockManager.port)</td>
  <td>
    Driver-specific port for the block manager to listen on, for cases where it cannot use the same
    configuration as executors.
  </td>
  <td>2.1.0</td>
</tr>
<tr>
  <td><code>spark.driver.bindAddress</code></td>
  <td>(value of spark.driver.host)</td>
  <td>
    Hostname or IP address where to bind listening sockets. This config overrides the SPARK_LOCAL_IP
    environment variable (see below).

    <br />It also allows a different address from the local one to be advertised to executors or external systems.
    This is useful, for example, when running containers with bridged networking. For this to properly work,
    the different ports used by the driver (RPC, block manager and UI) need to be forwarded from the
    container's host.
  </td>
  <td>2.1.0</td>
</tr>
<tr>
  <td><code>spark.driver.host</code></td>
  <td>(local hostname)</td>
  <td>
    Hostname or IP address for the driver.
    This is used for communicating with the executors and the standalone Master.
  </td>
  <td>0.7.0</td>
</tr>
<tr>
  <td><code>spark.driver.port</code></td>
  <td>(random)</td>
  <td>
    Port for the driver to listen on.
    This is used for communicating with the executors and the standalone Master.
  </td>
  <td>0.7.0</td>
</tr>
<tr>
  <td><code>spark.rpc.io.backLog</code></td>
  <td>64</td>
  <td>
    Length of the accept queue for the RPC server. For large applications, this value may
    need to be increased, so that incoming connections are not dropped when a large number of
    connections arrives in a short period of time.
  </td>
  <td>3.0.0</td>
</tr>
<tr>
  <td><code>spark.network.timeout</code></td>
  <td>120s</td>
  <td>
    Default timeout for all network interactions. This config will be used in place of
    <code>spark.storage.blockManagerHeartbeatTimeoutMs</code>,
    <code>spark.shuffle.io.connectionTimeout</code>, <code>spark.rpc.askTimeout</code> or
    <code>spark.rpc.lookupTimeout</code> if they are not configured.
  </td>
  <td>1.3.0</td>
</tr>
<tr>
  <td><code>spark.network.io.preferDirectBufs</code></td>
  <td>true</td>
  <td>
    If enabled then off-heap buffer allocations are preferred by the shared allocators.
    Off-heap buffers are used to reduce garbage collection during shuffle and cache
    block transfer. For environments where off-heap memory is tightly limited, users may wish to
    turn this off to force all allocations to be on-heap.
  </td>
  <td>3.0.0</td>
</tr>
<tr>
  <td><code>spark.port.maxRetries</code></td>
  <td>16</td>
  <td>
    Maximum number of retries when binding to a port before giving up.
    When a port is given a specific value (non 0), each subsequent retry will
    increment the port used in the previous attempt by 1 before retrying. This
    essentially allows it to try a range of ports from the start port specified
    to port + maxRetries.
  </td>
  <td>1.1.1</td>
</tr>
<tr>
  <td><code>spark.rpc.numRetries</code></td>
  <td>3</td>
  <td>
    Number of times to retry before an RPC task gives up.
    An RPC task will run at most times of this number.
  </td>
  <td>1.4.0</td>
</tr>
<tr>
  <td><code>spark.rpc.retry.wait</code></td>
  <td>3s</td>
  <td>
    Duration for an RPC ask operation to wait before retrying.
  </td>
  <td>1.4.0</td>
</tr>
<tr>
  <td><code>spark.rpc.askTimeout</code></td>
  <td><code>spark.network.timeout</code></td>
  <td>
    Duration for an RPC ask operation to wait before timing out.
  </td>
  <td>1.4.0</td>
</tr>
<tr>
  <td><code>spark.rpc.lookupTimeout</code></td>
  <td>120s</td>
  <td>
    Duration for an RPC remote endpoint lookup operation to wait before timing out.
  </td>
  <td>1.4.0</td>
</tr>
<tr>
  <td><code>spark.network.maxRemoteBlockSizeFetchToMem</code></td>
  <td>200m</td>
  <td>
    Remote block will be fetched to disk when size of the block is above this threshold
    in bytes. This is to avoid a giant request takes too much memory. Note this
    configuration will affect both shuffle fetch and block manager remote block fetch.
    For users who enabled external shuffle service, this feature can only work when
    external shuffle service is at least 2.3.0.
  </td>
  <td>3.0.0</td>
</tr>
</table>

<h3 id="scheduling">Scheduling</h3>

<table class="table">
<tr><th>Property Name</th><th>Default</th><th>Meaning</th><th>Since Version</th></tr>
<tr>
  <td><code>spark.cores.max</code></td>
  <td>(not set)</td>
  <td>
    When running on a <a href="spark-standalone.html">standalone deploy cluster</a> or a
    <a href="running-on-mesos.html#mesos-run-modes">Mesos cluster in "coarse-grained"
    sharing mode</a>, the maximum amount of CPU cores to request for the application from
    across the cluster (not from each machine). If not set, the default will be
    <code>spark.deploy.defaultCores</code> on Spark's standalone cluster manager, or
    infinite (all available cores) on Mesos.
  </td>
  <td>0.6.0</td>
</tr>
<tr>
  <td><code>spark.locality.wait</code></td>
  <td>3s</td>
  <td>
    How long to wait to launch a data-local task before giving up and launching it
    on a less-local node. The same wait will be used to step through multiple locality levels
    (process-local, node-local, rack-local and then any). It is also possible to customize the
    waiting time for each level by setting <code>spark.locality.wait.node</code>, etc.
    You should increase this setting if your tasks are long and see poor locality, but the
    default usually works well.
  </td>
  <td>0.5.0</td>
</tr>
<tr>
  <td><code>spark.locality.wait.node</code></td>
  <td>spark.locality.wait</td>
  <td>
    Customize the locality wait for node locality. For example, you can set this to 0 to skip
    node locality and search immediately for rack locality (if your cluster has rack information).
  </td>
  <td>0.8.0</td>
</tr>
<tr>
  <td><code>spark.locality.wait.process</code></td>
  <td>spark.locality.wait</td>
  <td>
    Customize the locality wait for process locality. This affects tasks that attempt to access
    cached data in a particular executor process.
  </td>
  <td>0.8.0</td>
</tr>
<tr>
  <td><code>spark.locality.wait.rack</code></td>
  <td>spark.locality.wait</td>
  <td>
    Customize the locality wait for rack locality.
  </td>
  <td>0.8.0</td>
</tr>
<tr>
  <td><code>spark.scheduler.maxRegisteredResourcesWaitingTime</code></td>
  <td>30s</td>
  <td>
    Maximum amount of time to wait for resources to register before scheduling begins.
  </td>
  <td>1.1.1</td>
</tr>
<tr>
  <td><code>spark.scheduler.minRegisteredResourcesRatio</code></td>
  <td>0.8 for KUBERNETES mode; 0.8 for YARN mode; 0.0 for standalone mode and Mesos coarse-grained mode</td>
  <td>
    The minimum ratio of registered resources (registered resources / total expected resources)
    (resources are executors in yarn mode and Kubernetes mode, CPU cores in standalone mode and Mesos coarse-grained
     mode ['spark.cores.max' value is total expected resources for Mesos coarse-grained mode] )
    to wait for before scheduling begins. Specified as a double between 0.0 and 1.0.
    Regardless of whether the minimum ratio of resources has been reached,
    the maximum amount of time it will wait before scheduling begins is controlled by config
    <code>spark.scheduler.maxRegisteredResourcesWaitingTime</code>.
  </td>
  <td>1.1.1</td>
</tr>
<tr>
  <td><code>spark.scheduler.mode</code></td>
  <td>FIFO</td>
  <td>
    The <a href="job-scheduling.html#scheduling-within-an-application">scheduling mode</a> between
    jobs submitted to the same SparkContext. Can be set to <code>FAIR</code>
    to use fair sharing instead of queueing jobs one after another. Useful for
    multi-user services.
  </td>
  <td>0.8.0</td>
</tr>
<tr>
  <td><code>spark.scheduler.revive.interval</code></td>
  <td>1s</td>
  <td>
    The interval length for the scheduler to revive the worker resource offers to run tasks.
  </td>
  <td>0.8.1</td>
</tr>
<tr>
  <td><code>spark.scheduler.listenerbus.eventqueue.capacity</code></td>
  <td>10000</td>
  <td>
    The default capacity for event queues. Spark will try to initialize an event queue 
    using capacity specified by `spark.scheduler.listenerbus.eventqueue.queueName.capacity` 
    first. If it's not configured, Spark will use the default capacity specified by this 
    config. Note that capacity must be greater than 0. Consider increasing value (e.g. 20000) 
    if listener events are dropped. Increasing this value may result in the driver using more memory.
  </td>
  <td>2.3.0</td>
</tr>
<tr>
  <td><code>spark.scheduler.listenerbus.eventqueue.shared.capacity</code></td>
  <td><code>spark.scheduler.listenerbus.eventqueue.capacity</code></td>
  <td>
    Capacity for shared event queue in Spark listener bus, which hold events for external listener(s)
    that register to the listener bus. Consider increasing value, if the listener events corresponding
    to shared queue are dropped. Increasing this value may result in the driver using more memory.
  </td>
  <td>3.0.0</td>
</tr>
<tr>
  <td><code>spark.scheduler.listenerbus.eventqueue.appStatus.capacity</code></td>
  <td><code>spark.scheduler.listenerbus.eventqueue.capacity</code></td>
  <td>
    Capacity for appStatus event queue, which hold events for internal application status listeners.
    Consider increasing value, if the listener events corresponding to appStatus queue are dropped.
    Increasing this value may result in the driver using more memory.
  </td>
  <td>3.0.0</td>
</tr>
<tr>
  <td><code>spark.scheduler.listenerbus.eventqueue.executorManagement.capacity</code></td>
  <td><code>spark.scheduler.listenerbus.eventqueue.capacity</code></td>
  <td>
    Capacity for executorManagement event queue in Spark listener bus, which hold events for internal
    executor management listeners. Consider increasing value if the listener events corresponding to
    executorManagement queue are dropped. Increasing this value may result in the driver using more memory.
  </td>
  <td>3.0.0</td>
</tr>
<tr>
  <td><code>spark.scheduler.listenerbus.eventqueue.eventLog.capacity</code></td>
  <td><code>spark.scheduler.listenerbus.eventqueue.capacity</code></td>
  <td>
    Capacity for eventLog queue in Spark listener bus, which hold events for Event logging listeners
    that write events to eventLogs. Consider increasing value if the listener events corresponding to eventLog queue
    are dropped. Increasing this value may result in the driver using more memory.
  </td>
  <td>3.0.0</td>
</tr>
<tr>
  <td><code>spark.scheduler.listenerbus.eventqueue.streams.capacity</code></td>
  <td><code>spark.scheduler.listenerbus.eventqueue.capacity</code></td>
  <td>
    Capacity for streams queue in Spark listener bus, which hold events for internal streaming listener.
    Consider increasing value if the listener events corresponding to streams queue are dropped. Increasing
    this value may result in the driver using more memory.
  </td>
  <td>3.0.0</td>
</tr>
<tr>
  <td><code>spark.scheduler.resource.profileMergeConflicts</code></td>
  <td>false</td>
  <td>
    If set to "true", Spark will merge ResourceProfiles when different profiles are specified
    in RDDs that get combined into a single stage. When they are merged, Spark chooses the maximum of
    each resource and creates a new ResourceProfile. The default of false results in Spark throwing
    an exception if multiple different ResourceProfiles are found in RDDs going into the same stage.
  </td>
  <td>3.1.0</td>
</tr>
<tr>
  <td><code>spark.scheduler.excludeOnFailure.unschedulableTaskSetTimeout</code></td>
  <td>120s</td>
  <td>
    The timeout in seconds to wait to acquire a new executor and schedule a task before aborting a
    TaskSet which is unschedulable because all executors are excluded due to task failures.
  </td>
  <td>2.4.1</td>
</tr>
<tr>
  <td><code>spark.excludeOnFailure.enabled</code></td>
  <td>
    false
  </td>
  <td>
    If set to "true", prevent Spark from scheduling tasks on executors that have been excluded
    due to too many task failures. The algorithm used to exclude executors and nodes can be further
    controlled by the other "spark.excludeOnFailure" configuration options.
  </td>
  <td>2.1.0</td>
</tr>
<tr>
  <td><code>spark.excludeOnFailure.timeout</code></td>
  <td>1h</td>
  <td>
    (Experimental) How long a node or executor is excluded for the entire application, before it
    is unconditionally removed from the excludelist to attempt running new tasks.
  </td>
  <td>2.1.0</td>
</tr>
<tr>
  <td><code>spark.excludeOnFailure.task.maxTaskAttemptsPerExecutor</code></td>
  <td>1</td>
  <td>
    (Experimental) For a given task, how many times it can be retried on one executor before the
    executor is excluded for that task.
  </td>
  <td>2.1.0</td>
</tr>
<tr>
  <td><code>spark.excludeOnFailure.task.maxTaskAttemptsPerNode</code></td>
  <td>2</td>
  <td>
    (Experimental) For a given task, how many times it can be retried on one node, before the entire
    node is excluded for that task.
  </td>
  <td>2.1.0</td>
</tr>
<tr>
  <td><code>spark.excludeOnFailure.stage.maxFailedTasksPerExecutor</code></td>
  <td>2</td>
  <td>
    (Experimental) How many different tasks must fail on one executor, within one stage, before the
    executor is excluded for that stage.
  </td>
  <td>2.1.0</td>
</tr>
<tr>
  <td><code>spark.excludeOnFailure.stage.maxFailedExecutorsPerNode</code></td>
  <td>2</td>
  <td>
    (Experimental) How many different executors are marked as excluded for a given stage, before
    the entire node is marked as failed for the stage.
  </td>
  <td>2.1.0</td>
</tr>
<tr>
  <td><code>spark.excludeOnFailure.application.maxFailedTasksPerExecutor</code></td>
  <td>2</td>
  <td>
    (Experimental) How many different tasks must fail on one executor, in successful task sets,
    before the executor is excluded for the entire application.  Excluded executors will
    be automatically added back to the pool of available resources after the timeout specified by
    <code>spark.excludeOnFailure.timeout</code>.  Note that with dynamic allocation, though, the executors
    may get marked as idle and be reclaimed by the cluster manager.
  </td>
  <td>2.2.0</td>
</tr>
<tr>
  <td><code>spark.excludeOnFailure.application.maxFailedExecutorsPerNode</code></td>
  <td>2</td>
  <td>
    (Experimental) How many different executors must be excluded for the entire application,
    before the node is excluded for the entire application.  Excluded nodes will
    be automatically added back to the pool of available resources after the timeout specified by
    <code>spark.excludeOnFailure.timeout</code>.  Note that with dynamic allocation, though, the
    executors on the node may get marked as idle and be reclaimed by the cluster manager.
  </td>
  <td>2.2.0</td>
</tr>
<tr>
  <td><code>spark.excludeOnFailure.killExcludedExecutors</code></td>
  <td>false</td>
  <td>
    (Experimental) If set to "true", allow Spark to automatically kill the executors 
    when they are excluded on fetch failure or excluded for the entire application, 
    as controlled by spark.killExcludedExecutors.application.*. Note that, when an entire node is added 
    excluded, all of the executors on that node will be killed.
  </td>
  <td>2.2.0</td>
</tr>
<tr>
  <td><code>spark.excludeOnFailure.application.fetchFailure.enabled</code></td>
  <td>false</td>
  <td>
    (Experimental) If set to "true", Spark will exclude the executor immediately when a fetch
    failure happens. If external shuffle service is enabled, then the whole node will be
    excluded.
  </td>
  <td>2.3.0</td>
</tr>
<tr>
  <td><code>spark.speculation</code></td>
  <td>false</td>
  <td>
    If set to "true", performs speculative execution of tasks. This means if one or more tasks are
    running slowly in a stage, they will be re-launched.
  </td>
  <td>0.6.0</td>
</tr>
<tr>
  <td><code>spark.speculation.interval</code></td>
  <td>100ms</td>
  <td>
    How often Spark will check for tasks to speculate.
  </td>
  <td>0.6.0</td>
</tr>
<tr>
  <td><code>spark.speculation.multiplier</code></td>
  <td>1.5</td>
  <td>
    How many times slower a task is than the median to be considered for speculation.
  </td>
  <td>0.6.0</td>
</tr>
<tr>
  <td><code>spark.speculation.quantile</code></td>
  <td>0.75</td>
  <td>
    Fraction of tasks which must be complete before speculation is enabled for a particular stage.
  </td>
  <td>0.6.0</td>
</tr>
<tr>
  <td><code>spark.speculation.task.duration.threshold</code></td>
  <td>None</td>
  <td>
    Task duration after which scheduler would try to speculative run the task. If provided, tasks
    would be speculatively run if current stage contains less tasks than or equal to the number of
    slots on a single executor and the task is taking longer time than the threshold. This config
    helps speculate stage with very few tasks. Regular speculation configs may also apply if the
    executor slots are large enough. E.g. tasks might be re-launched if there are enough successful
    runs even though the threshold hasn't been reached. The number of slots is computed based on
    the conf values of spark.executor.cores and spark.task.cpus minimum 1.
    Default unit is bytes, unless otherwise specified.
  </td>
  <td>3.0.0</td>
</tr>
<tr>
  <td><code>spark.task.cpus</code></td>
  <td>1</td>
  <td>
    Number of cores to allocate for each task.
  </td>
  <td>0.5.0</td>
</tr>
<tr>
  <td><code>spark.task.resource.{resourceName}.amount</code></td>
  <td>1</td>
  <td>
    Amount of a particular resource type to allocate for each task, note that this can be a double.
    If this is specified you must also provide the executor config 
    <code>spark.executor.resource.{resourceName}.amount</code> and any corresponding discovery configs 
    so that your executors are created with that resource type. In addition to whole amounts, 
    a fractional amount (for example, 0.25, which means 1/4th of a resource) may be specified. 
    Fractional amounts must be less than or equal to 0.5, or in other words, the minimum amount of
    resource sharing is 2 tasks per resource. Additionally, fractional amounts are floored 
    in order to assign resource slots (e.g. a 0.2222 configuration, or 1/0.2222 slots will become 
    4 tasks/resource, not 5).
  </td>
  <td>3.0.0</td>
</tr>
<tr>
  <td><code>spark.task.maxFailures</code></td>
  <td>4</td>
  <td>
    Number of failures of any particular task before giving up on the job.
    The total number of failures spread across different tasks will not cause the job
    to fail; a particular task has to fail this number of attempts.
    Should be greater than or equal to 1. Number of allowed retries = this value - 1.
  </td>
  <td>0.8.0</td>
</tr>
<tr>
  <td><code>spark.task.reaper.enabled</code></td>
  <td>false</td>
  <td>
    Enables monitoring of killed / interrupted tasks. When set to true, any task which is killed
    will be monitored by the executor until that task actually finishes executing. See the other
    <code>spark.task.reaper.*</code> configurations for details on how to control the exact behavior
    of this monitoring. When set to false (the default), task killing will use an older code
    path which lacks such monitoring.
  </td>
  <td>2.0.3</td>
</tr>
<tr>
  <td><code>spark.task.reaper.pollingInterval</code></td>
  <td>10s</td>
  <td>
    When <code>spark.task.reaper.enabled = true</code>, this setting controls the frequency at which
    executors will poll the status of killed tasks. If a killed task is still running when polled
    then a warning will be logged and, by default, a thread-dump of the task will be logged
    (this thread dump can be disabled via the <code>spark.task.reaper.threadDump</code> setting,
    which is documented below).
  </td>
  <td>2.0.3</td>
</tr>
<tr>
  <td><code>spark.task.reaper.threadDump</code></td>
  <td>true</td>
  <td>
    When <code>spark.task.reaper.enabled = true</code>, this setting controls whether task thread
    dumps are logged during periodic polling of killed tasks. Set this to false to disable
    collection of thread dumps.
  </td>
  <td>2.0.3</td>
</tr>
<tr>
  <td><code>spark.task.reaper.killTimeout</code></td>
  <td>-1</td>
  <td>
    When <code>spark.task.reaper.enabled = true</code>, this setting specifies a timeout after
    which the executor JVM will kill itself if a killed task has not stopped running. The default
    value, -1, disables this mechanism and prevents the executor from self-destructing. The purpose
    of this setting is to act as a safety-net to prevent runaway noncancellable tasks from rendering
    an executor unusable.
  </td>
  <td>2.0.3</td>
</tr>
<tr>
  <td><code>spark.stage.maxConsecutiveAttempts</code></td>
  <td>4</td>
  <td>
    Number of consecutive stage attempts allowed before a stage is aborted.
  </td>
  <td>2.2.0</td>
</tr>
</table>

<h3 id="barrier-execution-mode">Barrier Execution Mode</h3>

<table class="table">
<tr><th>Property Name</th><th>Default</th><th>Meaning</th><th>Since Version</th></tr>
<tr>
  <td><code>spark.barrier.sync.timeout</code></td>
  <td>365d</td>
  <td>
    The timeout in seconds for each <code>barrier()</code> call from a barrier task. If the
    coordinator didn't receive all the sync messages from barrier tasks within the
    configured time, throw a SparkException to fail all the tasks. The default value is set
    to 31536000(3600 * 24 * 365) so the <code>barrier()</code> call shall wait for one year.
  </td>
  <td>2.4.0</td>
</tr>
<tr>
  <td><code>spark.scheduler.barrier.maxConcurrentTasksCheck.interval</code></td>
  <td>15s</td>
  <td>
    Time in seconds to wait between a max concurrent tasks check failure and the next
    check. A max concurrent tasks check ensures the cluster can launch more concurrent
    tasks than required by a barrier stage on job submitted. The check can fail in case
    a cluster has just started and not enough executors have registered, so we wait for a
    little while and try to perform the check again. If the check fails more than a
    configured max failure times for a job then fail current job submission. Note this
    config only applies to jobs that contain one or more barrier stages, we won't perform
    the check on non-barrier jobs.
  </td>
  <td>2.4.0</td>
</tr>
<tr>
  <td><code>spark.scheduler.barrier.maxConcurrentTasksCheck.maxFailures</code></td>
  <td>40</td>
  <td>
    Number of max concurrent tasks check failures allowed before fail a job submission.
    A max concurrent tasks check ensures the cluster can launch more concurrent tasks than
    required by a barrier stage on job submitted. The check can fail in case a cluster
    has just started and not enough executors have registered, so we wait for a little
    while and try to perform the check again. If the check fails more than a configured
    max failure times for a job then fail current job submission. Note this config only
    applies to jobs that contain one or more barrier stages, we won't perform the check on
    non-barrier jobs.
  </td>
  <td>2.4.0</td>
</tr>
</table>

<h3 id="dynamic-allocation">Dynamic Allocation</h3>

<table class="table">
<tr><th>Property Name</th><th>Default</th><th>Meaning</th><th>Since Version</th></tr>
<tr>
  <td><code>spark.dynamicAllocation.enabled</code></td>
  <td>false</td>
  <td>
    Whether to use dynamic resource allocation, which scales the number of executors registered
    with this application up and down based on the workload.
    For more detail, see the description
    <a href="job-scheduling.html#dynamic-resource-allocation">here</a>.
    <br /><br />
    This requires <code>spark.shuffle.service.enabled</code> or
    <code>spark.dynamicAllocation.shuffleTracking.enabled</code> to be set.
    The following configurations are also relevant:
    <code>spark.dynamicAllocation.minExecutors</code>,
    <code>spark.dynamicAllocation.maxExecutors</code>, and
    <code>spark.dynamicAllocation.initialExecutors</code>
    <code>spark.dynamicAllocation.executorAllocationRatio</code>
  </td>
  <td>1.2.0</td>
</tr>
<tr>
  <td><code>spark.dynamicAllocation.executorIdleTimeout</code></td>
  <td>60s</td>
  <td>
    If dynamic allocation is enabled and an executor has been idle for more than this duration,
    the executor will be removed. For more detail, see this
    <a href="job-scheduling.html#resource-allocation-policy">description</a>.
  </td>
  <td>1.2.0</td>
</tr>
<tr>
  <td><code>spark.dynamicAllocation.cachedExecutorIdleTimeout</code></td>
  <td>infinity</td>
  <td>
    If dynamic allocation is enabled and an executor which has cached data blocks has been idle for more than this duration,
    the executor will be removed. For more details, see this
    <a href="job-scheduling.html#resource-allocation-policy">description</a>.
  </td>
  <td>1.4.0</td>
</tr>
<tr>
  <td><code>spark.dynamicAllocation.initialExecutors</code></td>
  <td><code>spark.dynamicAllocation.minExecutors</code></td>
  <td>
    Initial number of executors to run if dynamic allocation is enabled.
    <br /><br />
    If `--num-executors` (or `spark.executor.instances`) is set and larger than this value, it will
    be used as the initial number of executors.
  </td>
  <td>1.3.0</td>
</tr>
<tr>
  <td><code>spark.dynamicAllocation.maxExecutors</code></td>
  <td>infinity</td>
  <td>
    Upper bound for the number of executors if dynamic allocation is enabled.
  </td>
  <td>1.2.0</td>
</tr>
<tr>
  <td><code>spark.dynamicAllocation.minExecutors</code></td>
  <td>0</td>
  <td>
    Lower bound for the number of executors if dynamic allocation is enabled.
  </td>
  <td>1.2.0</td>
</tr>
<tr>
  <td><code>spark.dynamicAllocation.executorAllocationRatio</code></td>
  <td>1</td>
  <td>
    By default, the dynamic allocation will request enough executors to maximize the
    parallelism according to the number of tasks to process. While this minimizes the
    latency of the job, with small tasks this setting can waste a lot of resources due to
    executor allocation overhead, as some executor might not even do any work.
    This setting allows to set a ratio that will be used to reduce the number of
    executors w.r.t. full parallelism.
    Defaults to 1.0 to give maximum parallelism.
    0.5 will divide the target number of executors by 2
    The target number of executors computed by the dynamicAllocation can still be overridden
    by the <code>spark.dynamicAllocation.minExecutors</code> and
    <code>spark.dynamicAllocation.maxExecutors</code> settings
  </td>
  <td>2.4.0</td>
</tr>
<tr>
  <td><code>spark.dynamicAllocation.schedulerBacklogTimeout</code></td>
  <td>1s</td>
  <td>
    If dynamic allocation is enabled and there have been pending tasks backlogged for more than
    this duration, new executors will be requested. For more detail, see this
    <a href="job-scheduling.html#resource-allocation-policy">description</a>.
  </td>
  <td>1.2.0</td>
</tr>
<tr>
  <td><code>spark.dynamicAllocation.sustainedSchedulerBacklogTimeout</code></td>
  <td><code>schedulerBacklogTimeout</code></td>
  <td>
    Same as <code>spark.dynamicAllocation.schedulerBacklogTimeout</code>, but used only for
    subsequent executor requests. For more detail, see this
    <a href="job-scheduling.html#resource-allocation-policy">description</a>.
  </td>
  <td>1.2.0</td>
</tr>
<tr>
  <td><code>spark.dynamicAllocation.shuffleTracking.enabled</code></td>
  <td><code>false</code></td>
  <td>
    Experimental. Enables shuffle file tracking for executors, which allows dynamic allocation
    without the need for an external shuffle service. This option will try to keep alive executors
    that are storing shuffle data for active jobs.
  </td>
  <td>3.0.0</td>
</tr>
<tr>
  <td><code>spark.dynamicAllocation.shuffleTracking.timeout</code></td>
  <td><code>infinity</code></td>
  <td>
    When shuffle tracking is enabled, controls the timeout for executors that are holding shuffle
    data. The default value means that Spark will rely on the shuffles being garbage collected to be
    able to release executors. If for some reason garbage collection is not cleaning up shuffles
    quickly enough, this option can be used to control when to time out executors even when they are
    storing shuffle data.
  </td>
  <td>3.0.0</td>
</tr>
</table>

<h3 id="thread-configurations">Thread Configurations</h3>

<p>Depending on jobs and cluster configurations, we can set number of threads in several places in Spark to utilize 
available resources efficiently to get better performance. Prior to Spark 3.0, these thread configurations apply 
to all roles of Spark, such as driver, executor, worker and master. From Spark 3.0, we can configure threads in 
finer granularity starting from driver and executor. Take RPC module as example in below table. For other modules,
like shuffle, just replace &#8220;rpc&#8221; with &#8220;shuffle&#8221; in the property names except 
<code>spark.{driver|executor}.rpc.netty.dispatcher.numThreads</code>, which is only for RPC module.</p>

<table class="table">
<tr><th>Property Name</th><th>Default</th><th>Meaning</th><th>Since Version</th></tr>
<tr>
  <td><code>spark.{driver|executor}.rpc.io.serverThreads</code></td>
  <td>
    Fall back on <code>spark.rpc.io.serverThreads</code>
  </td>
  <td>Number of threads used in the server thread pool</td>
  <td>1.6.0</td>
</tr>
<tr>
  <td><code>spark.{driver|executor}.rpc.io.clientThreads</code></td>
  <td>
    Fall back on <code>spark.rpc.io.clientThreads</code>
  </td>
  <td>Number of threads used in the client thread pool</td>
  <td>1.6.0</td>
</tr>
<tr>
  <td><code>spark.{driver|executor}.rpc.netty.dispatcher.numThreads</code></td>
  <td>
    Fall back on <code>spark.rpc.netty.dispatcher.numThreads</code>
  </td>
  <td>Number of threads used in RPC message dispatcher thread pool</td>
  <td>3.0.0</td>
</tr>
</table>

<p>The default value for number of thread-related config keys is the minimum of the number of cores requested for 
the driver or executor, or, in the absence of that value, the number of cores available for the JVM (with a hardcoded upper limit of 8).</p>

<h3 id="security">Security</h3>

<p>Please refer to the <a href="security.html">Security</a> page for available options on how to secure different
Spark subsystems.</p>

<h3 id="spark-sql">Spark SQL</h3>

<h4 id="runtime-sql-configuration">Runtime SQL Configuration</h4>

<p>Runtime SQL configurations are per-session, mutable Spark SQL configurations. They can be set with initial values by the config file
and command-line options with <code class="language-plaintext highlighter-rouge">--conf/-c</code> prefixed, or by setting <code class="language-plaintext highlighter-rouge">SparkConf</code> that are used to create <code class="language-plaintext highlighter-rouge">SparkSession</code>.
Also, they can be set and queried by SET commands and rest to their initial values by RESET command,
or by <code class="language-plaintext highlighter-rouge">SparkSession.conf</code>&#8217;s setter and getter methods in runtime.</p>

<table class="table">
<tr><th>Property Name</th><th>Default</th><th>Meaning</th><th>Since Version</th></tr>

<tr>
    <td><code>spark.sql.adaptive.advisoryPartitionSizeInBytes</code></td>
    <td>(value of <code>spark.sql.adaptive.shuffle.targetPostShuffleInputSize</code>)</td>
    <td><p>The advisory size in bytes of the shuffle partition during adaptive optimization (when spark.sql.adaptive.enabled is true). It takes effect when Spark coalesces small shuffle partitions or splits skewed shuffle partition.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.adaptive.coalescePartitions.enabled</code></td>
    <td>true</td>
    <td><p>When true and 'spark.sql.adaptive.enabled' is true, Spark will coalesce contiguous shuffle partitions according to the target size (specified by 'spark.sql.adaptive.advisoryPartitionSizeInBytes'), to avoid too many small tasks.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.adaptive.coalescePartitions.initialPartitionNum</code></td>
    <td>(none)</td>
    <td><p>The initial number of shuffle partitions before coalescing. If not set, it equals to spark.sql.shuffle.partitions. This configuration only has an effect when 'spark.sql.adaptive.enabled' and 'spark.sql.adaptive.coalescePartitions.enabled' are both true.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.adaptive.coalescePartitions.minPartitionNum</code></td>
    <td>(none)</td>
    <td><p>The suggested (not guaranteed) minimum number of shuffle partitions after coalescing. If not set, the default value is the default parallelism of the Spark cluster. This configuration only has an effect when 'spark.sql.adaptive.enabled' and 'spark.sql.adaptive.coalescePartitions.enabled' are both true.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.adaptive.enabled</code></td>
    <td>false</td>
    <td><p>When true, enable adaptive query execution, which re-optimizes the query plan in the middle of query execution, based on accurate runtime statistics.</p></td>
    <td>1.6.0</td>
</tr>

<tr>
    <td><code>spark.sql.adaptive.localShuffleReader.enabled</code></td>
    <td>true</td>
    <td><p>When true and 'spark.sql.adaptive.enabled' is true, Spark tries to use local shuffle reader to read the shuffle data when the shuffle partitioning is not needed, for example, after converting sort-merge join to broadcast-hash join.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.adaptive.optimizer.excludedRules</code></td>
    <td>(none)</td>
    <td><p>Configures a list of rules to be disabled in the adaptive optimizer, in which the rules are specified by their rule names and separated by comma. The optimizer will log the rules that have indeed been excluded.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.adaptive.skewJoin.enabled</code></td>
    <td>true</td>
    <td><p>When true and 'spark.sql.adaptive.enabled' is true, Spark dynamically handles skew in sort-merge join by splitting (and replicating if needed) skewed partitions.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.adaptive.skewJoin.skewedPartitionFactor</code></td>
    <td>5</td>
    <td><p>A partition is considered as skewed if its size is larger than this factor multiplying the median partition size and also larger than 'spark.sql.adaptive.skewJoin.skewedPartitionThresholdInBytes'</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.adaptive.skewJoin.skewedPartitionThresholdInBytes</code></td>
    <td>256MB</td>
    <td><p>A partition is considered as skewed if its size in bytes is larger than this threshold and also larger than 'spark.sql.adaptive.skewJoin.skewedPartitionFactor' multiplying the median partition size. Ideally this config should be set larger than 'spark.sql.adaptive.advisoryPartitionSizeInBytes'.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.ansi.enabled</code></td>
    <td>false</td>
    <td><p>When true, Spark SQL uses an ANSI compliant dialect instead of being Hive compliant. For example, Spark will throw an exception at runtime instead of returning null results when the inputs to a SQL operator/function are invalid.For full details of this dialect, you can find them in the section "ANSI Compliance" of Spark's documentation. Some ANSI dialect features may be not from the ANSI SQL standard directly, but their behaviors align with ANSI SQL's style</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.autoBroadcastJoinThreshold</code></td>
    <td>10MB</td>
    <td><p>Configures the maximum size in bytes for a table that will be broadcast to all worker nodes when performing a join.  By setting this value to -1 broadcasting can be disabled. Note that currently statistics are only supported for Hive Metastore tables where the command <code>ANALYZE TABLE &lt;tableName&gt; COMPUTE STATISTICS noscan</code> has been run, and file-based data source tables where the statistics are computed directly on the files of data.</p></td>
    <td>1.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.avro.compression.codec</code></td>
    <td>snappy</td>
    <td><p>Compression codec used in writing of AVRO files. Supported codecs: uncompressed, deflate, snappy, bzip2 and xz. Default codec is snappy.</p></td>
    <td>2.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.avro.deflate.level</code></td>
    <td>-1</td>
    <td><p>Compression level for the deflate codec used in writing of AVRO files. Valid value must be in the range of from 1 to 9 inclusive or -1. The default value is -1 which corresponds to 6 level in the current implementation.</p></td>
    <td>2.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.avro.filterPushdown.enabled</code></td>
    <td>true</td>
    <td><p>When true, enable filter pushdown to Avro datasource.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.broadcastTimeout</code></td>
    <td>300</td>
    <td><p>Timeout in seconds for the broadcast wait time in broadcast joins.</p></td>
    <td>1.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.bucketing.coalesceBucketsInJoin.enabled</code></td>
    <td>false</td>
    <td><p>When true, if two bucketed tables with the different number of buckets are joined, the side with a bigger number of buckets will be coalesced to have the same number of buckets as the other side. Bigger number of buckets is divisible by the smaller number of buckets. Bucket coalescing is applied to sort-merge joins and shuffled hash join. Note: Coalescing bucketed table can avoid unnecessary shuffling in join, but it also reduces parallelism and could possibly cause OOM for shuffled hash join.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.bucketing.coalesceBucketsInJoin.maxBucketRatio</code></td>
    <td>4</td>
    <td><p>The ratio of the number of two buckets being coalesced should be less than or equal to this value for bucket coalescing to be applied. This configuration only has an effect when 'spark.sql.bucketing.coalesceBucketsInJoin.enabled' is set to true.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.catalog.spark_catalog</code></td>
    <td>(none)</td>
    <td><p>A catalog implementation that will be used as the v2 interface to Spark's built-in v1 catalog: spark_catalog. This catalog shares its identifier namespace with the spark_catalog and must be consistent with it; for example, if a table can be loaded by the spark_catalog, this catalog must also return the table metadata. To delegate operations to the spark_catalog, implementations can extend 'CatalogExtension'.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.cbo.enabled</code></td>
    <td>false</td>
    <td><p>Enables CBO for estimation of plan statistics when set true.</p></td>
    <td>2.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.cbo.joinReorder.dp.star.filter</code></td>
    <td>false</td>
    <td><p>Applies star-join filter heuristics to cost based join enumeration.</p></td>
    <td>2.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.cbo.joinReorder.dp.threshold</code></td>
    <td>12</td>
    <td><p>The maximum number of joined nodes allowed in the dynamic programming algorithm.</p></td>
    <td>2.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.cbo.joinReorder.enabled</code></td>
    <td>false</td>
    <td><p>Enables join reorder in CBO.</p></td>
    <td>2.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.cbo.planStats.enabled</code></td>
    <td>false</td>
    <td><p>When true, the logical plan will fetch row counts and column statistics from catalog.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.cbo.starSchemaDetection</code></td>
    <td>false</td>
    <td><p>When true, it enables join reordering based on star schema detection. </p></td>
    <td>2.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.columnNameOfCorruptRecord</code></td>
    <td>_corrupt_record</td>
    <td><p>The name of internal column for storing raw/un-parsed JSON and CSV records that fail to parse.</p></td>
    <td>1.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.csv.filterPushdown.enabled</code></td>
    <td>true</td>
    <td><p>When true, enable filter pushdown to CSV datasource.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.datetime.java8API.enabled</code></td>
    <td>false</td>
    <td><p>If the configuration property is set to true, java.time.Instant and java.time.LocalDate classes of Java 8 API are used as external types for Catalyst's TimestampType and DateType. If it is set to false, java.sql.Timestamp and java.sql.Date are used for the same purpose.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.debug.maxToStringFields</code></td>
    <td>25</td>
    <td><p>Maximum number of fields of sequence-like entries can be converted to strings in debug output. Any elements beyond the limit will be dropped and replaced by a "... N more fields" placeholder.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.defaultCatalog</code></td>
    <td>spark_catalog</td>
    <td><p>Name of the default catalog. This will be the current catalog if users have not explicitly set the current catalog yet.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.execution.arrow.enabled</code></td>
    <td>false</td>
    <td><p>(Deprecated since Spark 3.0, please set 'spark.sql.execution.arrow.pyspark.enabled'.)</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.execution.arrow.fallback.enabled</code></td>
    <td>true</td>
    <td><p>(Deprecated since Spark 3.0, please set 'spark.sql.execution.arrow.pyspark.fallback.enabled'.)</p></td>
    <td>2.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.execution.arrow.maxRecordsPerBatch</code></td>
    <td>10000</td>
    <td><p>When using Apache Arrow, limit the maximum number of records that can be written to a single ArrowRecordBatch in memory. If set to zero or negative there is no limit.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.execution.arrow.pyspark.enabled</code></td>
    <td>(value of <code>spark.sql.execution.arrow.enabled</code>)</td>
    <td><p>When true, make use of Apache Arrow for columnar data transfers in PySpark. This optimization applies to: 1. pyspark.sql.DataFrame.toPandas 2. pyspark.sql.SparkSession.createDataFrame when its input is a Pandas DataFrame The following data types are unsupported: ArrayType of TimestampType, and nested StructType.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.execution.arrow.pyspark.fallback.enabled</code></td>
    <td>(value of <code>spark.sql.execution.arrow.fallback.enabled</code>)</td>
    <td><p>When true, optimizations enabled by 'spark.sql.execution.arrow.pyspark.enabled' will fallback automatically to non-optimized implementations if an error occurs.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.execution.arrow.sparkr.enabled</code></td>
    <td>false</td>
    <td><p>When true, make use of Apache Arrow for columnar data transfers in SparkR. This optimization applies to: 1. createDataFrame when its input is an R DataFrame 2. collect 3. dapply 4. gapply The following data types are unsupported: FloatType, BinaryType, ArrayType, StructType and MapType.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.execution.pandas.udf.buffer.size</code></td>
    <td>(value of <code>spark.buffer.size</code>)</td>
    <td><p>Same as <code>spark.buffer.size</code> but only applies to Pandas UDF executions. If it is not set, the fallback is <code>spark.buffer.size</code>. Note that Pandas execution requires more than 4 bytes. Lowering this value could make small Pandas UDF batch iterated and pipelined; however, it might degrade performance. See SPARK-27870.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.execution.pyspark.udf.simplifiedTraceback.enabled</code></td>
    <td>false</td>
    <td><p>When true, the traceback from Python UDFs is simplified. It hides the Python worker, (de)serialization, etc from PySpark in tracebacks, and only shows the exception messages from UDFs. Note that this works only with CPython 3.7+.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.files.ignoreCorruptFiles</code></td>
    <td>false</td>
    <td><p>Whether to ignore corrupt files. If true, the Spark jobs will continue to run when encountering corrupted files and the contents that have been read will still be returned. This configuration is effective only when using file-based sources such as Parquet, JSON and ORC.</p></td>
    <td>2.1.1</td>
</tr>

<tr>
    <td><code>spark.sql.files.ignoreMissingFiles</code></td>
    <td>false</td>
    <td><p>Whether to ignore missing files. If true, the Spark jobs will continue to run when encountering missing files and the contents that have been read will still be returned. This configuration is effective only when using file-based sources such as Parquet, JSON and ORC.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.files.maxPartitionBytes</code></td>
    <td>128MB</td>
    <td><p>The maximum number of bytes to pack into a single partition when reading files. This configuration is effective only when using file-based sources such as Parquet, JSON and ORC.</p></td>
    <td>2.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.files.maxRecordsPerFile</code></td>
    <td>0</td>
    <td><p>Maximum number of records to write out to a single file. If this value is zero or negative, there is no limit.</p></td>
    <td>2.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.files.minPartitionNum</code></td>
    <td>(none)</td>
    <td><p>The suggested (not guaranteed) minimum number of split file partitions. If not set, the default value is <code>spark.default.parallelism</code>. This configuration is effective only when using file-based sources such as Parquet, JSON and ORC.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.function.concatBinaryAsString</code></td>
    <td>false</td>
    <td><p>When this option is set to false and all inputs are binary, <code>functions.concat</code> returns an output as binary. Otherwise, it returns as a string.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.function.eltOutputAsString</code></td>
    <td>false</td>
    <td><p>When this option is set to false and all inputs are binary, <code>elt</code> returns an output as binary. Otherwise, it returns as a string.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.groupByAliases</code></td>
    <td>true</td>
    <td><p>When true, aliases in a select list can be used in group by clauses. When false, an analysis exception is thrown in the case.</p></td>
    <td>2.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.groupByOrdinal</code></td>
    <td>true</td>
    <td><p>When true, the ordinal numbers in group by clauses are treated as the position in the select list. When false, the ordinal numbers are ignored.</p></td>
    <td>2.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.hive.convertInsertingPartitionedTable</code></td>
    <td>true</td>
    <td><p>When set to true, and <code>spark.sql.hive.convertMetastoreParquet</code> or <code>spark.sql.hive.convertMetastoreOrc</code> is true, the built-in ORC/Parquet writer is usedto process inserting into partitioned ORC/Parquet tables created by using the HiveSQL syntax.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.hive.convertMetastoreCtas</code></td>
    <td>true</td>
    <td><p>When set to true,  Spark will try to use built-in data source writer instead of Hive serde in CTAS. This flag is effective only if <code>spark.sql.hive.convertMetastoreParquet</code> or <code>spark.sql.hive.convertMetastoreOrc</code> is enabled respectively for Parquet and ORC formats</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.hive.convertMetastoreOrc</code></td>
    <td>true</td>
    <td><p>When set to true, the built-in ORC reader and writer are used to process ORC tables created by using the HiveQL syntax, instead of Hive serde.</p></td>
    <td>2.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.hive.convertMetastoreParquet</code></td>
    <td>true</td>
    <td><p>When set to true, the built-in Parquet reader and writer are used to process parquet tables created by using the HiveQL syntax, instead of Hive serde.</p></td>
    <td>1.1.1</td>
</tr>

<tr>
    <td><code>spark.sql.hive.convertMetastoreParquet.mergeSchema</code></td>
    <td>false</td>
    <td><p>When true, also tries to merge possibly different but compatible Parquet schemas in different Parquet data files. This configuration is only effective when "spark.sql.hive.convertMetastoreParquet" is true.</p></td>
    <td>1.3.1</td>
</tr>

<tr>
    <td><code>spark.sql.hive.filesourcePartitionFileCacheSize</code></td>
    <td>262144000</td>
    <td><p>When nonzero, enable caching of partition file metadata in memory. All tables share a cache that can use up to specified num bytes for file metadata. This conf only has an effect when hive filesource partition management is enabled.</p></td>
    <td>2.1.1</td>
</tr>

<tr>
    <td><code>spark.sql.hive.manageFilesourcePartitions</code></td>
    <td>true</td>
    <td><p>When true, enable metastore partition management for file source tables as well. This includes both datasource and converted Hive tables. When partition management is enabled, datasource tables store partition in the Hive metastore, and use the metastore to prune partitions during query planning.</p></td>
    <td>2.1.1</td>
</tr>

<tr>
    <td><code>spark.sql.hive.metastorePartitionPruning</code></td>
    <td>true</td>
    <td><p>When true, some predicates will be pushed down into the Hive metastore so that unmatching partitions can be eliminated earlier. This only affects Hive tables not converted to filesource relations (see HiveUtils.CONVERT_METASTORE_PARQUET and HiveUtils.CONVERT_METASTORE_ORC for more information).</p></td>
    <td>1.5.0</td>
</tr>

<tr>
    <td><code>spark.sql.hive.thriftServer.async</code></td>
    <td>true</td>
    <td><p>When set to true, Hive Thrift server executes SQL queries in an asynchronous way.</p></td>
    <td>1.5.0</td>
</tr>

<tr>
    <td><code>spark.sql.hive.verifyPartitionPath</code></td>
    <td>false</td>
    <td><p>When true, check all the partition paths under the table's root directory when reading data stored in HDFS. This configuration will be deprecated in the future releases and replaced by spark.files.ignoreMissingFiles.</p></td>
    <td>1.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.hive.version</code></td>
    <td>(value of <code>spark.sql.hive.metastore.version</code>)</td>
    <td><p>deprecated, please use spark.sql.hive.metastore.version to get the Hive version in Spark.</p></td>
    <td>1.1.1</td>
</tr>

<tr>
    <td><code>spark.sql.inMemoryColumnarStorage.batchSize</code></td>
    <td>10000</td>
    <td><p>Controls the size of batches for columnar caching.  Larger batch sizes can improve memory utilization and compression, but risk OOMs when caching data.</p></td>
    <td>1.1.1</td>
</tr>

<tr>
    <td><code>spark.sql.inMemoryColumnarStorage.compressed</code></td>
    <td>true</td>
    <td><p>When set to true Spark SQL will automatically select a compression codec for each column based on statistics of the data.</p></td>
    <td>1.0.1</td>
</tr>

<tr>
    <td><code>spark.sql.inMemoryColumnarStorage.enableVectorizedReader</code></td>
    <td>true</td>
    <td><p>Enables vectorized reader for columnar caching.</p></td>
    <td>2.3.1</td>
</tr>

<tr>
    <td><code>spark.sql.json.filterPushdown.enabled</code></td>
    <td>true</td>
    <td><p>When true, enable filter pushdown to JSON datasource.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.jsonGenerator.ignoreNullFields</code></td>
    <td>true</td>
    <td><p>Whether to ignore null fields when generating JSON objects in JSON data source and JSON functions such as to_json. If false, it generates null for null fields in JSON objects.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.legacy.allowHashOnMapType</code></td>
    <td>false</td>
    <td><p>When set to true, hash expressions can be applied on elements of MapType. Otherwise, an analysis exception will be thrown.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.mapKeyDedupPolicy</code></td>
    <td>EXCEPTION</td>
    <td><p>The policy to deduplicate map keys in builtin function: CreateMap, MapFromArrays, MapFromEntries, StringToMap, MapConcat and TransformKeys. When EXCEPTION, the query fails if duplicated map keys are detected. When LAST_WIN, the map key that is inserted at last takes precedence.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.maven.additionalRemoteRepositories</code></td>
    <td>https://maven-central.storage-download.googleapis.com/maven2/</td>
    <td><p>A comma-delimited string config of the optional additional remote Maven mirror repositories. This is only used for downloading Hive jars in IsolatedClientLoader if the default Maven Central repo is unreachable.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.maxMetadataStringLength</code></td>
    <td>100</td>
    <td><p>Maximum number of characters to output for a metadata string. e.g. file location in <code>DataSourceScanExec</code>, every value will be abbreviated if exceed length.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.maxPlanStringLength</code></td>
    <td>2147483632</td>
    <td><p>Maximum number of characters to output for a plan string.  If the plan is longer, further output will be truncated.  The default setting always generates a full plan.  Set this to a lower value such as 8k if plan strings are taking up too much memory or are causing OutOfMemory errors in the driver or UI processes.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.optimizer.dynamicPartitionPruning.enabled</code></td>
    <td>true</td>
    <td><p>When true, we will generate predicate for partition column when it's used as join key</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.optimizer.enableJsonExpressionOptimization</code></td>
    <td>true</td>
    <td><p>Whether to optimize JSON expressions in SQL optimizer. It includes pruning unnecessary columns from from_json, simplifing from_json + to_json, to_json + named_struct(from_json.col1, from_json.col2, ....).</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.optimizer.excludedRules</code></td>
    <td>(none)</td>
    <td><p>Configures a list of rules to be disabled in the optimizer, in which the rules are specified by their rule names and separated by comma. It is not guaranteed that all the rules in this configuration will eventually be excluded, as some rules are necessary for correctness. The optimizer will log the rules that have indeed been excluded.</p></td>
    <td>2.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.orc.columnarReaderBatchSize</code></td>
    <td>4096</td>
    <td><p>The number of rows to include in a orc vectorized reader batch. The number should be carefully chosen to minimize overhead and avoid OOMs in reading data.</p></td>
    <td>2.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.orc.compression.codec</code></td>
    <td>snappy</td>
    <td><p>Sets the compression codec used when writing ORC files. If either <code>compression</code> or <code>orc.compress</code> is specified in the table-specific options/properties, the precedence would be <code>compression</code>, <code>orc.compress</code>, <code>spark.sql.orc.compression.codec</code>.Acceptable values include: none, uncompressed, snappy, zlib, lzo.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.orc.enableVectorizedReader</code></td>
    <td>true</td>
    <td><p>Enables vectorized orc decoding.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.orc.filterPushdown</code></td>
    <td>true</td>
    <td><p>When true, enable filter pushdown for ORC files.</p></td>
    <td>1.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.orc.mergeSchema</code></td>
    <td>false</td>
    <td><p>When true, the Orc data source merges schemas collected from all data files, otherwise the schema is picked from a random data file.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.orderByOrdinal</code></td>
    <td>true</td>
    <td><p>When true, the ordinal numbers are treated as the position in the select list. When false, the ordinal numbers in order/sort by clause are ignored.</p></td>
    <td>2.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.binaryAsString</code></td>
    <td>false</td>
    <td><p>Some other Parquet-producing systems, in particular Impala and older versions of Spark SQL, do not differentiate between binary data and strings when writing out the Parquet schema. This flag tells Spark SQL to interpret binary data as a string to provide compatibility with these systems.</p></td>
    <td>1.1.1</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.columnarReaderBatchSize</code></td>
    <td>4096</td>
    <td><p>The number of rows to include in a parquet vectorized reader batch. The number should be carefully chosen to minimize overhead and avoid OOMs in reading data.</p></td>
    <td>2.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.compression.codec</code></td>
    <td>snappy</td>
    <td><p>Sets the compression codec used when writing Parquet files. If either <code>compression</code> or <code>parquet.compression</code> is specified in the table-specific options/properties, the precedence would be <code>compression</code>, <code>parquet.compression</code>, <code>spark.sql.parquet.compression.codec</code>. Acceptable values include: none, uncompressed, snappy, gzip, lzo, brotli, lz4, zstd.</p></td>
    <td>1.1.1</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.enableVectorizedReader</code></td>
    <td>true</td>
    <td><p>Enables vectorized parquet decoding.</p></td>
    <td>2.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.filterPushdown</code></td>
    <td>true</td>
    <td><p>Enables Parquet filter push-down optimization when set to true.</p></td>
    <td>1.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.int96AsTimestamp</code></td>
    <td>true</td>
    <td><p>Some Parquet-producing systems, in particular Impala, store Timestamp into INT96. Spark would also store Timestamp as INT96 because we need to avoid precision lost of the nanoseconds field. This flag tells Spark SQL to interpret INT96 data as a timestamp to provide compatibility with these systems.</p></td>
    <td>1.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.int96TimestampConversion</code></td>
    <td>false</td>
    <td><p>This controls whether timestamp adjustments should be applied to INT96 data when converting to timestamps, for data written by Impala.  This is necessary because Impala stores INT96 data with a different timezone offset than Hive &amp; Spark.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.mergeSchema</code></td>
    <td>false</td>
    <td><p>When true, the Parquet data source merges schemas collected from all data files, otherwise the schema is picked from the summary file or a random data file if no summary file is available.</p></td>
    <td>1.5.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.outputTimestampType</code></td>
    <td>INT96</td>
    <td><p>Sets which Parquet timestamp type to use when Spark writes data to Parquet files. INT96 is a non-standard but commonly used timestamp type in Parquet. TIMESTAMP_MICROS is a standard timestamp type in Parquet, which stores number of microseconds from the Unix epoch. TIMESTAMP_MILLIS is also standard, but with millisecond precision, which means Spark has to truncate the microsecond portion of its timestamp value.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.recordLevelFilter.enabled</code></td>
    <td>false</td>
    <td><p>If true, enables Parquet's native record-level filtering using the pushed down filters. This configuration only has an effect when 'spark.sql.parquet.filterPushdown' is enabled and the vectorized reader is not used. You can ensure the vectorized reader is not used by setting 'spark.sql.parquet.enableVectorizedReader' to false.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.respectSummaryFiles</code></td>
    <td>false</td>
    <td><p>When true, we make assumption that all part-files of Parquet are consistent with summary files and we will ignore them when merging schema. Otherwise, if this is false, which is the default, we will merge all part-files. This should be considered as expert-only option, and shouldn't be enabled before knowing what it means exactly.</p></td>
    <td>1.5.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.writeLegacyFormat</code></td>
    <td>false</td>
    <td><p>If true, data will be written in a way of Spark 1.4 and earlier. For example, decimal values will be written in Apache Parquet's fixed-length byte array format, which other systems such as Apache Hive and Apache Impala use. If false, the newer format in Parquet will be used. For example, decimals will be written in int-based format. If Parquet output is intended for use with systems that do not support this newer format, set to true.</p></td>
    <td>1.6.0</td>
</tr>

<tr>
    <td><code>spark.sql.parser.quotedRegexColumnNames</code></td>
    <td>false</td>
    <td><p>When true, quoted Identifiers (using backticks) in SELECT statement are interpreted as regular expressions.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.pivotMaxValues</code></td>
    <td>10000</td>
    <td><p>When doing a pivot without specifying values for the pivot column this is the maximum number of (distinct) values that will be collected without error.</p></td>
    <td>1.6.0</td>
</tr>

<tr>
    <td><code>spark.sql.pyspark.jvmStacktrace.enabled</code></td>
    <td>false</td>
    <td><p>When true, it shows the JVM stacktrace in the user-facing PySpark exception together with Python stacktrace. By default, it is disabled and hides JVM stacktrace and shows a Python-friendly exception only.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.redaction.options.regex</code></td>
    <td>(?i)url</td>
    <td><p>Regex to decide which keys in a Spark SQL command's options map contain sensitive information. The values of options whose names that match this regex will be redacted in the explain output. This redaction is applied on top of the global redaction configuration defined by spark.redaction.regex.</p></td>
    <td>2.2.2</td>
</tr>

<tr>
    <td><code>spark.sql.redaction.string.regex</code></td>
    <td>(value of <code>spark.redaction.string.regex</code>)</td>
    <td><p>Regex to decide which parts of strings produced by Spark contain sensitive information. When this regex matches a string part, that string part is replaced by a dummy value. This is currently used to redact the output of SQL explain commands. When this conf is not set, the value from <code>spark.redaction.string.regex</code> is used.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.repl.eagerEval.enabled</code></td>
    <td>false</td>
    <td><p>Enables eager evaluation or not. When true, the top K rows of Dataset will be displayed if and only if the REPL supports the eager evaluation. Currently, the eager evaluation is supported in PySpark and SparkR. In PySpark, for the notebooks like Jupyter, the HTML table (generated by <em>repr_html</em>) will be returned. For plain Python REPL, the returned outputs are formatted like dataframe.show(). In SparkR, the returned outputs are showed similar to R data.frame would.</p></td>
    <td>2.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.repl.eagerEval.maxNumRows</code></td>
    <td>20</td>
    <td><p>The max number of rows that are returned by eager evaluation. This only takes effect when spark.sql.repl.eagerEval.enabled is set to true. The valid range of this config is from 0 to (Int.MaxValue - 1), so the invalid config like negative and greater than (Int.MaxValue - 1) will be normalized to 0 and (Int.MaxValue - 1).</p></td>
    <td>2.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.repl.eagerEval.truncate</code></td>
    <td>20</td>
    <td><p>The max number of characters for each cell that is returned by eager evaluation. This only takes effect when spark.sql.repl.eagerEval.enabled is set to true.</p></td>
    <td>2.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.session.timeZone</code></td>
    <td>(value of local timezone)</td>
    <td><p>The ID of session local timezone in the format of either region-based zone IDs or zone offsets. Region IDs must have the form 'area/city', such as 'America/Los_Angeles'. Zone offsets must be in the format '(+|-)HH', '(+|-)HH:mm' or '(+|-)HH:mm:ss', e.g '-08', '+01:00' or '-13:33:33'. Also 'UTC' and 'Z' are supported as aliases of '+00:00'. Other short names are not recommended to use because they can be ambiguous.</p></td>
    <td>2.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.shuffle.partitions</code></td>
    <td>200</td>
    <td><p>The default number of partitions to use when shuffling data for joins or aggregations. Note: For structured streaming, this configuration cannot be changed between query restarts from the same checkpoint location.</p></td>
    <td>1.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.sources.bucketing.autoBucketedScan.enabled</code></td>
    <td>true</td>
    <td><p>When true, decide whether to do bucketed scan on input tables based on query plan automatically. Do not use bucketed scan if 1. query does not have operators to utilize bucketing (e.g. join, group-by, etc), or 2. there's an exchange operator between these operators and table scan. Note when 'spark.sql.sources.bucketing.enabled' is set to false, this configuration does not take any effect.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.sources.bucketing.enabled</code></td>
    <td>true</td>
    <td><p>When false, we will treat bucketed table as normal table</p></td>
    <td>2.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.sources.bucketing.maxBuckets</code></td>
    <td>100000</td>
    <td><p>The maximum number of buckets allowed.</p></td>
    <td>2.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.sources.default</code></td>
    <td>parquet</td>
    <td><p>The default data source to use in input/output.</p></td>
    <td>1.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.sources.parallelPartitionDiscovery.threshold</code></td>
    <td>32</td>
    <td><p>The maximum number of paths allowed for listing files at driver side. If the number of detected paths exceeds this value during partition discovery, it tries to list the files with another Spark distributed job. This configuration is effective only when using file-based sources such as Parquet, JSON and ORC.</p></td>
    <td>1.5.0</td>
</tr>

<tr>
    <td><code>spark.sql.sources.partitionColumnTypeInference.enabled</code></td>
    <td>true</td>
    <td><p>When true, automatically infer the data types for partitioned columns.</p></td>
    <td>1.5.0</td>
</tr>

<tr>
    <td><code>spark.sql.sources.partitionOverwriteMode</code></td>
    <td>STATIC</td>
    <td><p>When INSERT OVERWRITE a partitioned data source table, we currently support 2 modes: static and dynamic. In static mode, Spark deletes all the partitions that match the partition specification(e.g. PARTITION(a=1,b)) in the INSERT statement, before overwriting. In dynamic mode, Spark doesn't delete partitions ahead, and only overwrite those partitions that have data written into it at runtime. By default we use static mode to keep the same behavior of Spark prior to 2.3. Note that this config doesn't affect Hive serde tables, as they are always overwritten with dynamic mode. This can also be set as an output option for a data source using key partitionOverwriteMode (which takes precedence over this setting), e.g. dataframe.write.option("partitionOverwriteMode", "dynamic").save(path).</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.statistics.fallBackToHdfs</code></td>
    <td>false</td>
    <td><p>When true, it will fall back to HDFS if the table statistics are not available from table metadata. This is useful in determining if a table is small enough to use broadcast joins. This flag is effective only for non-partitioned Hive tables. For non-partitioned data source tables, it will be automatically recalculated if table statistics are not available. For partitioned data source and partitioned Hive tables, It is 'spark.sql.defaultSizeInBytes' if table statistics are not available.</p></td>
    <td>2.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.statistics.histogram.enabled</code></td>
    <td>false</td>
    <td><p>Generates histograms when computing column statistics if enabled. Histograms can provide better estimation accuracy. Currently, Spark only supports equi-height histogram. Note that collecting histograms takes extra cost. For example, collecting column statistics usually takes only one table scan, but generating equi-height histogram will cause an extra table scan.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.statistics.size.autoUpdate.enabled</code></td>
    <td>false</td>
    <td><p>Enables automatic update for table size once table's data is changed. Note that if the total number of files of the table is very large, this can be expensive and slow down data change commands.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.storeAssignmentPolicy</code></td>
    <td>ANSI</td>
    <td><p>When inserting a value into a column with different data type, Spark will perform type coercion. Currently, we support 3 policies for the type coercion rules: ANSI, legacy and strict. With ANSI policy, Spark performs the type coercion as per ANSI SQL. In practice, the behavior is mostly the same as PostgreSQL. It disallows certain unreasonable type conversions such as converting <code>string</code> to <code>int</code> or <code>double</code> to <code>boolean</code>. With legacy policy, Spark allows the type coercion as long as it is a valid <code>Cast</code>, which is very loose. e.g. converting <code>string</code> to <code>int</code> or <code>double</code> to <code>boolean</code> is allowed. It is also the only behavior in Spark 2.x and it is compatible with Hive. With strict policy, Spark doesn't allow any possible precision loss or data truncation in type coercion, e.g. converting <code>double</code> to <code>int</code> or <code>decimal</code> to <code>double</code> is not allowed.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.checkpointLocation</code></td>
    <td>(none)</td>
    <td><p>The default location for storing checkpoint data for streaming queries.</p></td>
    <td>2.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.continuous.epochBacklogQueueSize</code></td>
    <td>10000</td>
    <td><p>The max number of entries to be stored in queue to wait for late epochs. If this parameter is exceeded by the size of the queue, stream will stop with an error.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.disabledV2Writers</code></td>
    <td></td>
    <td><p>A comma-separated list of fully qualified data source register class names for which StreamWriteSupport is disabled. Writes to these sources will fall back to the V1 Sinks.</p></td>
    <td>2.3.1</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.fileSource.cleaner.numThreads</code></td>
    <td>1</td>
    <td><p>Number of threads used in the file source completed file cleaner.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.forceDeleteTempCheckpointLocation</code></td>
    <td>false</td>
    <td><p>When true, enable temporary checkpoint locations force delete.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.metricsEnabled</code></td>
    <td>false</td>
    <td><p>Whether Dropwizard/Codahale metrics will be reported for active streaming queries.</p></td>
    <td>2.0.2</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.multipleWatermarkPolicy</code></td>
    <td>min</td>
    <td><p>Policy to calculate the global watermark value when there are multiple watermark operators in a streaming query. The default value is 'min' which chooses the minimum watermark reported across multiple operators. Other alternative value is 'max' which chooses the maximum across multiple operators. Note: This configuration cannot be changed between query restarts from the same checkpoint location.</p></td>
    <td>2.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.noDataMicroBatches.enabled</code></td>
    <td>true</td>
    <td><p>Whether streaming micro-batch engine will execute batches without data for eager state management for stateful streaming queries.</p></td>
    <td>2.4.1</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.numRecentProgressUpdates</code></td>
    <td>100</td>
    <td><p>The number of progress updates to retain for a streaming query</p></td>
    <td>2.1.1</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.stateStore.stateSchemaCheck</code></td>
    <td>true</td>
    <td><p>When true, Spark will validate the state schema against schema on existing state and fail query if it's incompatible.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.stopActiveRunOnRestart</code></td>
    <td>true</td>
    <td><p>Running multiple runs of the same streaming query concurrently is not supported. If we find a concurrent active run for a streaming query (in the same or different SparkSessions on the same cluster) and this flag is true, we will stop the old streaming query run to start the new one.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.stopTimeout</code></td>
    <td>0</td>
    <td><p>How long to wait in milliseconds for the streaming execution thread to stop when calling the streaming query's stop() method. 0 or negative values wait indefinitely.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.thriftServer.queryTimeout</code></td>
    <td>0ms</td>
    <td><p>Set a query duration timeout in seconds in Thrift Server. If the timeout is set to a positive value, a running query will be cancelled automatically when the timeout is exceeded, otherwise the query continues to run till completion. If timeout values are set for each statement via <code>java.sql.Statement.setQueryTimeout</code> and they are smaller than this configuration value, they take precedence.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.thriftserver.scheduler.pool</code></td>
    <td>(none)</td>
    <td><p>Set a Fair Scheduler pool for a JDBC client session.</p></td>
    <td>1.1.1</td>
</tr>

<tr>
    <td><code>spark.sql.thriftserver.ui.retainedSessions</code></td>
    <td>200</td>
    <td><p>The number of SQL client sessions kept in the JDBC/ODBC web UI history.</p></td>
    <td>1.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.thriftserver.ui.retainedStatements</code></td>
    <td>200</td>
    <td><p>The number of SQL statements kept in the JDBC/ODBC web UI history.</p></td>
    <td>1.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.ui.explainMode</code></td>
    <td>formatted</td>
    <td><p>Configures the query explain mode used in the Spark SQL UI. The value can be 'simple', 'extended', 'codegen', 'cost', or 'formatted'. The default value is 'formatted'.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.variable.substitute</code></td>
    <td>true</td>
    <td><p>This enables substitution using syntax like <code>${var}</code>, <code>${system:var}</code>, and <code>${env:var}</code>.</p></td>
    <td>2.0.0</td>
</tr>
</table>

<h4 id="static-sql-configuration">Static SQL Configuration</h4>

<p>Static SQL configurations are cross-session, immutable Spark SQL configurations. They can be set with final values by the config file
and command-line options with <code class="language-plaintext highlighter-rouge">--conf/-c</code> prefixed, or by setting <code class="language-plaintext highlighter-rouge">SparkConf</code> that are used to create <code class="language-plaintext highlighter-rouge">SparkSession</code>.
External users can query the static sql config values via <code class="language-plaintext highlighter-rouge">SparkSession.conf</code> or via set command, e.g. <code class="language-plaintext highlighter-rouge">SET spark.sql.extensions;</code>, but cannot set/unset them.</p>

<table class="table">
<tr><th>Property Name</th><th>Default</th><th>Meaning</th><th>Since Version</th></tr>

<tr>
    <td><code>spark.sql.cache.serializer</code></td>
    <td>org.apache.spark.sql.execution.columnar.DefaultCachedBatchSerializer</td>
    <td><p>The name of a class that implements org.apache.spark.sql.columnar.CachedBatchSerializer. It will be used to translate SQL data into a format that can more efficiently be cached. The underlying API is subject to change so use with caution. Multiple classes cannot be specified. The class must have a no-arg constructor.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.event.truncate.length</code></td>
    <td>2147483647</td>
    <td><p>Threshold of SQL length beyond which it will be truncated before adding to event. Defaults to no truncation. If set to 0, callsite will be logged instead.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.extensions</code></td>
    <td>(none)</td>
    <td><p>A comma-separated list of classes that implement Function1[SparkSessionExtensions, Unit] used to configure Spark Session extensions. The classes must have a no-args constructor. If multiple extensions are specified, they are applied in the specified order. For the case of rules and planner strategies, they are applied in the specified order. For the case of parsers, the last parser is used and each parser can delegate to its predecessor. For the case of function name conflicts, the last registered function name is used.</p></td>
    <td>2.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.hive.metastore.barrierPrefixes</code></td>
    <td></td>
    <td><p>A comma separated list of class prefixes that should explicitly be reloaded for each version of Hive that Spark SQL is communicating with. For example, Hive UDFs that are declared in a prefix that typically would be shared (i.e. <code>org.apache.spark.*</code>).</p></td>
    <td>1.4.0</td>
</tr>

               <tr>
                   <td><code>spark.sql.hive.metastore.jars</code></td>
                   <td>builtin</td>
                   <td><p>Location of the jars that should be used to instantiate the HiveMetastoreClient.
This property can be one of four options:
1. "builtin"
  Use Hive 2.3.7, which is bundled with the Spark assembly when
  <code>-Phive</code> is enabled. When this option is chosen,
  <code>spark.sql.hive.metastore.version</code> must be either
  <code>2.3.7</code> or not defined.
2. "maven"
  Use Hive jars of specified version downloaded from Maven repositories.
3. "path"
  Use Hive jars configured by <code>spark.sql.hive.metastore.jars.path</code>
  in comma separated format. Support both local or remote paths.The provided jars
  should be the same version as ConfigEntry(key=spark.sql.hive.metastore.version, defaultValue=2.3.7, doc=Version of the Hive metastore. Available options are <code>0.12.0</code> through <code>2.3.7</code> and <code>3.0.0</code> through <code>3.1.2</code>., public=true, version=1.4.0).
4. A classpath in the standard format for both Hive and Hadoop. The provided jars
  should be the same version as ConfigEntry(key=spark.sql.hive.metastore.version, defaultValue=2.3.7, doc=Version of the Hive metastore. Available options are <code>0.12.0</code> through <code>2.3.7</code> and <code>3.0.0</code> through <code>3.1.2</code>., public=true, version=1.4.0).</p></td>
                   <td>1.4.0</td>
               </tr>

               <tr>
                   <td><code>spark.sql.hive.metastore.jars.path</code></td>
                   <td></td>
                   <td><p>Comma-separated paths of the jars that used to instantiate the HiveMetastoreClient.
This configuration is useful only when <code>{ConfigEntry(key=spark.sql.hive.metastore.jars, defaultValue=builtin, doc=
Location of the jars that should be used to instantiate the HiveMetastoreClient.
This property can be one of four options:
1. "builtin"
  Use Hive 2.3.7, which is bundled with the Spark assembly when
  &lt;code&gt;-Phive&lt;/code&gt; is enabled. When this option is chosen,
  &lt;code&gt;spark.sql.hive.metastore.version&lt;/code&gt; must be either
  &lt;code&gt;2.3.7&lt;/code&gt; or not defined.
2. "maven"
  Use Hive jars of specified version downloaded from Maven repositories.
3. "path"
  Use Hive jars configured by</code>spark.sql.hive.metastore.jars.path<code>in comma separated format. Support both local or remote paths.The provided jars
  should be the same version as ConfigEntry(key=spark.sql.hive.metastore.version, defaultValue=2.3.7, doc=Version of the Hive metastore. Available options are &lt;code&gt;0.12.0&lt;/code&gt; through &lt;code&gt;2.3.7&lt;/code&gt; and &lt;code&gt;3.0.0&lt;/code&gt; through &lt;code&gt;3.1.2&lt;/code&gt;., public=true, version=1.4.0).
4. A classpath in the standard format for both Hive and Hadoop. The provided jars
  should be the same version as ConfigEntry(key=spark.sql.hive.metastore.version, defaultValue=2.3.7, doc=Version of the Hive metastore. Available options are &lt;code&gt;0.12.0&lt;/code&gt; through &lt;code&gt;2.3.7&lt;/code&gt; and &lt;code&gt;3.0.0&lt;/code&gt; through &lt;code&gt;3.1.2&lt;/code&gt;., public=true, version=1.4.0).
     , public=true, version=1.4.0).key}</code> is set as <code>path</code>.
The paths can be any of the following format:
1. file://path/to/jar/foo.jar
2. hdfs://nameservice/path/to/jar/foo.jar
3. /path/to/jar/ (path without URI scheme follow conf <code>fs.defaultFS</code>'s URI schema)
4. [http/https/ftp]://path/to/jar/foo.jar
Note that 1, 2, and 3 support wildcard. For example:
1. file://path/to/jar/<em>,file://path2/to/jar/</em>/<em>.jar
2. hdfs://nameservice/path/to/jar/</em>,hdfs://nameservice2/path/to/jar/<em>/</em>.jar</p></td>
                   <td>3.1.0</td>
               </tr>

<tr>
    <td><code>spark.sql.hive.metastore.sharedPrefixes</code></td>
    <td>com.mysql.jdbc,org.postgresql,com.microsoft.sqlserver,oracle.jdbc</td>
    <td><p>A comma separated list of class prefixes that should be loaded using the classloader that is shared between Spark SQL and a specific version of Hive. An example of classes that should be shared is JDBC drivers that are needed to talk to the metastore. Other classes that need to be shared are those that interact with classes that are already shared. For example, custom appenders that are used by log4j.</p></td>
    <td>1.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.hive.metastore.version</code></td>
    <td>2.3.7</td>
    <td><p>Version of the Hive metastore. Available options are <code>0.12.0</code> through <code>2.3.7</code> and <code>3.0.0</code> through <code>3.1.2</code>.</p></td>
    <td>1.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.hive.thriftServer.singleSession</code></td>
    <td>false</td>
    <td><p>When set to true, Hive Thrift server is running in a single session mode. All the JDBC/ODBC connections share the temporary views, function registries, SQL configuration and the current database.</p></td>
    <td>1.6.0</td>
</tr>

<tr>
    <td><code>spark.sql.legacy.sessionInitWithConfigDefaults</code></td>
    <td>false</td>
    <td><p>Flag to revert to legacy behavior where a cloned SparkSession receives SparkConf defaults, dropping any overrides in its parent SparkSession.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.metadataCacheTTLSeconds</code></td>
    <td>-1000ms</td>
    <td><p>Time-to-live (TTL) value for the metadata caches: partition file metadata cache and session catalog cache. This configuration only has an effect when this value having a positive value (&gt; 0). It also requires setting 'spark.sql.catalogImplementation' to <code>hive</code>, setting 'spark.sql.hive.filesourcePartitionFileCacheSize' &gt; 0 and setting 'spark.sql.hive.manageFilesourcePartitions' to <code>true</code> to be applied to the partition file metadata cache.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.queryExecutionListeners</code></td>
    <td>(none)</td>
    <td><p>List of class names implementing QueryExecutionListener that will be automatically added to newly created sessions. The classes should have either a no-arg constructor, or a constructor that expects a SparkConf argument.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.streamingQueryListeners</code></td>
    <td>(none)</td>
    <td><p>List of class names implementing StreamingQueryListener that will be automatically added to newly created sessions. The classes should have either a no-arg constructor, or a constructor that expects a SparkConf argument.</p></td>
    <td>2.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.ui.enabled</code></td>
    <td>true</td>
    <td><p>Whether to run the Structured Streaming Web UI for the Spark application when the Spark Web UI is enabled.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.ui.retainedProgressUpdates</code></td>
    <td>100</td>
    <td><p>The number of progress updates to retain for a streaming query for Structured Streaming UI.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.ui.retainedQueries</code></td>
    <td>100</td>
    <td><p>The number of inactive queries to retain for Structured Streaming UI.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.ui.retainedExecutions</code></td>
    <td>1000</td>
    <td><p>Number of executions to retain in the Spark UI.</p></td>
    <td>1.5.0</td>
</tr>

<tr>
    <td><code>spark.sql.warehouse.dir</code></td>
    <td>(value of <code>$PWD/spark-warehouse</code>)</td>
    <td><p>The default location for managed databases and tables.</p></td>
    <td>2.0.0</td>
</tr>
</table>

<h3 id="spark-streaming">Spark Streaming</h3>

<table class="table">
<tr><th>Property Name</th><th>Default</th><th>Meaning</th><th>Since Version</th></tr>
<tr>
  <td><code>spark.streaming.backpressure.enabled</code></td>
  <td>false</td>
  <td>
    Enables or disables Spark Streaming's internal backpressure mechanism (since 1.5).
    This enables the Spark Streaming to control the receiving rate based on the
    current batch scheduling delays and processing times so that the system receives
    only as fast as the system can process. Internally, this dynamically sets the
    maximum receiving rate of receivers. This rate is upper bounded by the values
    <code>spark.streaming.receiver.maxRate</code> and <code>spark.streaming.kafka.maxRatePerPartition</code>
    if they are set (see below).
  </td>
  <td>1.5.0</td>
</tr>
<tr>
  <td><code>spark.streaming.backpressure.initialRate</code></td>
  <td>not set</td>
  <td>
    This is the initial maximum receiving rate at which each receiver will receive data for the
    first batch when the backpressure mechanism is enabled.
  </td>
  <td>2.0.0</td>
</tr>
<tr>
  <td><code>spark.streaming.blockInterval</code></td>
  <td>200ms</td>
  <td>
    Interval at which data received by Spark Streaming receivers is chunked
    into blocks of data before storing them in Spark. Minimum recommended - 50 ms. See the
    <a href="streaming-programming-guide.html#level-of-parallelism-in-data-receiving">performance
     tuning</a> section in the Spark Streaming programming guide for more details.
  </td>
  <td>0.8.0</td>
</tr>
<tr>
  <td><code>spark.streaming.receiver.maxRate</code></td>
  <td>not set</td>
  <td>
    Maximum rate (number of records per second) at which each receiver will receive data.
    Effectively, each stream will consume at most this number of records per second.
    Setting this configuration to 0 or a negative number will put no limit on the rate.
    See the <a href="streaming-programming-guide.html#deploying-applications">deployment guide</a>
    in the Spark Streaming programming guide for mode details.
  </td>
  <td>1.0.2</td>
</tr>
<tr>
  <td><code>spark.streaming.receiver.writeAheadLog.enable</code></td>
  <td>false</td>
  <td>
    Enable write-ahead logs for receivers. All the input data received through receivers
    will be saved to write-ahead logs that will allow it to be recovered after driver failures.
    See the <a href="streaming-programming-guide.html#deploying-applications">deployment guide</a>
    in the Spark Streaming programming guide for more details.
  </td>
  <td>1.2.1</td>
</tr>
<tr>
  <td><code>spark.streaming.unpersist</code></td>
  <td>true</td>
  <td>
    Force RDDs generated and persisted by Spark Streaming to be automatically unpersisted from
    Spark's memory. The raw input data received by Spark Streaming is also automatically cleared.
    Setting this to false will allow the raw data and persisted RDDs to be accessible outside the
    streaming application as they will not be cleared automatically. But it comes at the cost of
    higher memory usage in Spark.
  </td>
  <td>0.9.0</td>
</tr>
<tr>
  <td><code>spark.streaming.stopGracefullyOnShutdown</code></td>
  <td>false</td>
  <td>
    If <code>true</code>, Spark shuts down the <code>StreamingContext</code> gracefully on JVM
    shutdown rather than immediately.
  </td>
  <td>1.4.0</td>
</tr>
<tr>
  <td><code>spark.streaming.kafka.maxRatePerPartition</code></td>
  <td>not set</td>
  <td>
    Maximum rate (number of records per second) at which data will be read from each Kafka
    partition when using the new Kafka direct stream API. See the
    <a href="streaming-kafka-0-10-integration.html">Kafka Integration guide</a>
    for more details.
  </td>
  <td>1.3.0</td>
</tr>
<tr>
  <td><code>spark.streaming.kafka.minRatePerPartition</code></td>
  <td>1</td>
  <td>
    Minimum rate (number of records per second) at which data will be read from each Kafka
    partition when using the new Kafka direct stream API.
  </td>
  <td>2.4.0</td>
</tr>
<tr>
  <td><code>spark.streaming.ui.retainedBatches</code></td>
  <td>1000</td>
  <td>
    How many batches the Spark Streaming UI and status APIs remember before garbage collecting.
  </td>
  <td>1.0.0</td>
</tr>
<tr>
  <td><code>spark.streaming.driver.writeAheadLog.closeFileAfterWrite</code></td>
  <td>false</td>
  <td>
    Whether to close the file after writing a write-ahead log record on the driver. Set this to 'true'
    when you want to use S3 (or any file system that does not support flushing) for the metadata WAL
    on the driver.
  </td>
  <td>1.6.0</td>
</tr>
<tr>
  <td><code>spark.streaming.receiver.writeAheadLog.closeFileAfterWrite</code></td>
  <td>false</td>
  <td>
    Whether to close the file after writing a write-ahead log record on the receivers. Set this to 'true'
    when you want to use S3 (or any file system that does not support flushing) for the data WAL
    on the receivers.
  </td>
  <td>1.6.0</td>
</tr>
</table>

<h3 id="sparkr">SparkR</h3>

<table class="table">
<tr><th>Property Name</th><th>Default</th><th>Meaning</th><th>Since Version</th></tr>
<tr>
  <td><code>spark.r.numRBackendThreads</code></td>
  <td>2</td>
  <td>
    Number of threads used by RBackend to handle RPC calls from SparkR package.
  </td>
  <td>1.4.0</td>
</tr>
<tr>
  <td><code>spark.r.command</code></td>
  <td>Rscript</td>
  <td>
    Executable for executing R scripts in cluster modes for both driver and workers.
  </td>
  <td>1.5.3</td>
</tr>
<tr>
  <td><code>spark.r.driver.command</code></td>
  <td>spark.r.command</td>
  <td>
    Executable for executing R scripts in client modes for driver. Ignored in cluster modes.
  </td>
  <td>1.5.3</td>
</tr>
<tr>
  <td><code>spark.r.shell.command</code></td>
  <td>R</td>
  <td>
    Executable for executing sparkR shell in client modes for driver. Ignored in cluster modes. It is the same as environment variable <code>SPARKR_DRIVER_R</code>, but take precedence over it.
    <code>spark.r.shell.command</code> is used for sparkR shell while <code>spark.r.driver.command</code> is used for running R script.
  </td>
  <td>2.1.0</td>
</tr>
<tr>
  <td><code>spark.r.backendConnectionTimeout</code></td>
  <td>6000</td>
  <td>
    Connection timeout set by R process on its connection to RBackend in seconds.
  </td>
  <td>2.1.0</td>
</tr>
<tr>
  <td><code>spark.r.heartBeatInterval</code></td>
  <td>100</td>
  <td>
    Interval for heartbeats sent from SparkR backend to R process to prevent connection timeout.
  </td>
  <td>2.1.0</td>
</tr>

</table>

<h3 id="graphx">GraphX</h3>

<table class="table">
<tr><th>Property Name</th><th>Default</th><th>Meaning</th><th>Since Version</th></tr>
<tr>
  <td><code>spark.graphx.pregel.checkpointInterval</code></td>
  <td>-1</td>
  <td>
    Checkpoint interval for graph and message in Pregel. It used to avoid stackOverflowError due to long lineage chains
  after lots of iterations. The checkpoint is disabled by default.
  </td>
  <td>2.2.0</td>
</tr>
</table>

<h3 id="deploy">Deploy</h3>

<table class="table">
  <tr><th>Property Name</th><th>Default</th><th>Meaning</th><th>Since Version</th></tr>
  <tr>
    <td><code>spark.deploy.recoveryMode</code></td>
    <td>NONE</td>
    <td>The recovery mode setting to recover submitted Spark jobs with cluster mode when it failed and relaunches.
    This is only applicable for cluster mode when running with Standalone or Mesos.</td>
    <td>0.8.1</td>
  </tr>
  <tr>
    <td><code>spark.deploy.zookeeper.url</code></td>
    <td>None</td>
    <td>When `spark.deploy.recoveryMode` is set to ZOOKEEPER, this configuration is used to set the zookeeper URL to connect to.</td>
    <td>0.8.1</td>
  </tr>
  <tr>
    <td><code>spark.deploy.zookeeper.dir</code></td>
    <td>None</td>
    <td>When `spark.deploy.recoveryMode` is set to ZOOKEEPER, this configuration is used to set the zookeeper directory to store recovery state.</td>
    <td>0.8.1</td>
  </tr>
</table>

<h3 id="cluster-managers">Cluster Managers</h3>

<p>Each cluster manager in Spark has additional configuration options. Configurations
can be found on the pages for each mode:</p>

<h4 id="yarn"><a href="running-on-yarn.html#configuration">YARN</a></h4>

<h4 id="mesos"><a href="running-on-mesos.html#configuration">Mesos</a></h4>

<h4 id="kubernetes"><a href="running-on-kubernetes.html#configuration">Kubernetes</a></h4>

<h4 id="standalone-mode"><a href="spark-standalone.html#cluster-launch-scripts">Standalone Mode</a></h4>

<h1 id="environment-variables">Environment Variables</h1>

<p>Certain Spark settings can be configured through environment variables, which are read from the
<code class="language-plaintext highlighter-rouge">conf/spark-env.sh</code> script in the directory where Spark is installed (or <code class="language-plaintext highlighter-rouge">conf/spark-env.cmd</code> on
Windows). In Standalone and Mesos modes, this file can give machine specific information such as
hostnames. It is also sourced when running local Spark applications or submission scripts.</p>

<p>Note that <code class="language-plaintext highlighter-rouge">conf/spark-env.sh</code> does not exist by default when Spark is installed. However, you can
copy <code class="language-plaintext highlighter-rouge">conf/spark-env.sh.template</code> to create it. Make sure you make the copy executable.</p>

<p>The following variables can be set in <code class="language-plaintext highlighter-rouge">spark-env.sh</code>:</p>

<table class="table">
  <tr><th style="width:21%">Environment Variable</th><th>Meaning</th></tr>
  <tr>
    <td><code>JAVA_HOME</code></td>
    <td>Location where Java is installed (if it's not on your default <code>PATH</code>).</td>
  </tr>
  <tr>
    <td><code>PYSPARK_PYTHON</code></td>
    <td>Python binary executable to use for PySpark in both driver and workers (default is <code>python3</code> if available, otherwise <code>python</code>).
    Property <code>spark.pyspark.python</code> take precedence if it is set</td>
  </tr>
  <tr>
    <td><code>PYSPARK_DRIVER_PYTHON</code></td>
    <td>Python binary executable to use for PySpark in driver only (default is <code>PYSPARK_PYTHON</code>).
    Property <code>spark.pyspark.driver.python</code> take precedence if it is set</td>
  </tr>
  <tr>
    <td><code>SPARKR_DRIVER_R</code></td>
    <td>R binary executable to use for SparkR shell (default is <code>R</code>).
    Property <code>spark.r.shell.command</code> take precedence if it is set</td>
  </tr>
  <tr>
    <td><code>SPARK_LOCAL_IP</code></td>
    <td>IP address of the machine to bind to.</td>
  </tr>
  <tr>
    <td><code>SPARK_PUBLIC_DNS</code></td>
    <td>Hostname your Spark program will advertise to other machines.</td>
  </tr>
</table>

<p>In addition to the above, there are also options for setting up the Spark
<a href="spark-standalone.html#cluster-launch-scripts">standalone cluster scripts</a>, such as number of cores
to use on each machine and maximum memory.</p>

<p>Since <code class="language-plaintext highlighter-rouge">spark-env.sh</code> is a shell script, some of these can be set programmatically &#8211; for example, you might
compute <code class="language-plaintext highlighter-rouge">SPARK_LOCAL_IP</code> by looking up the IP of a specific network interface.</p>

<p>Note: When running Spark on YARN in <code class="language-plaintext highlighter-rouge">cluster</code> mode, environment variables need to be set using the <code class="language-plaintext highlighter-rouge">spark.yarn.appMasterEnv.[EnvironmentVariableName]</code> property in your <code class="language-plaintext highlighter-rouge">conf/spark-defaults.conf</code> file.  Environment variables that are set in <code class="language-plaintext highlighter-rouge">spark-env.sh</code> will not be reflected in the YARN Application Master process in <code class="language-plaintext highlighter-rouge">cluster</code> mode.  See the <a href="running-on-yarn.html#spark-properties">YARN-related Spark Properties</a> for more information.</p>

<h1 id="configuring-logging">Configuring Logging</h1>

<p>Spark uses <a href="http://logging.apache.org/log4j/">log4j</a> for logging. You can configure it by adding a
<code class="language-plaintext highlighter-rouge">log4j.properties</code> file in the <code class="language-plaintext highlighter-rouge">conf</code> directory. One way to start is to copy the existing
<code class="language-plaintext highlighter-rouge">log4j.properties.template</code> located there.</p>

<p>By default, Spark adds 1 record to the MDC (Mapped Diagnostic Context): <code class="language-plaintext highlighter-rouge">mdc.taskName</code>, which shows something
like <code class="language-plaintext highlighter-rouge">task 1.0 in stage 0.0</code>. You can add <code class="language-plaintext highlighter-rouge">%X{mdc.taskName}</code> to your patternLayout in
order to print it in the logs.
Moreover, you can use <code class="language-plaintext highlighter-rouge">spark.sparkContext.setLocalProperty(s"mdc.$name", "value")</code> to add user specific data into MDC.
The key in MDC will be the string of &#8220;mdc.$name&#8221;.</p>

<h1 id="overriding-configuration-directory">Overriding configuration directory</h1>

<p>To specify a different configuration directory other than the default &#8220;SPARK_HOME/conf&#8221;,
you can set SPARK_CONF_DIR. Spark will use the configuration files (spark-defaults.conf, spark-env.sh, log4j.properties, etc)
from this directory.</p>

<h1 id="inheriting-hadoop-cluster-configuration">Inheriting Hadoop Cluster Configuration</h1>

<p>If you plan to read and write from HDFS using Spark, there are two Hadoop configuration files that
should be included on Spark&#8217;s classpath:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">hdfs-site.xml</code>, which provides default behaviors for the HDFS client.</li>
  <li><code class="language-plaintext highlighter-rouge">core-site.xml</code>, which sets the default filesystem name.</li>
</ul>

<p>The location of these configuration files varies across Hadoop versions, but
a common location is inside of <code class="language-plaintext highlighter-rouge">/etc/hadoop/conf</code>. Some tools create
configurations on-the-fly, but offer a mechanism to download copies of them.</p>

<p>To make these files visible to Spark, set <code class="language-plaintext highlighter-rouge">HADOOP_CONF_DIR</code> in <code class="language-plaintext highlighter-rouge">$SPARK_HOME/conf/spark-env.sh</code>
to a location containing the configuration files.</p>

<h1 id="custom-hadoophive-configuration">Custom Hadoop/Hive Configuration</h1>

<p>If your Spark application is interacting with Hadoop, Hive, or both, there are probably Hadoop/Hive
configuration files in Spark&#8217;s classpath.</p>

<p>Multiple running applications might require different Hadoop/Hive client side configurations.
You can copy and modify <code class="language-plaintext highlighter-rouge">hdfs-site.xml</code>, <code class="language-plaintext highlighter-rouge">core-site.xml</code>, <code class="language-plaintext highlighter-rouge">yarn-site.xml</code>, <code class="language-plaintext highlighter-rouge">hive-site.xml</code> in
Spark&#8217;s classpath for each application. In a Spark cluster running on YARN, these configuration
files are set cluster-wide, and cannot safely be changed by the application.</p>

<p>The better choice is to use spark hadoop properties in the form of <code class="language-plaintext highlighter-rouge">spark.hadoop.*</code>, and use
spark hive properties in the form of <code class="language-plaintext highlighter-rouge">spark.hive.*</code>.
For example, adding configuration &#8220;spark.hadoop.abc.def=xyz&#8221; represents adding hadoop property &#8220;abc.def=xyz&#8221;,
and adding configuration &#8220;spark.hive.abc=xyz&#8221; represents adding hive property &#8220;hive.abc=xyz&#8221;.
They can be considered as same as normal spark properties which can be set in <code class="language-plaintext highlighter-rouge">$SPARK_HOME/conf/spark-defaults.conf</code></p>

<p>In some cases, you may want to avoid hard-coding certain configurations in a <code class="language-plaintext highlighter-rouge">SparkConf</code>. For
instance, Spark allows you to simply create an empty conf and set spark/spark hadoop/spark hive properties.</p>

<figure class="highlight"><pre><code class="language-scala" data-lang="scala"><span class="k">val</span> <span class="nv">conf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SparkConf</span><span class="o">().</span><span class="py">set</span><span class="o">(</span><span class="s">"spark.hadoop.abc.def"</span><span class="o">,</span> <span class="s">"xyz"</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">sc</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SparkContext</span><span class="o">(</span><span class="n">conf</span><span class="o">)</span></code></pre></figure>

<p>Also, you can modify or add configurations at runtime:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">./bin/spark-submit <span class="se">\ </span>
  <span class="nt">--name</span> <span class="s2">"My app"</span> <span class="se">\ </span>
  <span class="nt">--master</span> <span class="nb">local</span><span class="o">[</span>4] <span class="se">\ </span> 
  <span class="nt">--conf</span> spark.eventLog.enabled<span class="o">=</span><span class="nb">false</span> <span class="se">\ </span>
  <span class="nt">--conf</span> <span class="s2">"spark.executor.extraJavaOptions=-XX:+PrintGCDetails -XX:+PrintGCTimeStamps"</span> <span class="se">\ </span>
  <span class="nt">--conf</span> spark.hadoop.abc.def<span class="o">=</span>xyz <span class="se">\</span>
  <span class="nt">--conf</span> spark.hive.abc<span class="o">=</span>xyz
  myApp.jar</code></pre></figure>

<h1 id="custom-resource-scheduling-and-configuration-overview">Custom Resource Scheduling and Configuration Overview</h1>

<p>GPUs and other accelerators have been widely used for accelerating special workloads, e.g.,
deep learning and signal processing. Spark now supports requesting and scheduling generic resources, such as GPUs, with a few caveats. The current implementation requires that the resource have addresses that can be allocated by the scheduler. It requires your cluster manager to support and be properly configured with the resources.</p>

<p>There are configurations available to request resources for the driver: <code>spark.driver.resource.{resourceName}.amount</code>, request resources for the executor(s): <code>spark.executor.resource.{resourceName}.amount</code> and specify the requirements for each task: <code>spark.task.resource.{resourceName}.amount</code>. The <code>spark.driver.resource.{resourceName}.discoveryScript</code> config is required on YARN, Kubernetes and a client side Driver on Spark Standalone. <code>spark.executor.resource.{resourceName}.discoveryScript</code> config is required for YARN and Kubernetes. Kubernetes also requires <code>spark.driver.resource.{resourceName}.vendor</code> and/or <code>spark.executor.resource.{resourceName}.vendor</code>. See the config descriptions above for more information on each.</p>

<p>Spark will use the configurations specified to first request containers with the corresponding resources from the cluster manager. Once it gets the container, Spark launches an Executor in that container which will discover what resources the container has and the addresses associated with each resource. The Executor will register with the Driver and report back the resources available to that Executor. The Spark scheduler can then schedule tasks to each Executor and assign specific resource addresses based on the resource requirements the user specified. The user can see the resources assigned to a task using the <code>TaskContext.get().resources</code> api. On the driver, the user can see the resources assigned with the SparkContext <code>resources</code> call. It&#8217;s then up to the user to use the assignedaddresses to do the processing they want or pass those into the ML/AI framework they are using.</p>

<p>See your cluster manager specific page for requirements and details on each of - <a href="running-on-yarn.html#resource-allocation-and-configuration-overview">YARN</a>, <a href="running-on-kubernetes.html#resource-allocation-and-configuration-overview">Kubernetes</a> and <a href="spark-standalone.html#resource-allocation-and-configuration-overview">Standalone Mode</a>. It is currently not available with Mesos or local mode. And please also note that local-cluster mode with multiple workers is not supported(see Standalone documentation).</p>

<h1 id="stage-level-scheduling-overview">Stage Level Scheduling Overview</h1>

<p>The stage level scheduling feature allows users to specify task and executor resource requirements at the stage level. This allows for different stages to run with executors that have different resources. A prime example of this is one ETL stage runs with executors with just CPUs, the next stage is an ML stage that needs GPUs. Stage level scheduling allows for user to request different executors that have GPUs when the ML stage runs rather then having to acquire executors with GPUs at the start of the application and them be idle while the ETL stage is being run.
This is only available for the RDD API in Scala, Java, and Python.  It is available on YARN and Kubernetes when dynamic allocation is enabled. See the <a href="running-on-yarn.html#stage-level-scheduling-overview">YARN</a> page or <a href="running-on-kubernetes.html#stage-level-scheduling-overview">Kubernetes</a> page for more implementation details.</p>

<p>See the <code class="language-plaintext highlighter-rouge">RDD.withResources</code> and <code class="language-plaintext highlighter-rouge">ResourceProfileBuilder</code> API&#8217;s for using this feature. The current implementation acquires new executors for each <code class="language-plaintext highlighter-rouge">ResourceProfile</code>  created and currently has to be an exact match. Spark does not try to fit tasks into an executor that require a different ResourceProfile than the executor was created with. Executors that are not in use will idle timeout with the dynamic allocation logic. The default configuration for this feature is to only allow one ResourceProfile per stage. If the user associates more then 1 ResourceProfile to an RDD, Spark will throw an exception by default. See config <code class="language-plaintext highlighter-rouge">spark.scheduler.resource.profileMergeConflicts</code> to control that behavior. The current merge strategy Spark implements when <code class="language-plaintext highlighter-rouge">spark.scheduler.resource.profileMergeConflicts</code> is enabled is a simple max of each resource within the conflicting ResourceProfiles. Spark will create a new ResourceProfile with the max of each of the resources.</p>


                </div>
            
             <!-- /container -->
        </div>

        <script src="js/vendor/jquery-3.5.1.min.js"></script>
        <script src="js/vendor/bootstrap.bundle.min.js"></script>
        <script src="js/vendor/anchor.min.js"></script>
        <script src="js/main.js"></script>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
        <script type="text/javascript">
            // DocSearch is entirely free and automated. DocSearch is built in two parts:
            // 1. a crawler which we run on our own infrastructure every 24 hours. It follows every link
            //    in your website and extract content from every page it traverses. It then pushes this
            //    content to an Algolia index.
            // 2. a JavaScript snippet to be inserted in your website that will bind this Algolia index
            //    to your search input and display its results in a dropdown UI. If you want to find more
            //    details on how works DocSearch, check the docs of DocSearch.
            docsearch({
    apiKey: 'b18ca3732c502995563043aa17bc6ecb',
    indexName: 'apache_spark',
    inputSelector: '#docsearch-input',
    enhancedSearchInput: true,
    algoliaOptions: {
      'facetFilters': ["version:3.1.2"]
    },
    debug: false // Set debug to true if you want to inspect the dropdown
});

        </script>

        <!-- MathJax Section -->
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({
                TeX: { equationNumbers: { autoNumber: "AMS" } }
            });
        </script>
        <script>
            // Note that we load MathJax this way to work with local file (file://), HTTP and HTTPS.
            // We could use "//cdn.mathjax...", but that won't support "file://".
            (function(d, script) {
                script = d.createElement('script');
                script.type = 'text/javascript';
                script.async = true;
                script.onload = function(){
                    MathJax.Hub.Config({
                        tex2jax: {
                            inlineMath: [ ["$", "$"], ["\\\\(","\\\\)"] ],
                            displayMath: [ ["$$","$$"], ["\\[", "\\]"] ],
                            processEscapes: true,
                            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
                        }
                    });
                };
                script.src = ('https:' == document.location.protocol ? 'https://' : 'http://') +
                    'cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js' +
                    '?config=TeX-AMS-MML_HTMLorMML';
                d.getElementsByTagName('head')[0].appendChild(script);
            }(document));
        </script>
    </body>
</html>
