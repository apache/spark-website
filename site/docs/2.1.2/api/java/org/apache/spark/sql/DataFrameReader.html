<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.7.0_151) on Mon Oct 02 14:47:15 PDT 2017 -->
<title>DataFrameReader (Spark 2.1.2 JavaDoc)</title>
<meta name="date" content="2017-10-02">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="DataFrameReader (Spark 2.1.2 JavaDoc)";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../org/apache/spark/sql/DataFrameNaFunctions.html" title="class in org.apache.spark.sql"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../../org/apache/spark/sql/DataFrameStatFunctions.html" title="class in org.apache.spark.sql"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?org/apache/spark/sql/DataFrameReader.html" target="_top">Frames</a></li>
<li><a href="DataFrameReader.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.apache.spark.sql</div>
<h2 title="Class DataFrameReader" class="title">Class DataFrameReader</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>Object</li>
<li>
<ul class="inheritance">
<li>org.apache.spark.sql.DataFrameReader</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="strong">DataFrameReader</span>
extends Object</pre>
<div class="block">Interface used to load a <a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> from external storage systems (e.g. file systems,
 key-value stores, etc). Use <code>SparkSession.read</code> to access this.
 <p></div>
<dl><dt><span class="strong">Since:</span></dt>
  <dd>1.4.0</dd></dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#csv(scala.collection.Seq)">csv</a></strong>(scala.collection.Seq&lt;String&gt;&nbsp;paths)</code>
<div class="block">Loads a CSV file and returns the result as a <code>DataFrame</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#csv(java.lang.String...)">csv</a></strong>(String...&nbsp;paths)</code>
<div class="block">Loads a CSV file and returns the result as a <code>DataFrame</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#csv(java.lang.String)">csv</a></strong>(String&nbsp;path)</code>
<div class="block">Loads a CSV file and returns the result as a <code>DataFrame</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/DataFrameReader.html" title="class in org.apache.spark.sql">DataFrameReader</a></code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#format(java.lang.String)">format</a></strong>(String&nbsp;source)</code>
<div class="block">Specifies the input data source format.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#jdbc(java.lang.String,%20java.lang.String,%20java.util.Properties)">jdbc</a></strong>(String&nbsp;url,
    String&nbsp;table,
    java.util.Properties&nbsp;properties)</code>
<div class="block">Construct a <code>DataFrame</code> representing the database table accessible via JDBC URL
 url named table and connection properties.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#jdbc(java.lang.String,%20java.lang.String,%20java.lang.String[],%20java.util.Properties)">jdbc</a></strong>(String&nbsp;url,
    String&nbsp;table,
    String[]&nbsp;predicates,
    java.util.Properties&nbsp;connectionProperties)</code>
<div class="block">Construct a <code>DataFrame</code> representing the database table accessible via JDBC URL
 url named table using connection properties.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#jdbc(java.lang.String,%20java.lang.String,%20java.lang.String,%20long,%20long,%20int,%20java.util.Properties)">jdbc</a></strong>(String&nbsp;url,
    String&nbsp;table,
    String&nbsp;columnName,
    long&nbsp;lowerBound,
    long&nbsp;upperBound,
    int&nbsp;numPartitions,
    java.util.Properties&nbsp;connectionProperties)</code>
<div class="block">Construct a <code>DataFrame</code> representing the database table accessible via JDBC URL
 url named table.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#json(org.apache.spark.api.java.JavaRDD)">json</a></strong>(<a href="../../../../org/apache/spark/api/java/JavaRDD.html" title="class in org.apache.spark.api.java">JavaRDD</a>&lt;String&gt;&nbsp;jsonRDD)</code>
<div class="block">Loads a <code>JavaRDD[String]</code> storing JSON objects (<a href="http://jsonlines.org/">JSON
 Lines text format or newline-delimited JSON</a>) and returns the result as
 a <code>DataFrame</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#json(org.apache.spark.rdd.RDD)">json</a></strong>(<a href="../../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</a>&lt;String&gt;&nbsp;jsonRDD)</code>
<div class="block">Loads an <code>RDD[String]</code> storing JSON objects (<a href="http://jsonlines.org/">JSON Lines
 text format or newline-delimited JSON</a>) and returns the result as a <code>DataFrame</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#json(scala.collection.Seq)">json</a></strong>(scala.collection.Seq&lt;String&gt;&nbsp;paths)</code>
<div class="block">Loads a JSON file (<a href="http://jsonlines.org/">JSON Lines text format or
 newline-delimited JSON</a>) and returns the result as a <code>DataFrame</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#json(java.lang.String...)">json</a></strong>(String...&nbsp;paths)</code>
<div class="block">Loads a JSON file (<a href="http://jsonlines.org/">JSON Lines text format or
 newline-delimited JSON</a>) and returns the result as a <code>DataFrame</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#json(java.lang.String)">json</a></strong>(String&nbsp;path)</code>
<div class="block">Loads a JSON file (<a href="http://jsonlines.org/">JSON Lines text format or
 newline-delimited JSON</a>) and returns the result as a <code>DataFrame</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#load()">load</a></strong>()</code>
<div class="block">Loads input in as a <code>DataFrame</code>, for data sources that don't require a path (e.g.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#load(scala.collection.Seq)">load</a></strong>(scala.collection.Seq&lt;String&gt;&nbsp;paths)</code>
<div class="block">Loads input in as a <code>DataFrame</code>, for data sources that support multiple paths.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#load(java.lang.String...)">load</a></strong>(String...&nbsp;paths)</code>
<div class="block">Loads input in as a <code>DataFrame</code>, for data sources that support multiple paths.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#load(java.lang.String)">load</a></strong>(String&nbsp;path)</code>
<div class="block">Loads input in as a <code>DataFrame</code>, for data sources that require a path (e.g.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/DataFrameReader.html" title="class in org.apache.spark.sql">DataFrameReader</a></code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#option(java.lang.String,%20boolean)">option</a></strong>(String&nbsp;key,
      boolean&nbsp;value)</code>
<div class="block">Adds an input option for the underlying data source.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/DataFrameReader.html" title="class in org.apache.spark.sql">DataFrameReader</a></code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#option(java.lang.String,%20double)">option</a></strong>(String&nbsp;key,
      double&nbsp;value)</code>
<div class="block">Adds an input option for the underlying data source.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/DataFrameReader.html" title="class in org.apache.spark.sql">DataFrameReader</a></code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#option(java.lang.String,%20long)">option</a></strong>(String&nbsp;key,
      long&nbsp;value)</code>
<div class="block">Adds an input option for the underlying data source.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/DataFrameReader.html" title="class in org.apache.spark.sql">DataFrameReader</a></code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#option(java.lang.String,%20java.lang.String)">option</a></strong>(String&nbsp;key,
      String&nbsp;value)</code>
<div class="block">Adds an input option for the underlying data source.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/DataFrameReader.html" title="class in org.apache.spark.sql">DataFrameReader</a></code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#options(scala.collection.Map)">options</a></strong>(scala.collection.Map&lt;String,String&gt;&nbsp;options)</code>
<div class="block">(Scala-specific) Adds input options for the underlying data source.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/DataFrameReader.html" title="class in org.apache.spark.sql">DataFrameReader</a></code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#options(java.util.Map)">options</a></strong>(java.util.Map&lt;String,String&gt;&nbsp;options)</code>
<div class="block">Adds input options for the underlying data source.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#orc(scala.collection.Seq)">orc</a></strong>(scala.collection.Seq&lt;String&gt;&nbsp;paths)</code>
<div class="block">Loads an ORC file and returns the result as a <code>DataFrame</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#orc(java.lang.String...)">orc</a></strong>(String...&nbsp;paths)</code>
<div class="block">Loads an ORC file and returns the result as a <code>DataFrame</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#orc(java.lang.String)">orc</a></strong>(String&nbsp;path)</code>
<div class="block">Loads an ORC file and returns the result as a <code>DataFrame</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#parquet(scala.collection.Seq)">parquet</a></strong>(scala.collection.Seq&lt;String&gt;&nbsp;paths)</code>
<div class="block">Loads a Parquet file, returning the result as a <code>DataFrame</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#parquet(java.lang.String...)">parquet</a></strong>(String...&nbsp;paths)</code>
<div class="block">Loads a Parquet file, returning the result as a <code>DataFrame</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#parquet(java.lang.String)">parquet</a></strong>(String&nbsp;path)</code>
<div class="block">Loads a Parquet file, returning the result as a <code>DataFrame</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/DataFrameReader.html" title="class in org.apache.spark.sql">DataFrameReader</a></code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#schema(org.apache.spark.sql.types.StructType)">schema</a></strong>(<a href="../../../../org/apache/spark/sql/types/StructType.html" title="class in org.apache.spark.sql.types">StructType</a>&nbsp;schema)</code>
<div class="block">Specifies the input schema.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#table(java.lang.String)">table</a></strong>(String&nbsp;tableName)</code>
<div class="block">Returns the specified table as a <code>DataFrame</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#text(scala.collection.Seq)">text</a></strong>(scala.collection.Seq&lt;String&gt;&nbsp;paths)</code>
<div class="block">Loads text files and returns a <code>DataFrame</code> whose schema starts with a string column named
 "value", and followed by partitioned columns if there are any.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#text(java.lang.String...)">text</a></strong>(String...&nbsp;paths)</code>
<div class="block">Loads text files and returns a <code>DataFrame</code> whose schema starts with a string column named
 "value", and followed by partitioned columns if there are any.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#text(java.lang.String)">text</a></strong>(String&nbsp;path)</code>
<div class="block">Loads text files and returns a <code>DataFrame</code> whose schema starts with a string column named
 "value", and followed by partitioned columns if there are any.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;String&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#textFile(scala.collection.Seq)">textFile</a></strong>(scala.collection.Seq&lt;String&gt;&nbsp;paths)</code>
<div class="block">Loads text files and returns a <a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> of String.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;String&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#textFile(java.lang.String...)">textFile</a></strong>(String...&nbsp;paths)</code>
<div class="block">Loads text files and returns a <a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> of String.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;String&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../../org/apache/spark/sql/DataFrameReader.html#textFile(java.lang.String)">textFile</a></strong>(String&nbsp;path)</code>
<div class="block">Loads text files and returns a <a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> of String.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="load(java.lang.String...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>load</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;load(String...&nbsp;paths)</pre>
<div class="block">Loads input in as a <code>DataFrame</code>, for data sources that support multiple paths.
 Only works if the source is a HadoopFsRelationProvider.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>paths</code> - (undocumented)</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6.0</dd></dl>
</li>
</ul>
<a name="json(java.lang.String...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>json</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;json(String...&nbsp;paths)</pre>
<div class="block">Loads a JSON file (<a href="http://jsonlines.org/">JSON Lines text format or
 newline-delimited JSON</a>) and returns the result as a <code>DataFrame</code>.
 <p>
 This function goes through the input once to determine the input schema. If you know the
 schema in advance, use the version that specifies the schema to avoid the extra scan.
 <p>
 You can set the following JSON-specific options to deal with non-standard JSON files:
 <ul>
 <li><code>primitivesAsString</code> (default <code>false</code>): infers all primitive values as a string type</li>
 <li><code>prefersDecimal</code> (default <code>false</code>): infers all floating-point values as a decimal
 type. If the values do not fit in decimal, then it infers them as doubles.</li>
 <li><code>allowComments</code> (default <code>false</code>): ignores Java/C++ style comment in JSON records</li>
 <li><code>allowUnquotedFieldNames</code> (default <code>false</code>): allows unquoted JSON field names</li>
 <li><code>allowSingleQuotes</code> (default <code>true</code>): allows single quotes in addition to double quotes
 </li>
 <li><code>allowNumericLeadingZeros</code> (default <code>false</code>): allows leading zeros in numbers
 (e.g. 00012)</li>
 <li><code>allowBackslashEscapingAnyCharacter</code> (default <code>false</code>): allows accepting quoting of all
 character using backslash quoting mechanism</li>
 <li><code>mode</code> (default <code>PERMISSIVE</code>): allows a mode for dealing with corrupt records
 during parsing.
   <ul>
     <li><code>PERMISSIVE</code> : sets other fields to <code>null</code> when it meets a corrupted record, and puts
     the malformed string into a new field configured by <code>columnNameOfCorruptRecord</code>. When
     a schema is set by user, it sets <code>null</code> for extra fields.</li>
     <li><code>DROPMALFORMED</code> : ignores the whole corrupted records.</li>
     <li><code>FAILFAST</code> : throws an exception when it meets corrupted records.</li>
   </ul>
 </li>
 <li><code>columnNameOfCorruptRecord</code> (default is the value specified in
 <code>spark.sql.columnNameOfCorruptRecord</code>): allows renaming the new field having malformed string
 created by <code>PERMISSIVE</code> mode. This overrides <code>spark.sql.columnNameOfCorruptRecord</code>.</li>
 <li><code>dateFormat</code> (default <code>yyyy-MM-dd</code>): sets the string that indicates a date format.
 Custom date formats follow the formats at <code>java.text.SimpleDateFormat</code>. This applies to
 date type.</li>
 <li><code>timestampFormat</code> (default <code>yyyy-MM-dd'T'HH:mm:ss.SSSZZ</code>): sets the string that
 indicates a timestamp format. Custom date formats follow the formats at
 <code>java.text.SimpleDateFormat</code>. This applies to timestamp type.</li>
 </ul>
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>paths</code> - (undocumented)</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>2.0.0</dd></dl>
</li>
</ul>
<a name="csv(java.lang.String...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>csv</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;csv(String...&nbsp;paths)</pre>
<div class="block">Loads a CSV file and returns the result as a <code>DataFrame</code>.
 <p>
 This function will go through the input once to determine the input schema if <code>inferSchema</code>
 is enabled. To avoid going through the entire data once, disable <code>inferSchema</code> option or
 specify the schema explicitly using <code>schema</code>.
 <p>
 You can set the following CSV-specific options to deal with CSV files:
 <ul>
 <li><code>sep</code> (default <code>,</code>): sets the single character as a separator for each
 field and value.</li>
 <li><code>encoding</code> (default <code>UTF-8</code>): decodes the CSV files by the given encoding
 type.</li>
 <li><code>quote</code> (default <code>"</code>): sets the single character used for escaping quoted values where
 the separator can be part of the value. If you would like to turn off quotations, you need to
 set not <code>null</code> but an empty string. This behaviour is different from
 <code>com.databricks.spark.csv</code>.</li>
 <li><code>escape</code> (default <code>\</code>): sets the single character used for escaping quotes inside
 an already quoted value.</li>
 <li><code>comment</code> (default empty string): sets the single character used for skipping lines
 beginning with this character. By default, it is disabled.</li>
 <li><code>header</code> (default <code>false</code>): uses the first line as names of columns.</li>
 <li><code>inferSchema</code> (default <code>false</code>): infers the input schema automatically from data. It
 requires one extra pass over the data.</li>
 <li><code>ignoreLeadingWhiteSpace</code> (default <code>false</code>): defines whether or not leading whitespaces
 from values being read should be skipped.</li>
 <li><code>ignoreTrailingWhiteSpace</code> (default <code>false</code>): defines whether or not trailing
 whitespaces from values being read should be skipped.</li>
 <li><code>nullValue</code> (default empty string): sets the string representation of a null value. Since
 2.0.1, this applies to all supported types including the string type.</li>
 <li><code>nanValue</code> (default <code>NaN</code>): sets the string representation of a non-number" value.</li>
 <li><code>positiveInf</code> (default <code>Inf</code>): sets the string representation of a positive infinity
 value.</li>
 <li><code>negativeInf</code> (default <code>-Inf</code>): sets the string representation of a negative infinity
 value.</li>
 <li><code>dateFormat</code> (default <code>yyyy-MM-dd</code>): sets the string that indicates a date format.
 Custom date formats follow the formats at <code>java.text.SimpleDateFormat</code>. This applies to
 date type.</li>
 <li><code>timestampFormat</code> (default <code>yyyy-MM-dd'T'HH:mm:ss.SSSZZ</code>): sets the string that
 indicates a timestamp format. Custom date formats follow the formats at
 <code>java.text.SimpleDateFormat</code>. This applies to timestamp type.</li>
 <li><code>maxColumns</code> (default <code>20480</code>): defines a hard limit of how many columns
 a record can have.</li>
 <li><code>maxCharsPerColumn</code> (default <code>-1</code>): defines the maximum number of characters allowed
 for any given value being read. By default, it is -1 meaning unlimited length</li>
 <li><code>maxMalformedLogPerPartition</code> (default <code>10</code>): sets the maximum number of malformed rows
 Spark will log for each partition. Malformed records beyond this number will be ignored.</li>
 <li><code>mode</code> (default <code>PERMISSIVE</code>): allows a mode for dealing with corrupt records
    during parsing.
   <ul>
     <li><code>PERMISSIVE</code> : sets other fields to <code>null</code> when it meets a corrupted record. When
       a schema is set by user, it sets <code>null</code> for extra fields.</li>
     <li><code>DROPMALFORMED</code> : ignores the whole corrupted records.</li>
     <li><code>FAILFAST</code> : throws an exception when it meets corrupted records.</li>
   </ul>
 </li>
 </ul></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>paths</code> - (undocumented)</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>2.0.0</dd></dl>
</li>
</ul>
<a name="parquet(java.lang.String...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parquet</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;parquet(String...&nbsp;paths)</pre>
<div class="block">Loads a Parquet file, returning the result as a <code>DataFrame</code>.
 <p>
 You can set the following Parquet-specific option(s) for reading Parquet files:
 <ul>
 <li><code>mergeSchema</code> (default is the value specified in <code>spark.sql.parquet.mergeSchema</code>): sets
 whether we should merge schemas collected from all Parquet part-files. This will override
 <code>spark.sql.parquet.mergeSchema</code>.</li>
 </ul></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>paths</code> - (undocumented)</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.4.0</dd></dl>
</li>
</ul>
<a name="orc(java.lang.String...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>orc</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;orc(String...&nbsp;paths)</pre>
<div class="block">Loads an ORC file and returns the result as a <code>DataFrame</code>.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>paths</code> - input paths</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>2.0.0</dd>
<dt><span class="strong">Note:</span></dt>
  <dd>Currently, this method can only be used after enabling Hive support.</dd></dl>
</li>
</ul>
<a name="text(java.lang.String...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>text</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;text(String...&nbsp;paths)</pre>
<div class="block">Loads text files and returns a <code>DataFrame</code> whose schema starts with a string column named
 "value", and followed by partitioned columns if there are any.
 <p>
 Each line in the text files is a new row in the resulting DataFrame. For example:
 <pre><code>
   // Scala:
   spark.read.text("/path/to/spark/README.md")

   // Java:
   spark.read().text("/path/to/spark/README.md")
 </code></pre>
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>paths</code> - input paths</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6.0</dd></dl>
</li>
</ul>
<a name="textFile(java.lang.String...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>textFile</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;String&gt;&nbsp;textFile(String...&nbsp;paths)</pre>
<div class="block">Loads text files and returns a <a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> of String. The underlying schema of the Dataset
 contains a single string column named "value".
 <p>
 If the directory structure of the text files contains partitioning information, those are
 ignored in the resulting Dataset. To include partitioning information as columns, use <code>text</code>.
 <p>
 Each line in the text files is a new element in the resulting Dataset. For example:
 <pre><code>
   // Scala:
   spark.read.textFile("/path/to/spark/README.md")

   // Java:
   spark.read().textFile("/path/to/spark/README.md")
 </code></pre>
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>paths</code> - input path</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>2.0.0</dd></dl>
</li>
</ul>
<a name="format(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>format</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/DataFrameReader.html" title="class in org.apache.spark.sql">DataFrameReader</a>&nbsp;format(String&nbsp;source)</pre>
<div class="block">Specifies the input data source format.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>source</code> - (undocumented)</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.4.0</dd></dl>
</li>
</ul>
<a name="schema(org.apache.spark.sql.types.StructType)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>schema</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/DataFrameReader.html" title="class in org.apache.spark.sql">DataFrameReader</a>&nbsp;schema(<a href="../../../../org/apache/spark/sql/types/StructType.html" title="class in org.apache.spark.sql.types">StructType</a>&nbsp;schema)</pre>
<div class="block">Specifies the input schema. Some data sources (e.g. JSON) can infer the input schema
 automatically from data. By specifying the schema here, the underlying data source can
 skip the schema inference step, and thus speed up data loading.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>schema</code> - (undocumented)</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.4.0</dd></dl>
</li>
</ul>
<a name="option(java.lang.String, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>option</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/DataFrameReader.html" title="class in org.apache.spark.sql">DataFrameReader</a>&nbsp;option(String&nbsp;key,
                     String&nbsp;value)</pre>
<div class="block">Adds an input option for the underlying data source.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>key</code> - (undocumented)</dd><dd><code>value</code> - (undocumented)</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.4.0</dd></dl>
</li>
</ul>
<a name="option(java.lang.String, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>option</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/DataFrameReader.html" title="class in org.apache.spark.sql">DataFrameReader</a>&nbsp;option(String&nbsp;key,
                     boolean&nbsp;value)</pre>
<div class="block">Adds an input option for the underlying data source.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>key</code> - (undocumented)</dd><dd><code>value</code> - (undocumented)</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>2.0.0</dd></dl>
</li>
</ul>
<a name="option(java.lang.String, long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>option</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/DataFrameReader.html" title="class in org.apache.spark.sql">DataFrameReader</a>&nbsp;option(String&nbsp;key,
                     long&nbsp;value)</pre>
<div class="block">Adds an input option for the underlying data source.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>key</code> - (undocumented)</dd><dd><code>value</code> - (undocumented)</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>2.0.0</dd></dl>
</li>
</ul>
<a name="option(java.lang.String, double)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>option</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/DataFrameReader.html" title="class in org.apache.spark.sql">DataFrameReader</a>&nbsp;option(String&nbsp;key,
                     double&nbsp;value)</pre>
<div class="block">Adds an input option for the underlying data source.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>key</code> - (undocumented)</dd><dd><code>value</code> - (undocumented)</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>2.0.0</dd></dl>
</li>
</ul>
<a name="options(scala.collection.Map)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>options</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/DataFrameReader.html" title="class in org.apache.spark.sql">DataFrameReader</a>&nbsp;options(scala.collection.Map&lt;String,String&gt;&nbsp;options)</pre>
<div class="block">(Scala-specific) Adds input options for the underlying data source.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>options</code> - (undocumented)</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.4.0</dd></dl>
</li>
</ul>
<a name="options(java.util.Map)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>options</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/DataFrameReader.html" title="class in org.apache.spark.sql">DataFrameReader</a>&nbsp;options(java.util.Map&lt;String,String&gt;&nbsp;options)</pre>
<div class="block">Adds input options for the underlying data source.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>options</code> - (undocumented)</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.4.0</dd></dl>
</li>
</ul>
<a name="load()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>load</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;load()</pre>
<div class="block">Loads input in as a <code>DataFrame</code>, for data sources that don't require a path (e.g. external
 key-value stores).
 <p></div>
<dl><dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.4.0</dd></dl>
</li>
</ul>
<a name="load(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>load</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;load(String&nbsp;path)</pre>
<div class="block">Loads input in as a <code>DataFrame</code>, for data sources that require a path (e.g. data backed by
 a local or distributed file system).
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>path</code> - (undocumented)</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.4.0</dd></dl>
</li>
</ul>
<a name="load(scala.collection.Seq)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>load</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;load(scala.collection.Seq&lt;String&gt;&nbsp;paths)</pre>
<div class="block">Loads input in as a <code>DataFrame</code>, for data sources that support multiple paths.
 Only works if the source is a HadoopFsRelationProvider.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>paths</code> - (undocumented)</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6.0</dd></dl>
</li>
</ul>
<a name="jdbc(java.lang.String, java.lang.String, java.util.Properties)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>jdbc</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;jdbc(String&nbsp;url,
                String&nbsp;table,
                java.util.Properties&nbsp;properties)</pre>
<div class="block">Construct a <code>DataFrame</code> representing the database table accessible via JDBC URL
 url named table and connection properties.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>url</code> - (undocumented)</dd><dd><code>table</code> - (undocumented)</dd><dd><code>properties</code> - (undocumented)</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.4.0</dd></dl>
</li>
</ul>
<a name="jdbc(java.lang.String, java.lang.String, java.lang.String, long, long, int, java.util.Properties)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>jdbc</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;jdbc(String&nbsp;url,
                String&nbsp;table,
                String&nbsp;columnName,
                long&nbsp;lowerBound,
                long&nbsp;upperBound,
                int&nbsp;numPartitions,
                java.util.Properties&nbsp;connectionProperties)</pre>
<div class="block">Construct a <code>DataFrame</code> representing the database table accessible via JDBC URL
 url named table. Partitions of the table will be retrieved in parallel based on the parameters
 passed to this function.
 <p>
 Don't create too many partitions in parallel on a large cluster; otherwise Spark might crash
 your external database systems.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>url</code> - JDBC database url of the form <code>jdbc:subprotocol:subname</code>.</dd><dd><code>table</code> - Name of the table in the external database.</dd><dd><code>columnName</code> - the name of a column of integral type that will be used for partitioning.</dd><dd><code>lowerBound</code> - the minimum value of <code>columnName</code> used to decide partition stride.</dd><dd><code>upperBound</code> - the maximum value of <code>columnName</code> used to decide partition stride.</dd><dd><code>numPartitions</code> - the number of partitions. This, along with <code>lowerBound</code> (inclusive),
                      <code>upperBound</code> (exclusive), form partition strides for generated WHERE
                      clause expressions used to split the column <code>columnName</code> evenly. When
                      the input is less than 1, the number is set to 1.</dd><dd><code>connectionProperties</code> - JDBC database connection arguments, a list of arbitrary string
                             tag/value. Normally at least a "user" and "password" property
                             should be included. "fetchsize" can be used to control the
                             number of rows per fetch.</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.4.0</dd></dl>
</li>
</ul>
<a name="jdbc(java.lang.String, java.lang.String, java.lang.String[], java.util.Properties)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>jdbc</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;jdbc(String&nbsp;url,
                String&nbsp;table,
                String[]&nbsp;predicates,
                java.util.Properties&nbsp;connectionProperties)</pre>
<div class="block">Construct a <code>DataFrame</code> representing the database table accessible via JDBC URL
 url named table using connection properties. The <code>predicates</code> parameter gives a list
 expressions suitable for inclusion in WHERE clauses; each one defines one partition
 of the <code>DataFrame</code>.
 <p>
 Don't create too many partitions in parallel on a large cluster; otherwise Spark might crash
 your external database systems.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>url</code> - JDBC database url of the form <code>jdbc:subprotocol:subname</code></dd><dd><code>table</code> - Name of the table in the external database.</dd><dd><code>predicates</code> - Condition in the where clause for each partition.</dd><dd><code>connectionProperties</code> - JDBC database connection arguments, a list of arbitrary string
                             tag/value. Normally at least a "user" and "password" property
                             should be included. "fetchsize" can be used to control the
                             number of rows per fetch.</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.4.0</dd></dl>
</li>
</ul>
<a name="json(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>json</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;json(String&nbsp;path)</pre>
<div class="block">Loads a JSON file (<a href="http://jsonlines.org/">JSON Lines text format or
 newline-delimited JSON</a>) and returns the result as a <code>DataFrame</code>.
 See the documentation on the overloaded <code>json()</code> method with varargs for more details.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>path</code> - (undocumented)</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.4.0</dd></dl>
</li>
</ul>
<a name="json(scala.collection.Seq)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>json</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;json(scala.collection.Seq&lt;String&gt;&nbsp;paths)</pre>
<div class="block">Loads a JSON file (<a href="http://jsonlines.org/">JSON Lines text format or
 newline-delimited JSON</a>) and returns the result as a <code>DataFrame</code>.
 <p>
 This function goes through the input once to determine the input schema. If you know the
 schema in advance, use the version that specifies the schema to avoid the extra scan.
 <p>
 You can set the following JSON-specific options to deal with non-standard JSON files:
 <ul>
 <li><code>primitivesAsString</code> (default <code>false</code>): infers all primitive values as a string type</li>
 <li><code>prefersDecimal</code> (default <code>false</code>): infers all floating-point values as a decimal
 type. If the values do not fit in decimal, then it infers them as doubles.</li>
 <li><code>allowComments</code> (default <code>false</code>): ignores Java/C++ style comment in JSON records</li>
 <li><code>allowUnquotedFieldNames</code> (default <code>false</code>): allows unquoted JSON field names</li>
 <li><code>allowSingleQuotes</code> (default <code>true</code>): allows single quotes in addition to double quotes
 </li>
 <li><code>allowNumericLeadingZeros</code> (default <code>false</code>): allows leading zeros in numbers
 (e.g. 00012)</li>
 <li><code>allowBackslashEscapingAnyCharacter</code> (default <code>false</code>): allows accepting quoting of all
 character using backslash quoting mechanism</li>
 <li><code>mode</code> (default <code>PERMISSIVE</code>): allows a mode for dealing with corrupt records
 during parsing.
   <ul>
     <li><code>PERMISSIVE</code> : sets other fields to <code>null</code> when it meets a corrupted record, and puts
     the malformed string into a new field configured by <code>columnNameOfCorruptRecord</code>. When
     a schema is set by user, it sets <code>null</code> for extra fields.</li>
     <li><code>DROPMALFORMED</code> : ignores the whole corrupted records.</li>
     <li><code>FAILFAST</code> : throws an exception when it meets corrupted records.</li>
   </ul>
 </li>
 <li><code>columnNameOfCorruptRecord</code> (default is the value specified in
 <code>spark.sql.columnNameOfCorruptRecord</code>): allows renaming the new field having malformed string
 created by <code>PERMISSIVE</code> mode. This overrides <code>spark.sql.columnNameOfCorruptRecord</code>.</li>
 <li><code>dateFormat</code> (default <code>yyyy-MM-dd</code>): sets the string that indicates a date format.
 Custom date formats follow the formats at <code>java.text.SimpleDateFormat</code>. This applies to
 date type.</li>
 <li><code>timestampFormat</code> (default <code>yyyy-MM-dd'T'HH:mm:ss.SSSZZ</code>): sets the string that
 indicates a timestamp format. Custom date formats follow the formats at
 <code>java.text.SimpleDateFormat</code>. This applies to timestamp type.</li>
 </ul>
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>paths</code> - (undocumented)</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>2.0.0</dd></dl>
</li>
</ul>
<a name="json(org.apache.spark.api.java.JavaRDD)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>json</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;json(<a href="../../../../org/apache/spark/api/java/JavaRDD.html" title="class in org.apache.spark.api.java">JavaRDD</a>&lt;String&gt;&nbsp;jsonRDD)</pre>
<div class="block">Loads a <code>JavaRDD[String]</code> storing JSON objects (<a href="http://jsonlines.org/">JSON
 Lines text format or newline-delimited JSON</a>) and returns the result as
 a <code>DataFrame</code>.
 <p>
 Unless the schema is specified using <code>schema</code> function, this function goes through the
 input once to determine the input schema.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>jsonRDD</code> - input RDD with one JSON object per record</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.4.0</dd></dl>
</li>
</ul>
<a name="json(org.apache.spark.rdd.RDD)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>json</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;json(<a href="../../../../org/apache/spark/rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</a>&lt;String&gt;&nbsp;jsonRDD)</pre>
<div class="block">Loads an <code>RDD[String]</code> storing JSON objects (<a href="http://jsonlines.org/">JSON Lines
 text format or newline-delimited JSON</a>) and returns the result as a <code>DataFrame</code>.
 <p>
 Unless the schema is specified using <code>schema</code> function, this function goes through the
 input once to determine the input schema.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>jsonRDD</code> - input RDD with one JSON object per record</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.4.0</dd></dl>
</li>
</ul>
<a name="csv(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>csv</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;csv(String&nbsp;path)</pre>
<div class="block">Loads a CSV file and returns the result as a <code>DataFrame</code>. See the documentation on the
 other overloaded <code>csv()</code> method for more details.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>path</code> - (undocumented)</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>2.0.0</dd></dl>
</li>
</ul>
<a name="csv(scala.collection.Seq)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>csv</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;csv(scala.collection.Seq&lt;String&gt;&nbsp;paths)</pre>
<div class="block">Loads a CSV file and returns the result as a <code>DataFrame</code>.
 <p>
 This function will go through the input once to determine the input schema if <code>inferSchema</code>
 is enabled. To avoid going through the entire data once, disable <code>inferSchema</code> option or
 specify the schema explicitly using <code>schema</code>.
 <p>
 You can set the following CSV-specific options to deal with CSV files:
 <ul>
 <li><code>sep</code> (default <code>,</code>): sets the single character as a separator for each
 field and value.</li>
 <li><code>encoding</code> (default <code>UTF-8</code>): decodes the CSV files by the given encoding
 type.</li>
 <li><code>quote</code> (default <code>"</code>): sets the single character used for escaping quoted values where
 the separator can be part of the value. If you would like to turn off quotations, you need to
 set not <code>null</code> but an empty string. This behaviour is different from
 <code>com.databricks.spark.csv</code>.</li>
 <li><code>escape</code> (default <code>\</code>): sets the single character used for escaping quotes inside
 an already quoted value.</li>
 <li><code>comment</code> (default empty string): sets the single character used for skipping lines
 beginning with this character. By default, it is disabled.</li>
 <li><code>header</code> (default <code>false</code>): uses the first line as names of columns.</li>
 <li><code>inferSchema</code> (default <code>false</code>): infers the input schema automatically from data. It
 requires one extra pass over the data.</li>
 <li><code>ignoreLeadingWhiteSpace</code> (default <code>false</code>): defines whether or not leading whitespaces
 from values being read should be skipped.</li>
 <li><code>ignoreTrailingWhiteSpace</code> (default <code>false</code>): defines whether or not trailing
 whitespaces from values being read should be skipped.</li>
 <li><code>nullValue</code> (default empty string): sets the string representation of a null value. Since
 2.0.1, this applies to all supported types including the string type.</li>
 <li><code>nanValue</code> (default <code>NaN</code>): sets the string representation of a non-number" value.</li>
 <li><code>positiveInf</code> (default <code>Inf</code>): sets the string representation of a positive infinity
 value.</li>
 <li><code>negativeInf</code> (default <code>-Inf</code>): sets the string representation of a negative infinity
 value.</li>
 <li><code>dateFormat</code> (default <code>yyyy-MM-dd</code>): sets the string that indicates a date format.
 Custom date formats follow the formats at <code>java.text.SimpleDateFormat</code>. This applies to
 date type.</li>
 <li><code>timestampFormat</code> (default <code>yyyy-MM-dd'T'HH:mm:ss.SSSZZ</code>): sets the string that
 indicates a timestamp format. Custom date formats follow the formats at
 <code>java.text.SimpleDateFormat</code>. This applies to timestamp type.</li>
 <li><code>maxColumns</code> (default <code>20480</code>): defines a hard limit of how many columns
 a record can have.</li>
 <li><code>maxCharsPerColumn</code> (default <code>-1</code>): defines the maximum number of characters allowed
 for any given value being read. By default, it is -1 meaning unlimited length</li>
 <li><code>maxMalformedLogPerPartition</code> (default <code>10</code>): sets the maximum number of malformed rows
 Spark will log for each partition. Malformed records beyond this number will be ignored.</li>
 <li><code>mode</code> (default <code>PERMISSIVE</code>): allows a mode for dealing with corrupt records
    during parsing.
   <ul>
     <li><code>PERMISSIVE</code> : sets other fields to <code>null</code> when it meets a corrupted record. When
       a schema is set by user, it sets <code>null</code> for extra fields.</li>
     <li><code>DROPMALFORMED</code> : ignores the whole corrupted records.</li>
     <li><code>FAILFAST</code> : throws an exception when it meets corrupted records.</li>
   </ul>
 </li>
 </ul></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>paths</code> - (undocumented)</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>2.0.0</dd></dl>
</li>
</ul>
<a name="parquet(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parquet</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;parquet(String&nbsp;path)</pre>
<div class="block">Loads a Parquet file, returning the result as a <code>DataFrame</code>. See the documentation
 on the other overloaded <code>parquet()</code> method for more details.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>path</code> - (undocumented)</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>2.0.0</dd></dl>
</li>
</ul>
<a name="parquet(scala.collection.Seq)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parquet</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;parquet(scala.collection.Seq&lt;String&gt;&nbsp;paths)</pre>
<div class="block">Loads a Parquet file, returning the result as a <code>DataFrame</code>.
 <p>
 You can set the following Parquet-specific option(s) for reading Parquet files:
 <ul>
 <li><code>mergeSchema</code> (default is the value specified in <code>spark.sql.parquet.mergeSchema</code>): sets
 whether we should merge schemas collected from all Parquet part-files. This will override
 <code>spark.sql.parquet.mergeSchema</code>.</li>
 </ul></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>paths</code> - (undocumented)</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.4.0</dd></dl>
</li>
</ul>
<a name="orc(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>orc</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;orc(String&nbsp;path)</pre>
<div class="block">Loads an ORC file and returns the result as a <code>DataFrame</code>.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>path</code> - input path</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.5.0</dd>
<dt><span class="strong">Note:</span></dt>
  <dd>Currently, this method can only be used after enabling Hive support.</dd></dl>
</li>
</ul>
<a name="orc(scala.collection.Seq)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>orc</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;orc(scala.collection.Seq&lt;String&gt;&nbsp;paths)</pre>
<div class="block">Loads an ORC file and returns the result as a <code>DataFrame</code>.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>paths</code> - input paths</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>2.0.0</dd>
<dt><span class="strong">Note:</span></dt>
  <dd>Currently, this method can only be used after enabling Hive support.</dd></dl>
</li>
</ul>
<a name="table(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>table</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;table(String&nbsp;tableName)</pre>
<div class="block">Returns the specified table as a <code>DataFrame</code>.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>tableName</code> - (undocumented)</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.4.0</dd></dl>
</li>
</ul>
<a name="text(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>text</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;text(String&nbsp;path)</pre>
<div class="block">Loads text files and returns a <code>DataFrame</code> whose schema starts with a string column named
 "value", and followed by partitioned columns if there are any. See the documentation on
 the other overloaded <code>text()</code> method for more details.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>path</code> - (undocumented)</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>2.0.0</dd></dl>
</li>
</ul>
<a name="text(scala.collection.Seq)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>text</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;text(scala.collection.Seq&lt;String&gt;&nbsp;paths)</pre>
<div class="block">Loads text files and returns a <code>DataFrame</code> whose schema starts with a string column named
 "value", and followed by partitioned columns if there are any.
 <p>
 Each line in the text files is a new row in the resulting DataFrame. For example:
 <pre><code>
   // Scala:
   spark.read.text("/path/to/spark/README.md")

   // Java:
   spark.read().text("/path/to/spark/README.md")
 </code></pre>
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>paths</code> - input paths</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.6.0</dd></dl>
</li>
</ul>
<a name="textFile(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>textFile</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;String&gt;&nbsp;textFile(String&nbsp;path)</pre>
<div class="block">Loads text files and returns a <a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> of String. See the documentation on the
 other overloaded <code>textFile()</code> method for more details.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>path</code> - (undocumented)</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>2.0.0</dd></dl>
</li>
</ul>
<a name="textFile(scala.collection.Seq)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>textFile</h4>
<pre>public&nbsp;<a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;String&gt;&nbsp;textFile(scala.collection.Seq&lt;String&gt;&nbsp;paths)</pre>
<div class="block">Loads text files and returns a <a href="../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> of String. The underlying schema of the Dataset
 contains a single string column named "value".
 <p>
 If the directory structure of the text files contains partitioning information, those are
 ignored in the resulting Dataset. To include partitioning information as columns, use <code>text</code>.
 <p>
 Each line in the text files is a new element in the resulting Dataset. For example:
 <pre><code>
   // Scala:
   spark.read.textFile("/path/to/spark/README.md")

   // Java:
   spark.read().textFile("/path/to/spark/README.md")
 </code></pre>
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>paths</code> - input path</dd>
<dt><span class="strong">Returns:</span></dt><dd>(undocumented)</dd><dt><span class="strong">Since:</span></dt>
  <dd>2.0.0</dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../org/apache/spark/sql/DataFrameNaFunctions.html" title="class in org.apache.spark.sql"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../../org/apache/spark/sql/DataFrameStatFunctions.html" title="class in org.apache.spark.sql"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?org/apache/spark/sql/DataFrameReader.html" target="_top">Frames</a></li>
<li><a href="DataFrameReader.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<script defer="defer" type="text/javascript" src="../../../../lib/jquery.js"></script><script defer="defer" type="text/javascript" src="../../../../lib/api-javadocs.js"></script></body>
</html>
