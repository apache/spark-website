<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pyspark.sql.streaming &#8212; PySpark 2.1.2 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pyspark.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '2.1.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/pyspark.js"></script>
    <link rel="top" title="PySpark 2.1.2 documentation" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
    
        <li class="nav-item nav-item-0"><a href="../../../index.html">PySpark 2.1.2 documentation</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for pyspark.sql.streaming</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># Licensed to the Apache Software Foundation (ASF) under one or more</span>
<span class="c1"># contributor license agreements.  See the NOTICE file distributed with</span>
<span class="c1"># this work for additional information regarding copyright ownership.</span>
<span class="c1"># The ASF licenses this file to You under the Apache License, Version 2.0</span>
<span class="c1"># (the &quot;License&quot;); you may not use this file except in compliance with</span>
<span class="c1"># the License.  You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#    http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1">#</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">json</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version</span> <span class="o">&gt;=</span> <span class="s1">&#39;3&#39;</span><span class="p">:</span>
    <span class="n">intlike</span> <span class="o">=</span> <span class="nb">int</span>
    <span class="n">basestring</span> <span class="o">=</span> <span class="n">unicode</span> <span class="o">=</span> <span class="nb">str</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">intlike</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">long</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">abc</span> <span class="k">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>

<span class="kn">from</span> <span class="nn">pyspark</span> <span class="k">import</span> <span class="n">since</span><span class="p">,</span> <span class="n">keyword_only</span>
<span class="kn">from</span> <span class="nn">pyspark.rdd</span> <span class="k">import</span> <span class="n">ignore_unicode_prefix</span>
<span class="kn">from</span> <span class="nn">pyspark.sql.column</span> <span class="k">import</span> <span class="n">_to_seq</span>
<span class="kn">from</span> <span class="nn">pyspark.sql.readwriter</span> <span class="k">import</span> <span class="n">OptionUtils</span><span class="p">,</span> <span class="n">to_str</span>
<span class="kn">from</span> <span class="nn">pyspark.sql.types</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">pyspark.sql.utils</span> <span class="k">import</span> <span class="n">StreamingQueryException</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;StreamingQuery&quot;</span><span class="p">,</span> <span class="s2">&quot;StreamingQueryManager&quot;</span><span class="p">,</span> <span class="s2">&quot;DataStreamReader&quot;</span><span class="p">,</span> <span class="s2">&quot;DataStreamWriter&quot;</span><span class="p">]</span>


<div class="viewcode-block" id="StreamingQuery"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.StreamingQuery">[docs]</a><span class="k">class</span> <span class="nc">StreamingQuery</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A handle to a query that is executing continuously in the background as new data arrives.</span>
<span class="sd">    All these methods are thread-safe.</span>

<span class="sd">    .. note:: Experimental</span>

<span class="sd">    .. versionadded:: 2.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jsq</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jsq</span> <span class="o">=</span> <span class="n">jsq</span>

    <span class="nd">@property</span>
    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the unique id of this query that persists across restarts from checkpoint data.</span>
<span class="sd">        That is, this id is generated when a query is started for the first time, and</span>
<span class="sd">        will be the same every time it is restarted from checkpoint data.</span>
<span class="sd">        There can only be one query with the same id active in a Spark cluster.</span>
<span class="sd">        Also see, `runId`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jsq</span><span class="o">.</span><span class="n">id</span><span class="p">()</span><span class="o">.</span><span class="n">toString</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.1</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">runId</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the unique id of this query that does not persist across restarts. That is, every</span>
<span class="sd">        query that is started (or restarted from checkpoint) will have a different runId.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jsq</span><span class="o">.</span><span class="n">runId</span><span class="p">()</span><span class="o">.</span><span class="n">toString</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the user-specified name of the query, or null if not specified.</span>
<span class="sd">        This name can be specified in the `org.apache.spark.sql.streaming.DataStreamWriter`</span>
<span class="sd">        as `dataframe.writeStream.queryName(&quot;query&quot;).start()`.</span>
<span class="sd">        This name, if set, must be unique across all active queries.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jsq</span><span class="o">.</span><span class="n">name</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">isActive</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Whether this streaming query is currently active or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jsq</span><span class="o">.</span><span class="n">isActive</span><span class="p">()</span>

    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<div class="viewcode-block" id="StreamingQuery.awaitTermination"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.StreamingQuery.awaitTermination">[docs]</a>    <span class="k">def</span> <span class="nf">awaitTermination</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Waits for the termination of `this` query, either by :func:`query.stop()` or by an</span>
<span class="sd">        exception. If the query has terminated with an exception, then the exception will be thrown.</span>
<span class="sd">        If `timeout` is set, it returns whether the query has terminated or not within the</span>
<span class="sd">        `timeout` seconds.</span>

<span class="sd">        If the query has terminated, then all subsequent calls to this method will either return</span>
<span class="sd">        immediately (if the query was terminated by :func:`stop()`), or throw the exception</span>
<span class="sd">        immediately (if the query has terminated with exception).</span>

<span class="sd">        throws :class:`StreamingQueryException`, if `this` query has terminated with an exception</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">or</span> <span class="n">timeout</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;timeout must be a positive integer or float. Got </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">timeout</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jsq</span><span class="o">.</span><span class="n">awaitTermination</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">timeout</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jsq</span><span class="o">.</span><span class="n">awaitTermination</span><span class="p">()</span></div>

    <span class="nd">@property</span>
    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.1</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the current status of the query.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_jsq</span><span class="o">.</span><span class="n">status</span><span class="p">()</span><span class="o">.</span><span class="n">json</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.1</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">recentProgress</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an array of the most recent [[StreamingQueryProgress]] updates for this query.</span>
<span class="sd">        The number of progress updates retained for each stream is configured by Spark session</span>
<span class="sd">        configuration `spark.sql.streaming.numRecentProgressUpdates`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">json</span><span class="p">())</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jsq</span><span class="o">.</span><span class="n">recentProgress</span><span class="p">()]</span>

    <span class="nd">@property</span>
    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.1</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">lastProgress</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the most recent :class:`StreamingQueryProgress` update of this streaming query or</span>
<span class="sd">        None if there were no progress updates</span>
<span class="sd">        :return: a map</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lastProgress</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jsq</span><span class="o">.</span><span class="n">lastProgress</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">lastProgress</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">lastProgress</span><span class="o">.</span><span class="n">json</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<div class="viewcode-block" id="StreamingQuery.processAllAvailable"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.StreamingQuery.processAllAvailable">[docs]</a>    <span class="k">def</span> <span class="nf">processAllAvailable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Blocks until all available data in the source has been processed and committed to the</span>
<span class="sd">        sink. This method is intended for testing.</span>

<span class="sd">        .. note:: In the case of continually arriving data, this method may block forever.</span>
<span class="sd">            Additionally, this method is only guaranteed to block until data that has been</span>
<span class="sd">            synchronously appended data to a stream source prior to invocation.</span>
<span class="sd">            (i.e. `getOffset` must immediately reflect the addition).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jsq</span><span class="o">.</span><span class="n">processAllAvailable</span><span class="p">()</span></div>

    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<div class="viewcode-block" id="StreamingQuery.stop"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.StreamingQuery.stop">[docs]</a>    <span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Stop this streaming query.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jsq</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span></div>

    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.1</span><span class="p">)</span>
<div class="viewcode-block" id="StreamingQuery.explain"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.StreamingQuery.explain">[docs]</a>    <span class="k">def</span> <span class="nf">explain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">extended</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prints the (logical and physical) plans to the console for debugging purpose.</span>

<span class="sd">        :param extended: boolean, default ``False``. If ``False``, prints only the physical plan.</span>

<span class="sd">        &gt;&gt;&gt; sq = sdf.writeStream.format(&#39;memory&#39;).queryName(&#39;query_explain&#39;).start()</span>
<span class="sd">        &gt;&gt;&gt; sq.processAllAvailable() # Wait a bit to generate the runtime plans.</span>
<span class="sd">        &gt;&gt;&gt; sq.explain()</span>
<span class="sd">        == Physical Plan ==</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; sq.explain(True)</span>
<span class="sd">        == Parsed Logical Plan ==</span>
<span class="sd">        ...</span>
<span class="sd">        == Analyzed Logical Plan ==</span>
<span class="sd">        ...</span>
<span class="sd">        == Optimized Logical Plan ==</span>
<span class="sd">        ...</span>
<span class="sd">        == Physical Plan ==</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; sq.stop()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Cannot call `_jsq.explain(...)` because it will print in the JVM process.</span>
        <span class="c1"># We should print it in the Python process.</span>
        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_jsq</span><span class="o">.</span><span class="n">explainInternal</span><span class="p">(</span><span class="n">extended</span><span class="p">))</span></div>

    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.1</span><span class="p">)</span>
<div class="viewcode-block" id="StreamingQuery.exception"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.StreamingQuery.exception">[docs]</a>    <span class="k">def</span> <span class="nf">exception</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: the StreamingQueryException if the query was terminated by an exception, or None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jsq</span><span class="o">.</span><span class="n">exception</span><span class="p">()</span><span class="o">.</span><span class="n">isDefined</span><span class="p">():</span>
            <span class="n">je</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jsq</span><span class="o">.</span><span class="n">exception</span><span class="p">()</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="n">je</span><span class="o">.</span><span class="n">toString</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;: &#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Drop the Java StreamingQueryException type info</span>
            <span class="n">stackTrace</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n\t</span><span class="s1"> at &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">toString</span><span class="p">(),</span> <span class="n">je</span><span class="o">.</span><span class="n">getStackTrace</span><span class="p">()))</span>
            <span class="k">return</span> <span class="n">StreamingQueryException</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">stackTrace</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div></div>


<div class="viewcode-block" id="StreamingQueryManager"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.StreamingQueryManager">[docs]</a><span class="k">class</span> <span class="nc">StreamingQueryManager</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A class to manage all the :class:`StreamingQuery` StreamingQueries active.</span>

<span class="sd">    .. note:: Experimental</span>

<span class="sd">    .. versionadded:: 2.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jsqm</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jsqm</span> <span class="o">=</span> <span class="n">jsqm</span>

    <span class="nd">@property</span>
    <span class="nd">@ignore_unicode_prefix</span>
    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">active</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of active queries associated with this SQLContext</span>

<span class="sd">        &gt;&gt;&gt; sq = sdf.writeStream.format(&#39;memory&#39;).queryName(&#39;this_query&#39;).start()</span>
<span class="sd">        &gt;&gt;&gt; sqm = spark.streams</span>
<span class="sd">        &gt;&gt;&gt; # get the list of active streaming queries</span>
<span class="sd">        &gt;&gt;&gt; [q.name for q in sqm.active]</span>
<span class="sd">        [u&#39;this_query&#39;]</span>
<span class="sd">        &gt;&gt;&gt; sq.stop()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">StreamingQuery</span><span class="p">(</span><span class="n">jsq</span><span class="p">)</span> <span class="k">for</span> <span class="n">jsq</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jsqm</span><span class="o">.</span><span class="n">active</span><span class="p">()]</span>

    <span class="nd">@ignore_unicode_prefix</span>
    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<div class="viewcode-block" id="StreamingQueryManager.get"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.StreamingQueryManager.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an active query from this SQLContext or throws exception if an active query</span>
<span class="sd">        with this name doesn&#39;t exist.</span>

<span class="sd">        &gt;&gt;&gt; sq = sdf.writeStream.format(&#39;memory&#39;).queryName(&#39;this_query&#39;).start()</span>
<span class="sd">        &gt;&gt;&gt; sq.name</span>
<span class="sd">        u&#39;this_query&#39;</span>
<span class="sd">        &gt;&gt;&gt; sq = spark.streams.get(sq.id)</span>
<span class="sd">        &gt;&gt;&gt; sq.isActive</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; sq = sqlContext.streams.get(sq.id)</span>
<span class="sd">        &gt;&gt;&gt; sq.isActive</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; sq.stop()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">StreamingQuery</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_jsqm</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="p">))</span></div>

    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<div class="viewcode-block" id="StreamingQueryManager.awaitAnyTermination"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.StreamingQueryManager.awaitAnyTermination">[docs]</a>    <span class="k">def</span> <span class="nf">awaitAnyTermination</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Wait until any of the queries on the associated SQLContext has terminated since the</span>
<span class="sd">        creation of the context, or since :func:`resetTerminated()` was called. If any query was</span>
<span class="sd">        terminated with an exception, then the exception will be thrown.</span>
<span class="sd">        If `timeout` is set, it returns whether the query has terminated or not within the</span>
<span class="sd">        `timeout` seconds.</span>

<span class="sd">        If a query has terminated, then subsequent calls to :func:`awaitAnyTermination()` will</span>
<span class="sd">        either return immediately (if the query was terminated by :func:`query.stop()`),</span>
<span class="sd">        or throw the exception immediately (if the query was terminated with exception). Use</span>
<span class="sd">        :func:`resetTerminated()` to clear past terminations and wait for new terminations.</span>

<span class="sd">        In the case where multiple queries have terminated since :func:`resetTermination()`</span>
<span class="sd">        was called, if any query has terminated with exception, then :func:`awaitAnyTermination()`</span>
<span class="sd">        will throw any of the exception. For correctly documenting exceptions across multiple</span>
<span class="sd">        queries, users need to stop all of them after any of them terminates with exception, and</span>
<span class="sd">        then check the `query.exception()` for each query.</span>

<span class="sd">        throws :class:`StreamingQueryException`, if `this` query has terminated with an exception</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">timeout</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">timeout</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">or</span> <span class="n">timeout</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;timeout must be a positive integer or float. Got </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">timeout</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jsqm</span><span class="o">.</span><span class="n">awaitAnyTermination</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">timeout</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jsqm</span><span class="o">.</span><span class="n">awaitAnyTermination</span><span class="p">()</span></div>

    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<div class="viewcode-block" id="StreamingQueryManager.resetTerminated"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.StreamingQueryManager.resetTerminated">[docs]</a>    <span class="k">def</span> <span class="nf">resetTerminated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Forget about past terminated queries so that :func:`awaitAnyTermination()` can be used</span>
<span class="sd">        again to wait for new terminations.</span>

<span class="sd">        &gt;&gt;&gt; spark.streams.resetTerminated()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jsqm</span><span class="o">.</span><span class="n">resetTerminated</span><span class="p">()</span></div></div>


<span class="k">class</span> <span class="nc">Trigger</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Used to indicate how often results should be produced by a :class:`StreamingQuery`.</span>

<span class="sd">    .. note:: Experimental</span>

<span class="sd">    .. versionadded:: 2.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__metaclass__</span> <span class="o">=</span> <span class="n">ABCMeta</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">_to_java_trigger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sqlContext</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Internal method to construct the trigger on the jvm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>


<span class="k">class</span> <span class="nc">ProcessingTime</span><span class="p">(</span><span class="n">Trigger</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A trigger that runs a query periodically based on the processing time. If `interval` is 0,</span>
<span class="sd">    the query will run as fast as possible.</span>

<span class="sd">    The interval should be given as a string, e.g. &#39;2 seconds&#39;, &#39;5 minutes&#39;, ...</span>

<span class="sd">    .. note:: Experimental</span>

<span class="sd">    .. versionadded:: 2.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">interval</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;interval should be a non empty interval string, e.g. &#39;2 seconds&#39;.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interval</span> <span class="o">=</span> <span class="n">interval</span>

    <span class="k">def</span> <span class="nf">_to_java_trigger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sqlContext</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sqlContext</span><span class="o">.</span><span class="n">_sc</span><span class="o">.</span><span class="n">_jvm</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">apache</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">sql</span><span class="o">.</span><span class="n">streaming</span><span class="o">.</span><span class="n">ProcessingTime</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interval</span><span class="p">)</span>


<div class="viewcode-block" id="DataStreamReader"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.DataStreamReader">[docs]</a><span class="k">class</span> <span class="nc">DataStreamReader</span><span class="p">(</span><span class="n">OptionUtils</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interface used to load a streaming :class:`DataFrame` from external storage systems</span>
<span class="sd">    (e.g. file systems, key-value stores, etc). Use :func:`spark.readStream`</span>
<span class="sd">    to access this.</span>

<span class="sd">    .. note:: Experimental.</span>

<span class="sd">    .. versionadded:: 2.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spark</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jreader</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">_ssql_ctx</span><span class="o">.</span><span class="n">readStream</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spark</span> <span class="o">=</span> <span class="n">spark</span>

    <span class="k">def</span> <span class="nf">_df</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jdf</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pyspark.sql.dataframe</span> <span class="k">import</span> <span class="n">DataFrame</span>
        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">jdf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spark</span><span class="p">)</span>

    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<div class="viewcode-block" id="DataStreamReader.format"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.DataStreamReader.format">[docs]</a>    <span class="k">def</span> <span class="nf">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Specifies the input data source format.</span>

<span class="sd">        .. note:: Experimental.</span>

<span class="sd">        :param source: string, name of the data source, e.g. &#39;json&#39;, &#39;parquet&#39;.</span>

<span class="sd">        &gt;&gt;&gt; s = spark.readStream.format(&quot;text&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jreader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jreader</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<div class="viewcode-block" id="DataStreamReader.schema"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.DataStreamReader.schema">[docs]</a>    <span class="k">def</span> <span class="nf">schema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schema</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Specifies the input schema.</span>

<span class="sd">        Some data sources (e.g. JSON) can infer the input schema automatically from data.</span>
<span class="sd">        By specifying the schema here, the underlying data source can skip the schema</span>
<span class="sd">        inference step, and thus speed up data loading.</span>

<span class="sd">        .. note:: Experimental.</span>

<span class="sd">        :param schema: a :class:`pyspark.sql.types.StructType` object</span>

<span class="sd">        &gt;&gt;&gt; s = spark.readStream.schema(sdf_schema)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pyspark.sql</span> <span class="k">import</span> <span class="n">SparkSession</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="n">StructType</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;schema should be StructType&quot;</span><span class="p">)</span>
        <span class="n">spark</span> <span class="o">=</span> <span class="n">SparkSession</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">getOrCreate</span><span class="p">()</span>
        <span class="n">jschema</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">_jsparkSession</span><span class="o">.</span><span class="n">parseDataType</span><span class="p">(</span><span class="n">schema</span><span class="o">.</span><span class="n">json</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jreader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jreader</span><span class="o">.</span><span class="n">schema</span><span class="p">(</span><span class="n">jschema</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<div class="viewcode-block" id="DataStreamReader.option"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.DataStreamReader.option">[docs]</a>    <span class="k">def</span> <span class="nf">option</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds an input option for the underlying data source.</span>

<span class="sd">        .. note:: Experimental.</span>

<span class="sd">        &gt;&gt;&gt; s = spark.readStream.option(&quot;x&quot;, 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jreader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jreader</span><span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">to_str</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<div class="viewcode-block" id="DataStreamReader.options"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.DataStreamReader.options">[docs]</a>    <span class="k">def</span> <span class="nf">options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds input options for the underlying data source.</span>

<span class="sd">        .. note:: Experimental.</span>

<span class="sd">        &gt;&gt;&gt; s = spark.readStream.options(x=&quot;1&quot;, y=2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_jreader</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jreader</span><span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">to_str</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<div class="viewcode-block" id="DataStreamReader.load"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.DataStreamReader.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Loads a data stream from a data source and returns it as a :class`DataFrame`.</span>

<span class="sd">        .. note:: Experimental.</span>

<span class="sd">        :param path: optional string for file-system backed data sources.</span>
<span class="sd">        :param format: optional string for format of the data source. Default to &#39;parquet&#39;.</span>
<span class="sd">        :param schema: optional :class:`pyspark.sql.types.StructType` for the input schema.</span>
<span class="sd">        :param options: all other string options</span>

<span class="sd">        &gt;&gt;&gt; json_sdf = spark.readStream.format(&quot;json&quot;) \\</span>
<span class="sd">        ...     .schema(sdf_schema) \\</span>
<span class="sd">        ...     .load(tempfile.mkdtemp())</span>
<span class="sd">        &gt;&gt;&gt; json_sdf.isStreaming</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; json_sdf.schema == sdf_schema</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">format</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">schema</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If the path is provided for stream, it needs to be a &quot;</span> <span class="o">+</span>
                                 <span class="s2">&quot;non-empty string. List of paths are not supported.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_df</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_jreader</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_df</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_jreader</span><span class="o">.</span><span class="n">load</span><span class="p">())</span></div>

    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<div class="viewcode-block" id="DataStreamReader.json"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.DataStreamReader.json">[docs]</a>    <span class="k">def</span> <span class="nf">json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">primitivesAsString</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefersDecimal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">allowComments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">allowUnquotedFieldNames</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">allowSingleQuotes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">allowNumericLeadingZero</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">allowBackslashEscapingAnyCharacter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">columnNameOfCorruptRecord</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dateFormat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">timestampFormat</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads a JSON file stream (`JSON Lines text format or newline-delimited JSON</span>
<span class="sd">        &lt;http://jsonlines.org/&gt;`_) and returns a :class`DataFrame`.</span>

<span class="sd">        If the ``schema`` parameter is not specified, this function goes</span>
<span class="sd">        through the input once to determine the input schema.</span>

<span class="sd">        .. note:: Experimental.</span>

<span class="sd">        :param path: string represents path to the JSON dataset,</span>
<span class="sd">                     or RDD of Strings storing JSON objects.</span>
<span class="sd">        :param schema: an optional :class:`pyspark.sql.types.StructType` for the input schema.</span>
<span class="sd">        :param primitivesAsString: infers all primitive values as a string type. If None is set,</span>
<span class="sd">                                   it uses the default value, ``false``.</span>
<span class="sd">        :param prefersDecimal: infers all floating-point values as a decimal type. If the values</span>
<span class="sd">                               do not fit in decimal, then it infers them as doubles. If None is</span>
<span class="sd">                               set, it uses the default value, ``false``.</span>
<span class="sd">        :param allowComments: ignores Java/C++ style comment in JSON records. If None is set,</span>
<span class="sd">                              it uses the default value, ``false``.</span>
<span class="sd">        :param allowUnquotedFieldNames: allows unquoted JSON field names. If None is set,</span>
<span class="sd">                                        it uses the default value, ``false``.</span>
<span class="sd">        :param allowSingleQuotes: allows single quotes in addition to double quotes. If None is</span>
<span class="sd">                                        set, it uses the default value, ``true``.</span>
<span class="sd">        :param allowNumericLeadingZero: allows leading zeros in numbers (e.g. 00012). If None is</span>
<span class="sd">                                        set, it uses the default value, ``false``.</span>
<span class="sd">        :param allowBackslashEscapingAnyCharacter: allows accepting quoting of all character</span>
<span class="sd">                                                   using backslash quoting mechanism. If None is</span>
<span class="sd">                                                   set, it uses the default value, ``false``.</span>
<span class="sd">        :param mode: allows a mode for dealing with corrupt records during parsing. If None is</span>
<span class="sd">                     set, it uses the default value, ``PERMISSIVE``.</span>

<span class="sd">                *  ``PERMISSIVE`` : sets other fields to ``null`` when it meets a corrupted \</span>
<span class="sd">                  record and puts the malformed string into a new field configured by \</span>
<span class="sd">                 ``columnNameOfCorruptRecord``. When a schema is set by user, it sets \</span>
<span class="sd">                 ``null`` for extra fields.</span>
<span class="sd">                *  ``DROPMALFORMED`` : ignores the whole corrupted records.</span>
<span class="sd">                *  ``FAILFAST`` : throws an exception when it meets corrupted records.</span>

<span class="sd">        :param columnNameOfCorruptRecord: allows renaming the new field having malformed string</span>
<span class="sd">                                          created by ``PERMISSIVE`` mode. This overrides</span>
<span class="sd">                                          ``spark.sql.columnNameOfCorruptRecord``. If None is set,</span>
<span class="sd">                                          it uses the value specified in</span>
<span class="sd">                                          ``spark.sql.columnNameOfCorruptRecord``.</span>
<span class="sd">        :param dateFormat: sets the string that indicates a date format. Custom date formats</span>
<span class="sd">                           follow the formats at ``java.text.SimpleDateFormat``. This</span>
<span class="sd">                           applies to date type. If None is set, it uses the</span>
<span class="sd">                           default value value, ``yyyy-MM-dd``.</span>
<span class="sd">        :param timestampFormat: sets the string that indicates a timestamp format. Custom date</span>
<span class="sd">                                formats follow the formats at ``java.text.SimpleDateFormat``.</span>
<span class="sd">                                This applies to timestamp type. If None is set, it uses the</span>
<span class="sd">                                default value value, ``yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZZ``.</span>

<span class="sd">        &gt;&gt;&gt; json_sdf = spark.readStream.json(tempfile.mkdtemp(), schema = sdf_schema)</span>
<span class="sd">        &gt;&gt;&gt; json_sdf.isStreaming</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; json_sdf.schema == sdf_schema</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_opts</span><span class="p">(</span>
            <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span> <span class="n">primitivesAsString</span><span class="o">=</span><span class="n">primitivesAsString</span><span class="p">,</span> <span class="n">prefersDecimal</span><span class="o">=</span><span class="n">prefersDecimal</span><span class="p">,</span>
            <span class="n">allowComments</span><span class="o">=</span><span class="n">allowComments</span><span class="p">,</span> <span class="n">allowUnquotedFieldNames</span><span class="o">=</span><span class="n">allowUnquotedFieldNames</span><span class="p">,</span>
            <span class="n">allowSingleQuotes</span><span class="o">=</span><span class="n">allowSingleQuotes</span><span class="p">,</span> <span class="n">allowNumericLeadingZero</span><span class="o">=</span><span class="n">allowNumericLeadingZero</span><span class="p">,</span>
            <span class="n">allowBackslashEscapingAnyCharacter</span><span class="o">=</span><span class="n">allowBackslashEscapingAnyCharacter</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">columnNameOfCorruptRecord</span><span class="o">=</span><span class="n">columnNameOfCorruptRecord</span><span class="p">,</span> <span class="n">dateFormat</span><span class="o">=</span><span class="n">dateFormat</span><span class="p">,</span>
            <span class="n">timestampFormat</span><span class="o">=</span><span class="n">timestampFormat</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_df</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_jreader</span><span class="o">.</span><span class="n">json</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;path can be only a single string&quot;</span><span class="p">)</span></div>

    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<div class="viewcode-block" id="DataStreamReader.parquet"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.DataStreamReader.parquet">[docs]</a>    <span class="k">def</span> <span class="nf">parquet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Loads a Parquet file stream, returning the result as a :class:`DataFrame`.</span>

<span class="sd">        You can set the following Parquet-specific option(s) for reading Parquet files:</span>
<span class="sd">            * ``mergeSchema``: sets whether we should merge schemas collected from all \</span>
<span class="sd">                Parquet part-files. This will override ``spark.sql.parquet.mergeSchema``. \</span>
<span class="sd">                The default value is specified in ``spark.sql.parquet.mergeSchema``.</span>

<span class="sd">        .. note:: Experimental.</span>

<span class="sd">        &gt;&gt;&gt; parquet_sdf = spark.readStream.schema(sdf_schema).parquet(tempfile.mkdtemp())</span>
<span class="sd">        &gt;&gt;&gt; parquet_sdf.isStreaming</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; parquet_sdf.schema == sdf_schema</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_df</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_jreader</span><span class="o">.</span><span class="n">parquet</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;path can be only a single string&quot;</span><span class="p">)</span></div>

    <span class="nd">@ignore_unicode_prefix</span>
    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<div class="viewcode-block" id="DataStreamReader.text"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.DataStreamReader.text">[docs]</a>    <span class="k">def</span> <span class="nf">text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads a text file stream and returns a :class:`DataFrame` whose schema starts with a</span>
<span class="sd">        string column named &quot;value&quot;, and followed by partitioned columns if there</span>
<span class="sd">        are any.</span>

<span class="sd">        Each line in the text file is a new row in the resulting DataFrame.</span>

<span class="sd">        .. note:: Experimental.</span>

<span class="sd">        :param paths: string, or list of strings, for input path(s).</span>

<span class="sd">        &gt;&gt;&gt; text_sdf = spark.readStream.text(tempfile.mkdtemp())</span>
<span class="sd">        &gt;&gt;&gt; text_sdf.isStreaming</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; &quot;value&quot; in str(text_sdf.schema)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_df</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_jreader</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;path can be only a single string&quot;</span><span class="p">)</span></div>

    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<div class="viewcode-block" id="DataStreamReader.csv"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.DataStreamReader.csv">[docs]</a>    <span class="k">def</span> <span class="nf">csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">quote</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">escape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">comment</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inferSchema</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ignoreLeadingWhiteSpace</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">ignoreTrailingWhiteSpace</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nullValue</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nanValue</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">positiveInf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">negativeInf</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dateFormat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">timestampFormat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxColumns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">maxCharsPerColumn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxMalformedLogPerPartition</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Loads a CSV file stream and returns the result as a  :class:`DataFrame`.</span>

<span class="sd">        This function will go through the input once to determine the input schema if</span>
<span class="sd">        ``inferSchema`` is enabled. To avoid going through the entire data once, disable</span>
<span class="sd">        ``inferSchema`` option or specify the schema explicitly using ``schema``.</span>

<span class="sd">        .. note:: Experimental.</span>

<span class="sd">        :param path: string, or list of strings, for input path(s).</span>
<span class="sd">        :param schema: an optional :class:`pyspark.sql.types.StructType` for the input schema.</span>
<span class="sd">        :param sep: sets the single character as a separator for each field and value.</span>
<span class="sd">                    If None is set, it uses the default value, ``,``.</span>
<span class="sd">        :param encoding: decodes the CSV files by the given encoding type. If None is set,</span>
<span class="sd">                         it uses the default value, ``UTF-8``.</span>
<span class="sd">        :param quote: sets the single character used for escaping quoted values where the</span>
<span class="sd">                      separator can be part of the value. If None is set, it uses the default</span>
<span class="sd">                      value, ``&quot;``. If you would like to turn off quotations, you need to set an</span>
<span class="sd">                      empty string.</span>
<span class="sd">        :param escape: sets the single character used for escaping quotes inside an already</span>
<span class="sd">                       quoted value. If None is set, it uses the default value, ``\``.</span>
<span class="sd">        :param comment: sets the single character used for skipping lines beginning with this</span>
<span class="sd">                        character. By default (None), it is disabled.</span>
<span class="sd">        :param header: uses the first line as names of columns. If None is set, it uses the</span>
<span class="sd">                       default value, ``false``.</span>
<span class="sd">        :param inferSchema: infers the input schema automatically from data. It requires one extra</span>
<span class="sd">                       pass over the data. If None is set, it uses the default value, ``false``.</span>
<span class="sd">        :param ignoreLeadingWhiteSpace: defines whether or not leading whitespaces from values</span>
<span class="sd">                                        being read should be skipped. If None is set, it uses</span>
<span class="sd">                                        the default value, ``false``.</span>
<span class="sd">        :param ignoreTrailingWhiteSpace: defines whether or not trailing whitespaces from values</span>
<span class="sd">                                         being read should be skipped. If None is set, it uses</span>
<span class="sd">                                         the default value, ``false``.</span>
<span class="sd">        :param nullValue: sets the string representation of a null value. If None is set, it uses</span>
<span class="sd">                          the default value, empty string. Since 2.0.1, this ``nullValue`` param</span>
<span class="sd">                          applies to all supported types including the string type.</span>
<span class="sd">        :param nanValue: sets the string representation of a non-number value. If None is set, it</span>
<span class="sd">                         uses the default value, ``NaN``.</span>
<span class="sd">        :param positiveInf: sets the string representation of a positive infinity value. If None</span>
<span class="sd">                            is set, it uses the default value, ``Inf``.</span>
<span class="sd">        :param negativeInf: sets the string representation of a negative infinity value. If None</span>
<span class="sd">                            is set, it uses the default value, ``Inf``.</span>
<span class="sd">        :param dateFormat: sets the string that indicates a date format. Custom date formats</span>
<span class="sd">                           follow the formats at ``java.text.SimpleDateFormat``. This</span>
<span class="sd">                           applies to date type. If None is set, it uses the</span>
<span class="sd">                           default value value, ``yyyy-MM-dd``.</span>
<span class="sd">        :param timestampFormat: sets the string that indicates a timestamp format. Custom date</span>
<span class="sd">                                formats follow the formats at ``java.text.SimpleDateFormat``.</span>
<span class="sd">                                This applies to timestamp type. If None is set, it uses the</span>
<span class="sd">                                default value value, ``yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZZ``.</span>
<span class="sd">        :param maxColumns: defines a hard limit of how many columns a record can have. If None is</span>
<span class="sd">                           set, it uses the default value, ``20480``.</span>
<span class="sd">        :param maxCharsPerColumn: defines the maximum number of characters allowed for any given</span>
<span class="sd">                                  value being read. If None is set, it uses the default value,</span>
<span class="sd">                                  ``-1`` meaning unlimited length.</span>
<span class="sd">        :param mode: allows a mode for dealing with corrupt records during parsing. If None is</span>
<span class="sd">                     set, it uses the default value, ``PERMISSIVE``.</span>

<span class="sd">                * ``PERMISSIVE`` : sets other fields to ``null`` when it meets a corrupted record.</span>
<span class="sd">                    When a schema is set by user, it sets ``null`` for extra fields.</span>
<span class="sd">                * ``DROPMALFORMED`` : ignores the whole corrupted records.</span>
<span class="sd">                * ``FAILFAST`` : throws an exception when it meets corrupted records.</span>

<span class="sd">        &gt;&gt;&gt; csv_sdf = spark.readStream.csv(tempfile.mkdtemp(), schema = sdf_schema)</span>
<span class="sd">        &gt;&gt;&gt; csv_sdf.isStreaming</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; csv_sdf.schema == sdf_schema</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_opts</span><span class="p">(</span>
            <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span> <span class="n">quote</span><span class="o">=</span><span class="n">quote</span><span class="p">,</span> <span class="n">escape</span><span class="o">=</span><span class="n">escape</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="n">comment</span><span class="p">,</span>
            <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">inferSchema</span><span class="o">=</span><span class="n">inferSchema</span><span class="p">,</span> <span class="n">ignoreLeadingWhiteSpace</span><span class="o">=</span><span class="n">ignoreLeadingWhiteSpace</span><span class="p">,</span>
            <span class="n">ignoreTrailingWhiteSpace</span><span class="o">=</span><span class="n">ignoreTrailingWhiteSpace</span><span class="p">,</span> <span class="n">nullValue</span><span class="o">=</span><span class="n">nullValue</span><span class="p">,</span>
            <span class="n">nanValue</span><span class="o">=</span><span class="n">nanValue</span><span class="p">,</span> <span class="n">positiveInf</span><span class="o">=</span><span class="n">positiveInf</span><span class="p">,</span> <span class="n">negativeInf</span><span class="o">=</span><span class="n">negativeInf</span><span class="p">,</span>
            <span class="n">dateFormat</span><span class="o">=</span><span class="n">dateFormat</span><span class="p">,</span> <span class="n">timestampFormat</span><span class="o">=</span><span class="n">timestampFormat</span><span class="p">,</span> <span class="n">maxColumns</span><span class="o">=</span><span class="n">maxColumns</span><span class="p">,</span>
            <span class="n">maxCharsPerColumn</span><span class="o">=</span><span class="n">maxCharsPerColumn</span><span class="p">,</span>
            <span class="n">maxMalformedLogPerPartition</span><span class="o">=</span><span class="n">maxMalformedLogPerPartition</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_df</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_jreader</span><span class="o">.</span><span class="n">csv</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;path can be only a single string&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="DataStreamWriter"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.DataStreamWriter">[docs]</a><span class="k">class</span> <span class="nc">DataStreamWriter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interface used to write a streaming :class:`DataFrame` to external storage systems</span>
<span class="sd">    (e.g. file systems, key-value stores, etc). Use :func:`DataFrame.writeStream`</span>
<span class="sd">    to access this.</span>

<span class="sd">    .. note:: Experimental.</span>

<span class="sd">    .. versionadded:: 2.0</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_df</span> <span class="o">=</span> <span class="n">df</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_spark</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sql_ctx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jwrite</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">_jdf</span><span class="o">.</span><span class="n">writeStream</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_sq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jsq</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pyspark.sql.streaming</span> <span class="k">import</span> <span class="n">StreamingQuery</span>
        <span class="k">return</span> <span class="n">StreamingQuery</span><span class="p">(</span><span class="n">jsq</span><span class="p">)</span>

    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<div class="viewcode-block" id="DataStreamWriter.outputMode"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.DataStreamWriter.outputMode">[docs]</a>    <span class="k">def</span> <span class="nf">outputMode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputMode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Specifies how data of a streaming DataFrame/Dataset is written to a streaming sink.</span>

<span class="sd">        Options include:</span>

<span class="sd">        * `append`:Only the new rows in the streaming DataFrame/Dataset will be written to</span>
<span class="sd">           the sink</span>
<span class="sd">        * `complete`:All the rows in the streaming DataFrame/Dataset will be written to the sink</span>
<span class="sd">           every time these is some updates</span>
<span class="sd">        * `update`:only the rows that were updated in the streaming DataFrame/Dataset will be</span>
<span class="sd">           written to the sink every time there are some updates. If the query doesn&#39;t contain</span>
<span class="sd">           aggregations, it will be equivalent to `append` mode.</span>

<span class="sd">       .. note:: Experimental.</span>

<span class="sd">        &gt;&gt;&gt; writer = sdf.writeStream.outputMode(&#39;append&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">outputMode</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">outputMode</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">outputMode</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The output mode must be a non-empty string. Got: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">outputMode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jwrite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jwrite</span><span class="o">.</span><span class="n">outputMode</span><span class="p">(</span><span class="n">outputMode</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<div class="viewcode-block" id="DataStreamWriter.format"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.DataStreamWriter.format">[docs]</a>    <span class="k">def</span> <span class="nf">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Specifies the underlying output data source.</span>

<span class="sd">        .. note:: Experimental.</span>

<span class="sd">        :param source: string, name of the data source, which for now can be &#39;parquet&#39;.</span>

<span class="sd">        &gt;&gt;&gt; writer = sdf.writeStream.format(&#39;json&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jwrite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jwrite</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<div class="viewcode-block" id="DataStreamWriter.option"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.DataStreamWriter.option">[docs]</a>    <span class="k">def</span> <span class="nf">option</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds an output option for the underlying data source.</span>

<span class="sd">        .. note:: Experimental.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jwrite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jwrite</span><span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">to_str</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<div class="viewcode-block" id="DataStreamWriter.options"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.DataStreamWriter.options">[docs]</a>    <span class="k">def</span> <span class="nf">options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds output options for the underlying data source.</span>

<span class="sd">       .. note:: Experimental.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_jwrite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jwrite</span><span class="o">.</span><span class="n">option</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">to_str</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="n">k</span><span class="p">]))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<div class="viewcode-block" id="DataStreamWriter.partitionBy"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.DataStreamWriter.partitionBy">[docs]</a>    <span class="k">def</span> <span class="nf">partitionBy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">cols</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Partitions the output by the given columns on the file system.</span>

<span class="sd">        If specified, the output is laid out on the file system similar</span>
<span class="sd">        to Hive&#39;s partitioning scheme.</span>

<span class="sd">        .. note:: Experimental.</span>

<span class="sd">        :param cols: name of columns</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cols</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jwrite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jwrite</span><span class="o">.</span><span class="n">partitionBy</span><span class="p">(</span><span class="n">_to_seq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spark</span><span class="o">.</span><span class="n">_sc</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<div class="viewcode-block" id="DataStreamWriter.queryName"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.DataStreamWriter.queryName">[docs]</a>    <span class="k">def</span> <span class="nf">queryName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queryName</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Specifies the name of the :class:`StreamingQuery` that can be started with</span>
<span class="sd">        :func:`start`. This name must be unique among all the currently active queries</span>
<span class="sd">        in the associated SparkSession.</span>

<span class="sd">        .. note:: Experimental.</span>

<span class="sd">        :param queryName: unique name for the query</span>

<span class="sd">        &gt;&gt;&gt; writer = sdf.writeStream.queryName(&#39;streaming_query&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">queryName</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">queryName</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">queryName</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The queryName must be a non-empty string. Got: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">queryName</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jwrite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jwrite</span><span class="o">.</span><span class="n">queryName</span><span class="p">(</span><span class="n">queryName</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@keyword_only</span>
    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<div class="viewcode-block" id="DataStreamWriter.trigger"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.DataStreamWriter.trigger">[docs]</a>    <span class="k">def</span> <span class="nf">trigger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">processingTime</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set the trigger for the stream query. If this is not set it will run the query as fast</span>
<span class="sd">        as possible, which is equivalent to setting the trigger to ``processingTime=&#39;0 seconds&#39;``.</span>

<span class="sd">        .. note:: Experimental.</span>

<span class="sd">        :param processingTime: a processing time interval as a string, e.g. &#39;5 seconds&#39;, &#39;1 minute&#39;.</span>

<span class="sd">        &gt;&gt;&gt; # trigger the query for execution every 5 seconds</span>
<span class="sd">        &gt;&gt;&gt; writer = sdf.writeStream.trigger(processingTime=&#39;5 seconds&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pyspark.sql.streaming</span> <span class="k">import</span> <span class="n">ProcessingTime</span>
        <span class="n">trigger</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">processingTime</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">processingTime</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">str</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">processingTime</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The processing time must be a non empty string. Got: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                                 <span class="n">processingTime</span><span class="p">)</span>
            <span class="n">trigger</span> <span class="o">=</span> <span class="n">ProcessingTime</span><span class="p">(</span><span class="n">processingTime</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">trigger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;A trigger was not provided. Supported triggers: processingTime.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jwrite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jwrite</span><span class="o">.</span><span class="n">trigger</span><span class="p">(</span><span class="n">trigger</span><span class="o">.</span><span class="n">_to_java_trigger</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_spark</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@ignore_unicode_prefix</span>
    <span class="nd">@since</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
<div class="viewcode-block" id="DataStreamWriter.start"><a class="viewcode-back" href="../../../pyspark.sql.html#pyspark.sql.streaming.DataStreamWriter.start">[docs]</a>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">outputMode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">partitionBy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">queryName</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Streams the contents of the :class:`DataFrame` to a data source.</span>

<span class="sd">        The data source is specified by the ``format`` and a set of ``options``.</span>
<span class="sd">        If ``format`` is not specified, the default data source configured by</span>
<span class="sd">        ``spark.sql.sources.default`` will be used.</span>

<span class="sd">        .. note:: Experimental.</span>

<span class="sd">        :param path: the path in a Hadoop supported file system</span>
<span class="sd">        :param format: the format used to save</span>
<span class="sd">        :param outputMode: specifies how data of a streaming DataFrame/Dataset is written to a</span>
<span class="sd">                           streaming sink.</span>

<span class="sd">            * `append`:Only the new rows in the streaming DataFrame/Dataset will be written to the</span>
<span class="sd">              sink</span>
<span class="sd">            * `complete`:All the rows in the streaming DataFrame/Dataset will be written to the sink</span>
<span class="sd">               every time these is some updates</span>
<span class="sd">            * `update`:only the rows that were updated in the streaming DataFrame/Dataset will be</span>
<span class="sd">              written to the sink every time there are some updates. If the query doesn&#39;t contain</span>
<span class="sd">              aggregations, it will be equivalent to `append` mode.</span>
<span class="sd">        :param partitionBy: names of partitioning columns</span>
<span class="sd">        :param queryName: unique name for the query</span>
<span class="sd">        :param options: All other string options. You may want to provide a `checkpointLocation`</span>
<span class="sd">                        for most streams, however it is not required for a `memory` stream.</span>

<span class="sd">        &gt;&gt;&gt; sq = sdf.writeStream.format(&#39;memory&#39;).queryName(&#39;this_query&#39;).start()</span>
<span class="sd">        &gt;&gt;&gt; sq.isActive</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; sq.name</span>
<span class="sd">        u&#39;this_query&#39;</span>
<span class="sd">        &gt;&gt;&gt; sq.stop()</span>
<span class="sd">        &gt;&gt;&gt; sq.isActive</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; sq = sdf.writeStream.trigger(processingTime=&#39;5 seconds&#39;).start(</span>
<span class="sd">        ...     queryName=&#39;that_query&#39;, outputMode=&quot;append&quot;, format=&#39;memory&#39;)</span>
<span class="sd">        &gt;&gt;&gt; sq.name</span>
<span class="sd">        u&#39;that_query&#39;</span>
<span class="sd">        &gt;&gt;&gt; sq.isActive</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; sq.stop()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="o">**</span><span class="n">options</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">outputMode</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">outputMode</span><span class="p">(</span><span class="n">outputMode</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">partitionBy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">partitionBy</span><span class="p">(</span><span class="n">partitionBy</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">format</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">queryName</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">queryName</span><span class="p">(</span><span class="n">queryName</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_jwrite</span><span class="o">.</span><span class="n">start</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_jwrite</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">path</span><span class="p">))</span></div></div>


<span class="k">def</span> <span class="nf">_test</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="kn">import</span> <span class="nn">os</span>
    <span class="kn">import</span> <span class="nn">tempfile</span>
    <span class="kn">from</span> <span class="nn">pyspark.sql</span> <span class="k">import</span> <span class="n">Row</span><span class="p">,</span> <span class="n">SparkSession</span><span class="p">,</span> <span class="n">SQLContext</span>
    <span class="kn">import</span> <span class="nn">pyspark.sql.streaming</span>

    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;SPARK_HOME&quot;</span><span class="p">])</span>

    <span class="n">globs</span> <span class="o">=</span> <span class="n">pyspark</span><span class="o">.</span><span class="n">sql</span><span class="o">.</span><span class="n">streaming</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">spark</span> <span class="o">=</span> <span class="n">SparkSession</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">getOrCreate</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">py4j</span><span class="o">.</span><span class="n">protocol</span><span class="o">.</span><span class="n">Py4JError</span><span class="p">:</span>
        <span class="n">spark</span> <span class="o">=</span> <span class="n">SparkSession</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>

    <span class="n">globs</span><span class="p">[</span><span class="s1">&#39;tempfile&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tempfile</span>
    <span class="n">globs</span><span class="p">[</span><span class="s1">&#39;os&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span>
    <span class="n">globs</span><span class="p">[</span><span class="s1">&#39;spark&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spark</span>
    <span class="n">globs</span><span class="p">[</span><span class="s1">&#39;sqlContext&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">SQLContext</span><span class="o">.</span><span class="n">getOrCreate</span><span class="p">(</span><span class="n">spark</span><span class="o">.</span><span class="n">sparkContext</span><span class="p">)</span>
    <span class="n">globs</span><span class="p">[</span><span class="s1">&#39;sdf&#39;</span><span class="p">]</span> <span class="o">=</span> \
        <span class="n">spark</span><span class="o">.</span><span class="n">readStream</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;text&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;python/test_support/sql/streaming&#39;</span><span class="p">)</span>
    <span class="n">globs</span><span class="p">[</span><span class="s1">&#39;sdf_schema&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">StructType</span><span class="p">([</span><span class="n">StructField</span><span class="p">(</span><span class="s2">&quot;data&quot;</span><span class="p">,</span> <span class="n">StringType</span><span class="p">(),</span> <span class="kc">False</span><span class="p">)])</span>
    <span class="n">globs</span><span class="p">[</span><span class="s1">&#39;df&#39;</span><span class="p">]</span> <span class="o">=</span> \
        <span class="n">globs</span><span class="p">[</span><span class="s1">&#39;spark&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">readStream</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;text&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;python/test_support/sql/streaming&#39;</span><span class="p">)</span>

    <span class="p">(</span><span class="n">failure_count</span><span class="p">,</span> <span class="n">test_count</span><span class="p">)</span> <span class="o">=</span> <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">(</span>
        <span class="n">pyspark</span><span class="o">.</span><span class="n">sql</span><span class="o">.</span><span class="n">streaming</span><span class="p">,</span> <span class="n">globs</span><span class="o">=</span><span class="n">globs</span><span class="p">,</span>
        <span class="n">optionflags</span><span class="o">=</span><span class="n">doctest</span><span class="o">.</span><span class="n">ELLIPSIS</span> <span class="o">|</span> <span class="n">doctest</span><span class="o">.</span><span class="n">NORMALIZE_WHITESPACE</span> <span class="o">|</span> <span class="n">doctest</span><span class="o">.</span><span class="n">REPORT_NDIFF</span><span class="p">)</span>
    <span class="n">globs</span><span class="p">[</span><span class="s1">&#39;spark&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">failure_count</span><span class="p">:</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">_test</span><span class="p">()</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/spark-logo-hd.png" alt="Logo"/>
            </a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
    
        <li class="nav-item nav-item-0"><a href="../../../index.html">PySpark 2.1.2 documentation</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright .
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.6.
    </div>
  </body>
</html>