<table class="table">
  <thead>
    <tr>
      <th style="width:25%">Function</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>aes_decrypt(expr, key[, mode[, padding]])</td>
      <td>Returns a decrypted value of `expr` using AES in `mode` with `padding`.
      Key lengths of 16, 24 and 32 bits are supported. Supported combinations of (`mode`, `padding`) are ('ECB', 'PKCS') and ('GCM', 'NONE').
      The default mode is GCM.</td>
    </tr>
    <tr>
      <td>aes_encrypt(expr, key[, mode[, padding]])</td>
      <td>Returns an encrypted value of `expr` using AES in given `mode` with the specified `padding`.
      Key lengths of 16, 24 and 32 bits are supported. Supported combinations of (`mode`, `padding`) are ('ECB', 'PKCS') and ('GCM', 'NONE').
      The default mode is GCM.</td>
    </tr>
    <tr>
      <td>assert_true(expr)</td>
      <td>Throws an exception if `expr` is not true.</td>
    </tr>
    <tr>
      <td>current_catalog()</td>
      <td>Returns the current catalog.</td>
    </tr>
    <tr>
      <td>current_database()</td>
      <td>Returns the current database.</td>
    </tr>
    <tr>
      <td>current_user()</td>
      <td>user name of current execution context.</td>
    </tr>
    <tr>
      <td>input_file_block_length()</td>
      <td>Returns the length of the block being read, or -1 if not available.</td>
    </tr>
    <tr>
      <td>input_file_block_start()</td>
      <td>Returns the start offset of the block being read, or -1 if not available.</td>
    </tr>
    <tr>
      <td>input_file_name()</td>
      <td>Returns the name of the file being read, or empty string if not available.</td>
    </tr>
    <tr>
      <td>java_method(class, method[, arg1[, arg2 ..]])</td>
      <td>Calls a method with reflection.</td>
    </tr>
    <tr>
      <td>monotonically_increasing_id()</td>
      <td>Returns monotonically increasing 64-bit integers. The generated ID is guaranteed
      to be monotonically increasing and unique, but not consecutive. The current implementation
      puts the partition ID in the upper 31 bits, and the lower 33 bits represent the record number
      within each partition. The assumption is that the data frame has less than 1 billion
      partitions, and each partition has less than 8 billion records.
      The function is non-deterministic because its result depends on partition IDs.</td>
    </tr>
    <tr>
      <td>reflect(class, method[, arg1[, arg2 ..]])</td>
      <td>Calls a method with reflection.</td>
    </tr>
    <tr>
      <td>spark_partition_id()</td>
      <td>Returns the current partition id.</td>
    </tr>
    <tr>
      <td>typeof(expr)</td>
      <td>Return DDL-formatted type string for the data type of the input.</td>
    </tr>
    <tr>
      <td>uuid()</td>
      <td>Returns an universally unique identifier (UUID) string. The value is returned as a canonical UUID 36-character string.</td>
    </tr>
    <tr>
      <td>version()</td>
      <td>Returns the Spark version. The string contains 2 fields, the first being a release version and the second being a git revision.</td>
    </tr>
  </tbody>
</table>
