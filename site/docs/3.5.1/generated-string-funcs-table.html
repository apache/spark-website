<table class="table">
  <thead>
    <tr>
      <th style="width:25%">Function</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ascii(str)</td>
      <td>Returns the numeric value of the first character of `str`.</td>
    </tr>
    <tr>
      <td>base64(bin)</td>
      <td>Converts the argument from a binary `bin` to a base 64 string.</td>
    </tr>
    <tr>
      <td>bit_length(expr)</td>
      <td>Returns the bit length of string data or number of bits of binary data.</td>
    </tr>
    <tr>
      <td>btrim(str)</td>
      <td>Removes the leading and trailing space characters from `str`.</td>
    </tr>
    <tr>
      <td>    btrim(str, trimStr)</td>
      <td>Remove the leading and trailing `trimStr` characters from `str`.</td>
    </tr>
    <tr>
      <td>char(expr)</td>
      <td>Returns the ASCII character having the binary equivalent to `expr`. If n is larger than 256 the result is equivalent to chr(n % 256)</td>
    </tr>
    <tr>
      <td>char_length(expr)</td>
      <td>Returns the character length of string data or number of bytes of binary data. The length of string data includes the trailing spaces. The length of binary data includes binary zeros.</td>
    </tr>
    <tr>
      <td>character_length(expr)</td>
      <td>Returns the character length of string data or number of bytes of binary data. The length of string data includes the trailing spaces. The length of binary data includes binary zeros.</td>
    </tr>
    <tr>
      <td>chr(expr)</td>
      <td>Returns the ASCII character having the binary equivalent to `expr`. If n is larger than 256 the result is equivalent to chr(n % 256)</td>
    </tr>
    <tr>
      <td>concat_ws(sep[, str | array(str)]+)</td>
      <td>Returns the concatenation of the strings separated by `sep`, skipping null values.</td>
    </tr>
    <tr>
      <td>contains(left, right)</td>
      <td>Returns a boolean. The value is True if right is found inside left.
    Returns NULL if either input expression is NULL. Otherwise, returns False.
    Both left or right must be of STRING or BINARY type.</td>
    </tr>
    <tr>
      <td>decode(bin, charset)</td>
      <td>Decodes the first argument using the second argument character set.</td>
    </tr>
    <tr>
      <td>    decode(expr, search, result [, search, result ] ... [, default])</td>
      <td>Compares expr
      to each search value in order. If expr is equal to a search value, decode returns
      the corresponding result. If no match is found, then it returns default. If default
      is omitted, it returns null.</td>
    </tr>
    <tr>
      <td>elt(n, input1, input2, ...)</td>
      <td>Returns the `n`-th input, e.g., returns `input2` when `n` is 2.
    The function returns NULL if the index exceeds the length of the array
    and `spark.sql.ansi.enabled` is set to false. If `spark.sql.ansi.enabled` is set to true,
    it throws ArrayIndexOutOfBoundsException for invalid indices.</td>
    </tr>
    <tr>
      <td>encode(str, charset)</td>
      <td>Encodes the first argument using the second argument character set.</td>
    </tr>
    <tr>
      <td>endswith(left, right)</td>
      <td>Returns a boolean. The value is True if left ends with right.
    Returns NULL if either input expression is NULL. Otherwise, returns False.
    Both left or right must be of STRING or BINARY type.</td>
    </tr>
    <tr>
      <td>find_in_set(str, str_array)</td>
      <td>Returns the index (1-based) of the given string (`str`) in the comma-delimited list (`str_array`).
      Returns 0, if the string was not found or if the given string (`str`) contains a comma.</td>
    </tr>
    <tr>
      <td>format_number(expr1, expr2)</td>
      <td>Formats the number `expr1` like '#,###,###.##', rounded to `expr2`
      decimal places. If `expr2` is 0, the result has no decimal point or fractional part.
      `expr2` also accept a user specified format.
      This is supposed to function like MySQL's FORMAT.</td>
    </tr>
    <tr>
      <td>format_string(strfmt, obj, ...)</td>
      <td>Returns a formatted string from printf-style format strings.</td>
    </tr>
    <tr>
      <td>initcap(str)</td>
      <td>Returns `str` with the first letter of each word in uppercase.
      All other letters are in lowercase. Words are delimited by white space.</td>
    </tr>
    <tr>
      <td>instr(str, substr)</td>
      <td>Returns the (1-based) index of the first occurrence of `substr` in `str`.</td>
    </tr>
    <tr>
      <td>lcase(str)</td>
      <td>Returns `str` with all characters changed to lowercase.</td>
    </tr>
    <tr>
      <td>left(str, len)</td>
      <td>Returns the leftmost `len`(`len` can be string type) characters from the string `str`,if `len` is less or equal than 0 the result is an empty string.</td>
    </tr>
    <tr>
      <td>len(expr)</td>
      <td>Returns the character length of string data or number of bytes of binary data. The length of string data includes the trailing spaces. The length of binary data includes binary zeros.</td>
    </tr>
    <tr>
      <td>length(expr)</td>
      <td>Returns the character length of string data or number of bytes of binary data. The length of string data includes the trailing spaces. The length of binary data includes binary zeros.</td>
    </tr>
    <tr>
      <td>levenshtein(str1, str2[, threshold])</td>
      <td>Returns the Levenshtein distance between the two given strings. If threshold is set and distance more than it, return -1.</td>
    </tr>
    <tr>
      <td>locate(substr, str[, pos])</td>
      <td>Returns the position of the first occurrence of `substr` in `str` after position `pos`.
      The given `pos` and return value are 1-based.</td>
    </tr>
    <tr>
      <td>lower(str)</td>
      <td>Returns `str` with all characters changed to lowercase.</td>
    </tr>
    <tr>
      <td>lpad(str, len[, pad])</td>
      <td>Returns `str`, left-padded with `pad` to a length of `len`.
      If `str` is longer than `len`, the return value is shortened to `len` characters or bytes.
      If `pad` is not specified, `str` will be padded to the left with space characters if it is
      a character string, and with zeros if it is a byte sequence.</td>
    </tr>
    <tr>
      <td>ltrim(str)</td>
      <td>Removes the leading space characters from `str`.</td>
    </tr>
    <tr>
      <td>luhn_check(str )</td>
      <td>Checks that a string of digits is valid according to the Luhn algorithm.
    This checksum function is widely applied on credit card numbers and government identification
    numbers to distinguish valid numbers from mistyped, incorrect numbers.</td>
    </tr>
    <tr>
      <td>mask(input[, upperChar, lowerChar, digitChar, otherChar])</td>
      <td>masks the given string value.
       The function replaces characters with 'X' or 'x', and numbers with 'n'.
       This can be useful for creating copies of tables with sensitive information removed.</td>
    </tr>
    <tr>
      <td>octet_length(expr)</td>
      <td>Returns the byte length of string data or number of bytes of binary data.</td>
    </tr>
    <tr>
      <td>overlay(input, replace, pos[, len])</td>
      <td>Replace `input` with `replace` that starts at `pos` and is of length `len`.</td>
    </tr>
    <tr>
      <td>position(substr, str[, pos])</td>
      <td>Returns the position of the first occurrence of `substr` in `str` after position `pos`.
      The given `pos` and return value are 1-based.</td>
    </tr>
    <tr>
      <td>printf(strfmt, obj, ...)</td>
      <td>Returns a formatted string from printf-style format strings.</td>
    </tr>
    <tr>
      <td>regexp_count(str, regexp)</td>
      <td>Returns a count of the number of times that the regular expression pattern `regexp` is matched in the string `str`.</td>
    </tr>
    <tr>
      <td>regexp_extract(str, regexp[, idx])</td>
      <td>Extract the first string in the `str` that match the `regexp`
    expression and corresponding to the regex group index.</td>
    </tr>
    <tr>
      <td>regexp_extract_all(str, regexp[, idx])</td>
      <td>Extract all strings in the `str` that match the `regexp`
    expression and corresponding to the regex group index.</td>
    </tr>
    <tr>
      <td>regexp_instr(str, regexp)</td>
      <td>Searches a string for a regular expression and returns an integer that indicates the beginning position of the matched substring. Positions are 1-based, not 0-based. If no match is found, returns 0.</td>
    </tr>
    <tr>
      <td>regexp_replace(str, regexp, rep[, position])</td>
      <td>Replaces all substrings of `str` that match `regexp` with `rep`.</td>
    </tr>
    <tr>
      <td>regexp_substr(str, regexp)</td>
      <td>Returns the substring that matches the regular expression `regexp` within the string `str`. If the regular expression is not found, the result is null.</td>
    </tr>
    <tr>
      <td>repeat(str, n)</td>
      <td>Returns the string which repeats the given string value n times.</td>
    </tr>
    <tr>
      <td>replace(str, search[, replace])</td>
      <td>Replaces all occurrences of `search` with `replace`.</td>
    </tr>
    <tr>
      <td>right(str, len)</td>
      <td>Returns the rightmost `len`(`len` can be string type) characters from the string `str`,if `len` is less or equal than 0 the result is an empty string.</td>
    </tr>
    <tr>
      <td>rpad(str, len[, pad])</td>
      <td>Returns `str`, right-padded with `pad` to a length of `len`.
      If `str` is longer than `len`, the return value is shortened to `len` characters.
      If `pad` is not specified, `str` will be padded to the right with space characters if it is
      a character string, and with zeros if it is a binary string.</td>
    </tr>
    <tr>
      <td>rtrim(str)</td>
      <td>Removes the trailing space characters from `str`.</td>
    </tr>
    <tr>
      <td>sentences(str[, lang, country])</td>
      <td>Splits `str` into an array of array of words.</td>
    </tr>
    <tr>
      <td>soundex(str)</td>
      <td>Returns Soundex code of the string.</td>
    </tr>
    <tr>
      <td>space(n)</td>
      <td>Returns a string consisting of `n` spaces.</td>
    </tr>
    <tr>
      <td>split(str, regex, limit)</td>
      <td>Splits `str` around occurrences that match `regex` and returns an array with a length of at most `limit`</td>
    </tr>
    <tr>
      <td>split_part(str, delimiter, partNum)</td>
      <td>Splits `str` by delimiter and return
      requested part of the split (1-based). If any input is null, returns null.
      if `partNum` is out of range of split parts, returns empty string. If `partNum` is 0,
      throws an error. If `partNum` is negative, the parts are counted backward from the
      end of the string. If the `delimiter` is an empty string, the `str` is not split.</td>
    </tr>
    <tr>
      <td>startswith(left, right)</td>
      <td>Returns a boolean. The value is True if left starts with right.
    Returns NULL if either input expression is NULL. Otherwise, returns False.
    Both left or right must be of STRING or BINARY type.</td>
    </tr>
    <tr>
      <td>substr(str, pos[, len])</td>
      <td>Returns the substring of `str` that starts at `pos` and is of length `len`, or the slice of byte array that starts at `pos` and is of length `len`.</td>
    </tr>
    <tr>
      <td>    substr(str FROM pos[ FOR len]])</td>
      <td>Returns the substring of `str` that starts at `pos` and is of length `len`, or the slice of byte array that starts at `pos` and is of length `len`.</td>
    </tr>
    <tr>
      <td>substring(str, pos[, len])</td>
      <td>Returns the substring of `str` that starts at `pos` and is of length `len`, or the slice of byte array that starts at `pos` and is of length `len`.</td>
    </tr>
    <tr>
      <td>    substring(str FROM pos[ FOR len]])</td>
      <td>Returns the substring of `str` that starts at `pos` and is of length `len`, or the slice of byte array that starts at `pos` and is of length `len`.</td>
    </tr>
    <tr>
      <td>substring_index(str, delim, count)</td>
      <td>Returns the substring from `str` before `count` occurrences of the delimiter `delim`.
      If `count` is positive, everything to the left of the final delimiter (counting from the
      left) is returned. If `count` is negative, everything to the right of the final delimiter
      (counting from the right) is returned. The function substring_index performs a case-sensitive match
      when searching for `delim`.</td>
    </tr>
    <tr>
      <td>to_binary(str[, fmt])</td>
      <td>Converts the input `str` to a binary value based on the supplied `fmt`.
      `fmt` can be a case-insensitive string literal of "hex", "utf-8", "utf8", or "base64".
      By default, the binary format for conversion is "hex" if `fmt` is omitted.
      The function returns NULL if at least one of the input parameters is NULL.</td>
    </tr>
    <tr>
      <td>to_char(numberExpr, formatExpr)</td>
      <td>Convert `numberExpr` to a string based on the `formatExpr`.
      Throws an exception if the conversion fails. The format can consist of the following
      characters, case insensitive:
        '0' or '9': Specifies an expected digit between 0 and 9. A sequence of 0 or 9 in the format
          string matches a sequence of digits in the input value, generating a result string of the
          same length as the corresponding sequence in the format string. The result string is
          left-padded with zeros if the 0/9 sequence comprises more digits than the matching part of
          the decimal value, starts with 0, and is before the decimal point. Otherwise, it is
          padded with spaces.
        '.' or 'D': Specifies the position of the decimal point (optional, only allowed once).
        ',' or 'G': Specifies the position of the grouping (thousands) separator (,). There must be
          a 0 or 9 to the left and right of each grouping separator.
        '$': Specifies the location of the $ currency sign. This character may only be specified
          once.
        'S' or 'MI': Specifies the position of a '-' or '+' sign (optional, only allowed once at
          the beginning or end of the format string). Note that 'S' prints '+' for positive values
          but 'MI' prints a space.
        'PR': Only allowed at the end of the format string; specifies that the result string will be
          wrapped by angle brackets if the input value is negative.
          ('<1>').</td>
    </tr>
    <tr>
      <td>to_number(expr, fmt)</td>
      <td>Convert string 'expr' to a number based on the string format 'fmt'.
       Throws an exception if the conversion fails. The format can consist of the following
       characters, case insensitive:
         '0' or '9': Specifies an expected digit between 0 and 9. A sequence of 0 or 9 in the format
           string matches a sequence of digits in the input string. If the 0/9 sequence starts with
           0 and is before the decimal point, it can only match a digit sequence of the same size.
           Otherwise, if the sequence starts with 9 or is after the decimal point, it can match a
           digit sequence that has the same or smaller size.
         '.' or 'D': Specifies the position of the decimal point (optional, only allowed once).
         ',' or 'G': Specifies the position of the grouping (thousands) separator (,). There must be
           a 0 or 9 to the left and right of each grouping separator. 'expr' must match the
           grouping separator relevant for the size of the number.
         '$': Specifies the location of the $ currency sign. This character may only be specified
           once.
         'S' or 'MI': Specifies the position of a '-' or '+' sign (optional, only allowed once at
           the beginning or end of the format string). Note that 'S' allows '-' but 'MI' does not.
         'PR': Only allowed at the end of the format string; specifies that 'expr' indicates a
           negative number with wrapping angled brackets.
           ('<1>').</td>
    </tr>
    <tr>
      <td>to_varchar(numberExpr, formatExpr)</td>
      <td>Convert `numberExpr` to a string based on the `formatExpr`.
      Throws an exception if the conversion fails. The format can consist of the following
      characters, case insensitive:
        '0' or '9': Specifies an expected digit between 0 and 9. A sequence of 0 or 9 in the format
          string matches a sequence of digits in the input value, generating a result string of the
          same length as the corresponding sequence in the format string. The result string is
          left-padded with zeros if the 0/9 sequence comprises more digits than the matching part of
          the decimal value, starts with 0, and is before the decimal point. Otherwise, it is
          padded with spaces.
        '.' or 'D': Specifies the position of the decimal point (optional, only allowed once).
        ',' or 'G': Specifies the position of the grouping (thousands) separator (,). There must be
          a 0 or 9 to the left and right of each grouping separator.
        '$': Specifies the location of the $ currency sign. This character may only be specified
          once.
        'S' or 'MI': Specifies the position of a '-' or '+' sign (optional, only allowed once at
          the beginning or end of the format string). Note that 'S' prints '+' for positive values
          but 'MI' prints a space.
        'PR': Only allowed at the end of the format string; specifies that the result string will be
          wrapped by angle brackets if the input value is negative.
          ('<1>').</td>
    </tr>
    <tr>
      <td>translate(input, from, to)</td>
      <td>Translates the `input` string by replacing the characters present in the `from` string with the corresponding characters in the `to` string.</td>
    </tr>
    <tr>
      <td>trim(str)</td>
      <td>Removes the leading and trailing space characters from `str`.</td>
    </tr>
    <tr>
      <td>    trim(BOTH FROM str)</td>
      <td>Removes the leading and trailing space characters from `str`.</td>
    </tr>
    <tr>
      <td>    trim(LEADING FROM str)</td>
      <td>Removes the leading space characters from `str`.</td>
    </tr>
    <tr>
      <td>    trim(TRAILING FROM str)</td>
      <td>Removes the trailing space characters from `str`.</td>
    </tr>
    <tr>
      <td>    trim(trimStr FROM str)</td>
      <td>Remove the leading and trailing `trimStr` characters from `str`.</td>
    </tr>
    <tr>
      <td>    trim(BOTH trimStr FROM str)</td>
      <td>Remove the leading and trailing `trimStr` characters from `str`.</td>
    </tr>
    <tr>
      <td>    trim(LEADING trimStr FROM str)</td>
      <td>Remove the leading `trimStr` characters from `str`.</td>
    </tr>
    <tr>
      <td>    trim(TRAILING trimStr FROM str)</td>
      <td>Remove the trailing `trimStr` characters from `str`.</td>
    </tr>
    <tr>
      <td>try_to_binary(str[, fmt])</td>
      <td>This is a special version of `to_binary` that performs the same operation, but returns a NULL value instead of raising an error if the conversion cannot be performed.</td>
    </tr>
    <tr>
      <td>try_to_number(expr, fmt)</td>
      <td>Convert string 'expr' to a number based on the string format `fmt`.
       Returns NULL if the string 'expr' does not match the expected format. The format follows the
       same semantics as the to_number function.</td>
    </tr>
    <tr>
      <td>ucase(str)</td>
      <td>Returns `str` with all characters changed to uppercase.</td>
    </tr>
    <tr>
      <td>unbase64(str)</td>
      <td>Converts the argument from a base 64 string `str` to a binary.</td>
    </tr>
    <tr>
      <td>upper(str)</td>
      <td>Returns `str` with all characters changed to uppercase.</td>
    </tr>
  </tbody>
</table>
