<table class="table">
  <thead>
    <tr>
      <th style="width:25%">Function</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>array(expr, ...)</td>
      <td>Returns an array with the given elements.</td>
    </tr>
    <tr>
      <td>array_append(array, element)</td>
      <td>Add the element at the end of the array passed as first
      argument. Type of element should be similar to type of the elements of the array.
      Null element is also appended into the array. But if the array passed, is NULL
      output is NULL</td>
    </tr>
    <tr>
      <td>array_compact(array)</td>
      <td>Removes null values from the array.</td>
    </tr>
    <tr>
      <td>array_contains(array, value)</td>
      <td>Returns true if the array contains the value.</td>
    </tr>
    <tr>
      <td>array_distinct(array)</td>
      <td>Removes duplicate values from the array.</td>
    </tr>
    <tr>
      <td>array_except(array1, array2)</td>
      <td>Returns an array of the elements in array1 but not in array2,
    without duplicates.</td>
    </tr>
    <tr>
      <td>array_insert(x, pos, val)</td>
      <td>Places val into index pos of array x.
      Array indices start at 1. The maximum negative index is -1 for which the function inserts
      new element after the current last element.
      Index above array size appends the array, or prepends the array if index is negative,
      with 'null' elements.</td>
    </tr>
    <tr>
      <td>array_intersect(array1, array2)</td>
      <td>Returns an array of the elements in the intersection of array1 and
    array2, without duplicates.</td>
    </tr>
    <tr>
      <td>array_join(array, delimiter[, nullReplacement])</td>
      <td>Concatenates the elements of the given array
      using the delimiter and an optional string to replace nulls. If no value is set for
      nullReplacement, any null value is filtered.</td>
    </tr>
    <tr>
      <td>array_max(array)</td>
      <td>Returns the maximum value in the array. NaN is greater than
    any non-NaN elements for double/float type. NULL elements are skipped.</td>
    </tr>
    <tr>
      <td>array_min(array)</td>
      <td>Returns the minimum value in the array. NaN is greater than
    any non-NaN elements for double/float type. NULL elements are skipped.</td>
    </tr>
    <tr>
      <td>array_position(array, element)</td>
      <td>Returns the (1-based) index of the first matching element of
      the array as long, or 0 if no match is found.</td>
    </tr>
    <tr>
      <td>array_prepend(array, element)</td>
      <td>Add the element at the beginning of the array passed as first
      argument. Type of element should be the same as the type of the elements of the array.
      Null element is also prepended to the array. But if the array passed is NULL
      output is NULL</td>
    </tr>
    <tr>
      <td>array_remove(array, element)</td>
      <td>Remove all elements that equal to element from array.</td>
    </tr>
    <tr>
      <td>array_repeat(element, count)</td>
      <td>Returns the array containing element count times.</td>
    </tr>
    <tr>
      <td>array_union(array1, array2)</td>
      <td>Returns an array of the elements in the union of array1 and array2,
      without duplicates.</td>
    </tr>
    <tr>
      <td>arrays_overlap(a1, a2)</td>
      <td>Returns true if a1 contains at least a non-null element present also in a2. If the arrays have no common element and they are both non-empty and either of them contains a null element null is returned, false otherwise.</td>
    </tr>
    <tr>
      <td>arrays_zip(a1, a2, ...)</td>
      <td>Returns a merged array of structs in which the N-th struct contains all
    N-th values of input arrays.</td>
    </tr>
    <tr>
      <td>flatten(arrayOfArrays)</td>
      <td>Transforms an array of arrays into a single array.</td>
    </tr>
    <tr>
      <td>get(array, index)</td>
      <td>Returns element of array at given (0-based) index. If the index points
     outside of the array boundaries, then this function returns NULL.</td>
    </tr>
    <tr>
      <td>sequence(start, stop, step)</td>
      <td>Generates an array of elements from start to stop (inclusive),
      incrementing by step. The type of the returned elements is the same as the type of argument
      expressions.

      Supported types are: byte, short, integer, long, date, timestamp.

      The start and stop expressions must resolve to the same type.
      If start and stop expressions resolve to the 'date' or 'timestamp' type
      then the step expression must resolve to the 'interval' or 'year-month interval' or
      'day-time interval' type, otherwise to the same type as the start and stop expressions.</td>
    </tr>
    <tr>
      <td>shuffle(array)</td>
      <td>Returns a random permutation of the given array.</td>
    </tr>
    <tr>
      <td>slice(x, start, length)</td>
      <td>Subsets array x starting from index start (array indices start at 1, or starting from the end if start is negative) with the specified length.</td>
    </tr>
    <tr>
      <td>sort_array(array[, ascendingOrder])</td>
      <td>Sorts the input array in ascending or descending order
      according to the natural ordering of the array elements. NaN is greater than any non-NaN
      elements for double/float type. Null elements will be placed at the beginning of the returned
      array in ascending order or at the end of the returned array in descending order.</td>
    </tr>
  </tbody>
</table>
