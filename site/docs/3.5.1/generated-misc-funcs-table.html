<table class="table">
  <thead>
    <tr>
      <th style="width:25%">Function</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>aes_decrypt(expr, key[, mode[, padding[, aad]]])</td>
      <td>Returns a decrypted value of `expr` using AES in `mode` with `padding`.
      Key lengths of 16, 24 and 32 bits are supported. Supported combinations of (`mode`, `padding`) are ('ECB', 'PKCS'), ('GCM', 'NONE') and ('CBC', 'PKCS').
      Optional additional authenticated data (AAD) is only supported for GCM. If provided for encryption, the identical AAD value must be provided for decryption.
      The default mode is GCM.</td>
    </tr>
    <tr>
      <td>aes_encrypt(expr, key[, mode[, padding[, iv[, aad]]]])</td>
      <td>Returns an encrypted value of `expr` using AES in given `mode` with the specified `padding`.
      Key lengths of 16, 24 and 32 bits are supported. Supported combinations of (`mode`, `padding`) are ('ECB', 'PKCS'), ('GCM', 'NONE') and ('CBC', 'PKCS').
      Optional initialization vectors (IVs) are only supported for CBC and GCM modes. These must be 16 bytes for CBC and 12 bytes for GCM. If not provided, a random vector will be generated and prepended to the output.
      Optional additional authenticated data (AAD) is only supported for GCM. If provided for encryption, the identical AAD value must be provided for decryption.
      The default mode is GCM.</td>
    </tr>
    <tr>
      <td>assert_true(expr)</td>
      <td>Throws an exception if `expr` is not true.</td>
    </tr>
    <tr>
      <td>bitmap_bit_position(child)</td>
      <td>Returns the bit position for the given input child expression.</td>
    </tr>
    <tr>
      <td>bitmap_bucket_number(child)</td>
      <td>Returns the bucket number for the given input child expression.</td>
    </tr>
    <tr>
      <td>bitmap_count(child)</td>
      <td>Returns the number of set bits in the child bitmap.</td>
    </tr>
    <tr>
      <td>current_catalog()</td>
      <td>Returns the current catalog.</td>
    </tr>
    <tr>
      <td>current_database()</td>
      <td>Returns the current database.</td>
    </tr>
    <tr>
      <td>current_schema()</td>
      <td>Returns the current database.</td>
    </tr>
    <tr>
      <td>current_user()</td>
      <td>user name of current execution context.</td>
    </tr>
    <tr>
      <td>equal_null(expr1, expr2)</td>
      <td>Returns same result as the EQUAL(=) operator for non-null operands,
      but returns true if both are null, false if one of the them is null.</td>
    </tr>
    <tr>
      <td>hll_sketch_estimate(expr)</td>
      <td>Returns the estimated number of unique values given the binary representation
    of a Datasketches HllSketch.</td>
    </tr>
    <tr>
      <td>hll_union(first, second, allowDifferentLgConfigK)</td>
      <td>Merges two binary representations of
    Datasketches HllSketch objects, using a Datasketches Union object. Set
    allowDifferentLgConfigK to true to allow unions of sketches with different
    lgConfigK values (defaults to false).</td>
    </tr>
    <tr>
      <td>input_file_block_length()</td>
      <td>Returns the length of the block being read, or -1 if not available.</td>
    </tr>
    <tr>
      <td>input_file_block_start()</td>
      <td>Returns the start offset of the block being read, or -1 if not available.</td>
    </tr>
    <tr>
      <td>input_file_name()</td>
      <td>Returns the name of the file being read, or empty string if not available.</td>
    </tr>
    <tr>
      <td>java_method(class, method[, arg1[, arg2 ..]])</td>
      <td>Calls a method with reflection.</td>
    </tr>
    <tr>
      <td>monotonically_increasing_id()</td>
      <td>Returns monotonically increasing 64-bit integers. The generated ID is guaranteed
      to be monotonically increasing and unique, but not consecutive. The current implementation
      puts the partition ID in the upper 31 bits, and the lower 33 bits represent the record number
      within each partition. The assumption is that the data frame has less than 1 billion
      partitions, and each partition has less than 8 billion records.
      The function is non-deterministic because its result depends on partition IDs.</td>
    </tr>
    <tr>
      <td>reflect(class, method[, arg1[, arg2 ..]])</td>
      <td>Calls a method with reflection.</td>
    </tr>
    <tr>
      <td>spark_partition_id()</td>
      <td>Returns the current partition id.</td>
    </tr>
    <tr>
      <td>try_aes_decrypt(expr, key[, mode[, padding[, aad]]])</td>
      <td>This is a special version of `aes_decrypt` that performs the same operation, but returns a NULL value instead of raising an error if the decryption cannot be performed.</td>
    </tr>
    <tr>
      <td>typeof(expr)</td>
      <td>Return DDL-formatted type string for the data type of the input.</td>
    </tr>
    <tr>
      <td>user()</td>
      <td>user name of current execution context.</td>
    </tr>
    <tr>
      <td>uuid()</td>
      <td>Returns an universally unique identifier (UUID) string. The value is returned as a canonical UUID 36-character string.</td>
    </tr>
    <tr>
      <td>version()</td>
      <td>Returns the Spark version. The string contains 2 fields, the first being a release version and the second being a git revision.</td>
    </tr>
  </tbody>
</table>
