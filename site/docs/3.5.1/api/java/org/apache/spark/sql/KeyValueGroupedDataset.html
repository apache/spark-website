<!DOCTYPE HTML>
<html lang="ko">
<head>
<!-- Generated by javadoc (17) on Sat Feb 24 16:16:59 KST 2024 -->
<title>KeyValueGroupedDataset (Spark 3.5.1 JavaDoc)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2024-02-24">
<meta name="description" content="declaration: package: org.apache.spark.sql, class: KeyValueGroupedDataset">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var evenRowColor = "even-row-color";
var oddRowColor = "odd-row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top">
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-all.html">Index</a></li>
<li><a href="../../../../help-doc.html#class">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search-input">SEARCH:</label>
<input type="text" id="search-input" value="search" disabled="disabled">
<input type="reset" id="reset-button" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">org.apache.spark.sql</a></div>
<h1 title="Class KeyValueGroupedDataset" class="title">Class KeyValueGroupedDataset&lt;K,<wbr>V&gt;</h1>
</div>
<div class="inheritance" title="Inheritance Tree"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a>
<div class="inheritance">org.apache.spark.sql.KeyValueGroupedDataset&lt;K,<wbr>V&gt;</div>
</div>
<section class="class-description" id="class-description">
<dl class="notes">
<dt>All Implemented Interfaces:</dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Serializable.html" title="class or interface in java.io" class="external-link">Serializable</a></code>, <code>scala.Serializable</code></dd>
</dl>
<hr>
<div class="type-signature"><span class="modifiers">public class </span><span class="element-name type-name-label">KeyValueGroupedDataset&lt;K,<wbr>V&gt;</span>
<span class="extends-implements">extends <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a>
implements scala.Serializable</span></div>
<div class="block">A <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> has been logically grouped by a user specified grouping key.  Users should not
 construct a <a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql"><code>KeyValueGroupedDataset</code></a> directly, but should instead call <code>groupByKey</code> on
 an existing <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a>.
 <p></div>
<dl class="notes">
<dt>Since:</dt>
<dd>2.0.0</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list">
<li><a href="../../../../serialized-form.html#org.apache.spark.sql.KeyValueGroupedDataset">Serialized Form</a></li>
</ul>
</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab2" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab2', 3)" class="table-tab">Instance Methods</button><button id="method-summary-table-tab4" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab4', 3)" class="table-tab">Concrete Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;U1&gt;&nbsp;<a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;scala.Tuple2&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>U1&gt;&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#agg(org.apache.spark.sql.TypedColumn)" class="member-name-link">agg</a><wbr>(<a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U1&gt;&nbsp;col1)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Computes the given aggregation, returning a <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> of tuples for each unique key
 and the result of computing this aggregation over all elements in the group.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;U1,<wbr>
U2&gt;&nbsp;<a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;scala.Tuple3&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>U1,<wbr>U2&gt;&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#agg(org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn)" class="member-name-link">agg</a><wbr>(<a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U1&gt;&nbsp;col1,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U2&gt;&nbsp;col2)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Computes the given aggregations, returning a <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> of tuples for each unique key
 and the result of computing these aggregations over all elements in the group.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;U1,<wbr>
U2,<wbr>
U3&gt;&nbsp;<a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;scala.Tuple4&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>U1,<wbr>U2,<wbr>U3&gt;&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#agg(org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn)" class="member-name-link">agg</a><wbr>(<a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U1&gt;&nbsp;col1,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U2&gt;&nbsp;col2,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U3&gt;&nbsp;col3)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Computes the given aggregations, returning a <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> of tuples for each unique key
 and the result of computing these aggregations over all elements in the group.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;U1,<wbr>
U2,<wbr>
U3,<wbr>
U4&gt;<br><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;scala.Tuple5&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>U1,<wbr>U2,<wbr>U3,<wbr>U4&gt;&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#agg(org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn)" class="member-name-link">agg</a><wbr>(<a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U1&gt;&nbsp;col1,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U2&gt;&nbsp;col2,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U3&gt;&nbsp;col3,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U4&gt;&nbsp;col4)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Computes the given aggregations, returning a <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> of tuples for each unique key
 and the result of computing these aggregations over all elements in the group.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;U1,<wbr>
U2,<wbr>
U3,<wbr>
U4,<wbr>
U5&gt;<br><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;scala.Tuple6&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>U1,<wbr>U2,<wbr>U3,<wbr>U4,<wbr>U5&gt;&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#agg(org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn)" class="member-name-link">agg</a><wbr>(<a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U1&gt;&nbsp;col1,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U2&gt;&nbsp;col2,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U3&gt;&nbsp;col3,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U4&gt;&nbsp;col4,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U5&gt;&nbsp;col5)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Computes the given aggregations, returning a <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> of tuples for each unique key
 and the result of computing these aggregations over all elements in the group.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;U1,<wbr>
U2,<wbr>
U3,<wbr>
U4,<wbr>
U5,<wbr>
U6&gt;<br><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;scala.Tuple7&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>U1,<wbr>U2,<wbr>U3,<wbr>U4,<wbr>U5,<wbr>U6&gt;&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#agg(org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn)" class="member-name-link">agg</a><wbr>(<a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U1&gt;&nbsp;col1,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U2&gt;&nbsp;col2,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U3&gt;&nbsp;col3,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U4&gt;&nbsp;col4,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U5&gt;&nbsp;col5,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U6&gt;&nbsp;col6)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Computes the given aggregations, returning a <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> of tuples for each unique key
 and the result of computing these aggregations over all elements in the group.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;U1,<wbr>
U2,<wbr>
U3,<wbr>
U4,<wbr>
U5,<wbr>
U6,<wbr>
U7&gt;<br><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;scala.Tuple8&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>U1,<wbr>U2,<wbr>U3,<wbr>U4,<wbr>U5,<wbr>U6,<wbr>U7&gt;&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#agg(org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn)" class="member-name-link">agg</a><wbr>(<a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U1&gt;&nbsp;col1,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U2&gt;&nbsp;col2,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U3&gt;&nbsp;col3,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U4&gt;&nbsp;col4,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U5&gt;&nbsp;col5,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U6&gt;&nbsp;col6,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U7&gt;&nbsp;col7)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Computes the given aggregations, returning a <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> of tuples for each unique key
 and the result of computing these aggregations over all elements in the group.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;U1,<wbr>
U2,<wbr>
U3,<wbr>
U4,<wbr>
U5,<wbr>
U6,<wbr>
U7,<wbr>
U8&gt;<br><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;scala.Tuple9&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>U1,<wbr>U2,<wbr>U3,<wbr>U4,<wbr>U5,<wbr>U6,<wbr>U7,<wbr>U8&gt;&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#agg(org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn)" class="member-name-link">agg</a><wbr>(<a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U1&gt;&nbsp;col1,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U2&gt;&nbsp;col2,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U3&gt;&nbsp;col3,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U4&gt;&nbsp;col4,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U5&gt;&nbsp;col5,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U6&gt;&nbsp;col6,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U7&gt;&nbsp;col7,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U8&gt;&nbsp;col8)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Computes the given aggregations, returning a <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> of tuples for each unique key
 and the result of computing these aggregations over all elements in the group.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;U,<wbr>
R&gt;&nbsp;<a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;R&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#cogroup(org.apache.spark.sql.KeyValueGroupedDataset,org.apache.spark.api.java.function.CoGroupFunction,org.apache.spark.sql.Encoder)" class="member-name-link">cogroup</a><wbr>(<a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql">KeyValueGroupedDataset</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>U&gt;&nbsp;other,
 <a href="../api/java/function/CoGroupFunction.html" title="interface in org.apache.spark.api.java.function">CoGroupFunction</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U,<wbr>R&gt;&nbsp;f,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;R&gt;&nbsp;encoder)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">(Java-specific)
 Applies the given function to each cogrouped data.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;U,<wbr>
R&gt;&nbsp;<a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;R&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#cogroup(org.apache.spark.sql.KeyValueGroupedDataset,scala.Function3,org.apache.spark.sql.Encoder)" class="member-name-link">cogroup</a><wbr>(<a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql">KeyValueGroupedDataset</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>U&gt;&nbsp;other,
 scala.Function3&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>scala.collection.Iterator&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;,<wbr>scala.collection.Iterator&lt;U&gt;,<wbr>scala.collection.TraversableOnce&lt;R&gt;&gt;&nbsp;f,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;R&gt;&nbsp;evidence$16)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">(Scala-specific)
 Applies the given function to each cogrouped data.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;U,<wbr>
R&gt;&nbsp;<a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;R&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#cogroupSorted(org.apache.spark.sql.KeyValueGroupedDataset,org.apache.spark.sql.Column%5B%5D,org.apache.spark.sql.Column%5B%5D,org.apache.spark.api.java.function.CoGroupFunction,org.apache.spark.sql.Encoder)" class="member-name-link">cogroupSorted</a><wbr>(<a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql">KeyValueGroupedDataset</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>U&gt;&nbsp;other,
 <a href="Column.html" title="class in org.apache.spark.sql">Column</a>[]&nbsp;thisSortExprs,
 <a href="Column.html" title="class in org.apache.spark.sql">Column</a>[]&nbsp;otherSortExprs,
 <a href="../api/java/function/CoGroupFunction.html" title="interface in org.apache.spark.api.java.function">CoGroupFunction</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U,<wbr>R&gt;&nbsp;f,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;R&gt;&nbsp;encoder)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">(Java-specific)
 Applies the given function to each sorted cogrouped data.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;U,<wbr>
R&gt;&nbsp;<a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;R&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#cogroupSorted(org.apache.spark.sql.KeyValueGroupedDataset,scala.collection.Seq,scala.collection.Seq,scala.Function3,org.apache.spark.sql.Encoder)" class="member-name-link">cogroupSorted</a><wbr>(<a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql">KeyValueGroupedDataset</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>U&gt;&nbsp;other,
 scala.collection.Seq&lt;<a href="Column.html" title="class in org.apache.spark.sql">Column</a>&gt;&nbsp;thisSortExprs,
 scala.collection.Seq&lt;<a href="Column.html" title="class in org.apache.spark.sql">Column</a>&gt;&nbsp;otherSortExprs,
 scala.Function3&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>scala.collection.Iterator&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;,<wbr>scala.collection.Iterator&lt;U&gt;,<wbr>scala.collection.TraversableOnce&lt;R&gt;&gt;&nbsp;f,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;R&gt;&nbsp;evidence$17)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">(Scala-specific)
 Applies the given function to each sorted cogrouped data.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;scala.Tuple2&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a>&gt;&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#count()" class="member-name-link">count</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Returns a <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> that contains a tuple with each key and the number of items present
 for that key.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;U&gt;&nbsp;<a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#flatMapGroups(org.apache.spark.api.java.function.FlatMapGroupsFunction,org.apache.spark.sql.Encoder)" class="member-name-link">flatMapGroups</a><wbr>(<a href="../api/java/function/FlatMapGroupsFunction.html" title="interface in org.apache.spark.api.java.function">FlatMapGroupsFunction</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U&gt;&nbsp;f,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;encoder)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">(Java-specific)
 Applies the given function to each group of data.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;U&gt;&nbsp;<a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#flatMapGroups(scala.Function2,org.apache.spark.sql.Encoder)" class="member-name-link">flatMapGroups</a><wbr>(scala.Function2&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>scala.collection.Iterator&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;,<wbr>scala.collection.TraversableOnce&lt;U&gt;&gt;&nbsp;f,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;evidence$3)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">(Scala-specific)
 Applies the given function to each group of data.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;S,<wbr>
U&gt;&nbsp;<a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#flatMapGroupsWithState(org.apache.spark.api.java.function.FlatMapGroupsWithStateFunction,org.apache.spark.sql.streaming.OutputMode,org.apache.spark.sql.Encoder,org.apache.spark.sql.Encoder,org.apache.spark.sql.streaming.GroupStateTimeout)" class="member-name-link">flatMapGroupsWithState</a><wbr>(<a href="../api/java/function/FlatMapGroupsWithStateFunction.html" title="interface in org.apache.spark.api.java.function">FlatMapGroupsWithStateFunction</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>S,<wbr>U&gt;&nbsp;func,
 <a href="streaming/OutputMode.html" title="class in org.apache.spark.sql.streaming">OutputMode</a>&nbsp;outputMode,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;S&gt;&nbsp;stateEncoder,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;outputEncoder,
 <a href="streaming/GroupStateTimeout.html" title="class in org.apache.spark.sql.streaming">GroupStateTimeout</a>&nbsp;timeoutConf)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">(Java-specific)
 Applies the given function to each group of data, while maintaining a user-defined per-group
 state.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;S,<wbr>
U&gt;&nbsp;<a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#flatMapGroupsWithState(org.apache.spark.api.java.function.FlatMapGroupsWithStateFunction,org.apache.spark.sql.streaming.OutputMode,org.apache.spark.sql.Encoder,org.apache.spark.sql.Encoder,org.apache.spark.sql.streaming.GroupStateTimeout,org.apache.spark.sql.KeyValueGroupedDataset)" class="member-name-link">flatMapGroupsWithState</a><wbr>(<a href="../api/java/function/FlatMapGroupsWithStateFunction.html" title="interface in org.apache.spark.api.java.function">FlatMapGroupsWithStateFunction</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>S,<wbr>U&gt;&nbsp;func,
 <a href="streaming/OutputMode.html" title="class in org.apache.spark.sql.streaming">OutputMode</a>&nbsp;outputMode,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;S&gt;&nbsp;stateEncoder,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;outputEncoder,
 <a href="streaming/GroupStateTimeout.html" title="class in org.apache.spark.sql.streaming">GroupStateTimeout</a>&nbsp;timeoutConf,
 <a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql">KeyValueGroupedDataset</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>S&gt;&nbsp;initialState)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">(Java-specific)
 Applies the given function to each group of data, while maintaining a user-defined per-group
 state.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;S,<wbr>
U&gt;&nbsp;<a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#flatMapGroupsWithState(org.apache.spark.sql.streaming.OutputMode,org.apache.spark.sql.streaming.GroupStateTimeout,org.apache.spark.sql.KeyValueGroupedDataset,scala.Function3,org.apache.spark.sql.Encoder,org.apache.spark.sql.Encoder)" class="member-name-link">flatMapGroupsWithState</a><wbr>(<a href="streaming/OutputMode.html" title="class in org.apache.spark.sql.streaming">OutputMode</a>&nbsp;outputMode,
 <a href="streaming/GroupStateTimeout.html" title="class in org.apache.spark.sql.streaming">GroupStateTimeout</a>&nbsp;timeoutConf,
 <a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql">KeyValueGroupedDataset</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>S&gt;&nbsp;initialState,
 scala.Function3&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>scala.collection.Iterator&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;,<wbr><a href="streaming/GroupState.html" title="interface in org.apache.spark.sql.streaming">GroupState</a>&lt;S&gt;,<wbr>scala.collection.Iterator&lt;U&gt;&gt;&nbsp;func,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;S&gt;&nbsp;evidence$14,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;evidence$15)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">(Scala-specific)
 Applies the given function to each group of data, while maintaining a user-defined per-group
 state.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;S,<wbr>
U&gt;&nbsp;<a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#flatMapGroupsWithState(org.apache.spark.sql.streaming.OutputMode,org.apache.spark.sql.streaming.GroupStateTimeout,scala.Function3,org.apache.spark.sql.Encoder,org.apache.spark.sql.Encoder)" class="member-name-link">flatMapGroupsWithState</a><wbr>(<a href="streaming/OutputMode.html" title="class in org.apache.spark.sql.streaming">OutputMode</a>&nbsp;outputMode,
 <a href="streaming/GroupStateTimeout.html" title="class in org.apache.spark.sql.streaming">GroupStateTimeout</a>&nbsp;timeoutConf,
 scala.Function3&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>scala.collection.Iterator&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;,<wbr><a href="streaming/GroupState.html" title="interface in org.apache.spark.sql.streaming">GroupState</a>&lt;S&gt;,<wbr>scala.collection.Iterator&lt;U&gt;&gt;&nbsp;func,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;S&gt;&nbsp;evidence$12,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;evidence$13)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">(Scala-specific)
 Applies the given function to each group of data, while maintaining a user-defined per-group
 state.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;U&gt;&nbsp;<a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#flatMapSortedGroups(org.apache.spark.sql.Column%5B%5D,org.apache.spark.api.java.function.FlatMapGroupsFunction,org.apache.spark.sql.Encoder)" class="member-name-link">flatMapSortedGroups</a><wbr>(<a href="Column.html" title="class in org.apache.spark.sql">Column</a>[]&nbsp;SortExprs,
 <a href="../api/java/function/FlatMapGroupsFunction.html" title="interface in org.apache.spark.api.java.function">FlatMapGroupsFunction</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U&gt;&nbsp;f,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;encoder)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">(Java-specific)
 Applies the given function to each group of data.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;U&gt;&nbsp;<a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#flatMapSortedGroups(scala.collection.Seq,scala.Function2,org.apache.spark.sql.Encoder)" class="member-name-link">flatMapSortedGroups</a><wbr>(scala.collection.Seq&lt;<a href="Column.html" title="class in org.apache.spark.sql">Column</a>&gt;&nbsp;sortExprs,
 scala.Function2&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>scala.collection.Iterator&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;,<wbr>scala.collection.TraversableOnce&lt;U&gt;&gt;&nbsp;f,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;evidence$4)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">(Scala-specific)
 Applies the given function to each group of data.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;L&gt;&nbsp;<a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql">KeyValueGroupedDataset</a>&lt;L,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#keyAs(org.apache.spark.sql.Encoder)" class="member-name-link">keyAs</a><wbr>(<a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;L&gt;&nbsp;evidence$1)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Returns a new <a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql"><code>KeyValueGroupedDataset</code></a> where the type of the key has been mapped to the
 specified type.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#keys()" class="member-name-link">keys</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Returns a <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> that contains each unique key.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;U&gt;&nbsp;<a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#mapGroups(org.apache.spark.api.java.function.MapGroupsFunction,org.apache.spark.sql.Encoder)" class="member-name-link">mapGroups</a><wbr>(<a href="../api/java/function/MapGroupsFunction.html" title="interface in org.apache.spark.api.java.function">MapGroupsFunction</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U&gt;&nbsp;f,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;encoder)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">(Java-specific)
 Applies the given function to each group of data.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;U&gt;&nbsp;<a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#mapGroups(scala.Function2,org.apache.spark.sql.Encoder)" class="member-name-link">mapGroups</a><wbr>(scala.Function2&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>scala.collection.Iterator&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;,<wbr>U&gt;&nbsp;f,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;evidence$5)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">(Scala-specific)
 Applies the given function to each group of data.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;S,<wbr>
U&gt;&nbsp;<a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#mapGroupsWithState(org.apache.spark.api.java.function.MapGroupsWithStateFunction,org.apache.spark.sql.Encoder,org.apache.spark.sql.Encoder)" class="member-name-link">mapGroupsWithState</a><wbr>(<a href="../api/java/function/MapGroupsWithStateFunction.html" title="interface in org.apache.spark.api.java.function">MapGroupsWithStateFunction</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>S,<wbr>U&gt;&nbsp;func,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;S&gt;&nbsp;stateEncoder,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;outputEncoder)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">(Java-specific)
 Applies the given function to each group of data, while maintaining a user-defined per-group
 state.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;S,<wbr>
U&gt;&nbsp;<a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#mapGroupsWithState(org.apache.spark.api.java.function.MapGroupsWithStateFunction,org.apache.spark.sql.Encoder,org.apache.spark.sql.Encoder,org.apache.spark.sql.streaming.GroupStateTimeout)" class="member-name-link">mapGroupsWithState</a><wbr>(<a href="../api/java/function/MapGroupsWithStateFunction.html" title="interface in org.apache.spark.api.java.function">MapGroupsWithStateFunction</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>S,<wbr>U&gt;&nbsp;func,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;S&gt;&nbsp;stateEncoder,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;outputEncoder,
 <a href="streaming/GroupStateTimeout.html" title="class in org.apache.spark.sql.streaming">GroupStateTimeout</a>&nbsp;timeoutConf)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">(Java-specific)
 Applies the given function to each group of data, while maintaining a user-defined per-group
 state.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;S,<wbr>
U&gt;&nbsp;<a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#mapGroupsWithState(org.apache.spark.api.java.function.MapGroupsWithStateFunction,org.apache.spark.sql.Encoder,org.apache.spark.sql.Encoder,org.apache.spark.sql.streaming.GroupStateTimeout,org.apache.spark.sql.KeyValueGroupedDataset)" class="member-name-link">mapGroupsWithState</a><wbr>(<a href="../api/java/function/MapGroupsWithStateFunction.html" title="interface in org.apache.spark.api.java.function">MapGroupsWithStateFunction</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>S,<wbr>U&gt;&nbsp;func,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;S&gt;&nbsp;stateEncoder,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;outputEncoder,
 <a href="streaming/GroupStateTimeout.html" title="class in org.apache.spark.sql.streaming">GroupStateTimeout</a>&nbsp;timeoutConf,
 <a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql">KeyValueGroupedDataset</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>S&gt;&nbsp;initialState)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">(Java-specific)
 Applies the given function to each group of data, while maintaining a user-defined per-group
 state.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;S,<wbr>
U&gt;&nbsp;<a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#mapGroupsWithState(org.apache.spark.sql.streaming.GroupStateTimeout,org.apache.spark.sql.KeyValueGroupedDataset,scala.Function3,org.apache.spark.sql.Encoder,org.apache.spark.sql.Encoder)" class="member-name-link">mapGroupsWithState</a><wbr>(<a href="streaming/GroupStateTimeout.html" title="class in org.apache.spark.sql.streaming">GroupStateTimeout</a>&nbsp;timeoutConf,
 <a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql">KeyValueGroupedDataset</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>S&gt;&nbsp;initialState,
 scala.Function3&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>scala.collection.Iterator&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;,<wbr><a href="streaming/GroupState.html" title="interface in org.apache.spark.sql.streaming">GroupState</a>&lt;S&gt;,<wbr>U&gt;&nbsp;func,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;S&gt;&nbsp;evidence$10,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;evidence$11)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">(Scala-specific)
 Applies the given function to each group of data, while maintaining a user-defined per-group
 state.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;S,<wbr>
U&gt;&nbsp;<a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#mapGroupsWithState(org.apache.spark.sql.streaming.GroupStateTimeout,scala.Function3,org.apache.spark.sql.Encoder,org.apache.spark.sql.Encoder)" class="member-name-link">mapGroupsWithState</a><wbr>(<a href="streaming/GroupStateTimeout.html" title="class in org.apache.spark.sql.streaming">GroupStateTimeout</a>&nbsp;timeoutConf,
 scala.Function3&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>scala.collection.Iterator&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;,<wbr><a href="streaming/GroupState.html" title="interface in org.apache.spark.sql.streaming">GroupState</a>&lt;S&gt;,<wbr>U&gt;&nbsp;func,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;S&gt;&nbsp;evidence$8,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;evidence$9)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">(Scala-specific)
 Applies the given function to each group of data, while maintaining a user-defined per-group
 state.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;S,<wbr>
U&gt;&nbsp;<a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#mapGroupsWithState(scala.Function3,org.apache.spark.sql.Encoder,org.apache.spark.sql.Encoder)" class="member-name-link">mapGroupsWithState</a><wbr>(scala.Function3&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>scala.collection.Iterator&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;,<wbr><a href="streaming/GroupState.html" title="interface in org.apache.spark.sql.streaming">GroupState</a>&lt;S&gt;,<wbr>U&gt;&nbsp;func,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;S&gt;&nbsp;evidence$6,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;evidence$7)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">(Scala-specific)
 Applies the given function to each group of data, while maintaining a user-defined per-group
 state.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;W&gt;&nbsp;<a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql">KeyValueGroupedDataset</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>W&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#mapValues(org.apache.spark.api.java.function.MapFunction,org.apache.spark.sql.Encoder)" class="member-name-link">mapValues</a><wbr>(<a href="../api/java/function/MapFunction.html" title="interface in org.apache.spark.api.java.function">MapFunction</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>W&gt;&nbsp;func,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;W&gt;&nbsp;encoder)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Returns a new <a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql"><code>KeyValueGroupedDataset</code></a> where the given function <code>func</code> has been applied
 to the data.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>&lt;W&gt;&nbsp;<a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql">KeyValueGroupedDataset</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>W&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#mapValues(scala.Function1,org.apache.spark.sql.Encoder)" class="member-name-link">mapValues</a><wbr>(scala.Function1&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>W&gt;&nbsp;func,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;W&gt;&nbsp;evidence$2)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">Returns a new <a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql"><code>KeyValueGroupedDataset</code></a> where the given function <code>func</code> has been applied
 to the data.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code>org.apache.spark.sql.execution.QueryExecution</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#queryExecution()" class="member-name-link">queryExecution</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">&nbsp;</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;scala.Tuple2&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#reduceGroups(org.apache.spark.api.java.function.ReduceFunction)" class="member-name-link">reduceGroups</a><wbr>(<a href="../api/java/function/ReduceFunction.html" title="interface in org.apache.spark.api.java.function">ReduceFunction</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;&nbsp;f)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">(Java-specific)
 Reduces the elements of each group of data using the specified binary function.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;scala.Tuple2&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#reduceGroups(scala.Function2)" class="member-name-link">reduceGroups</a><wbr>(scala.Function2&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;&nbsp;f)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">
<div class="block">(Scala-specific)
 Reduces the elements of each group of data using the specified binary function.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4"><code><a href="#toString()" class="member-name-link">toString</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab4">&nbsp;</div>
</div>
</div>
</div>
<div class="inherited-list">
<h3 id="methods-inherited-from-class-Object">Methods inherited from class&nbsp;java.lang.<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></h3>
<code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)" title="class or interface in java.lang" class="external-link">equals</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#getClass()" title="class or interface in java.lang" class="external-link">getClass</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#hashCode()" title="class or interface in java.lang" class="external-link">hashCode</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#notify()" title="class or interface in java.lang" class="external-link">notify</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#notifyAll()" title="class or interface in java.lang" class="external-link">notifyAll</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait()" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait(long)" title="class or interface in java.lang" class="external-link">wait</a>, <a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#wait(long,int)" title="class or interface in java.lang" class="external-link">wait</a></code></div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="agg(org.apache.spark.sql.TypedColumn)">
<h3>agg</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;U1&gt;</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;scala.Tuple2&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>U1&gt;&gt;</span>&nbsp;<span class="element-name">agg</span><wbr><span class="parameters">(<a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U1&gt;&nbsp;col1)</span></div>
<div class="block">Computes the given aggregation, returning a <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> of tuples for each unique key
 and the result of computing this aggregation over all elements in the group.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>col1</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>1.6.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="agg(org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn)">
<h3>agg</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;U1,<wbr>
U2&gt;</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;scala.Tuple3&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>U1,<wbr>U2&gt;&gt;</span>&nbsp;<span class="element-name">agg</span><wbr><span class="parameters">(<a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U1&gt;&nbsp;col1,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U2&gt;&nbsp;col2)</span></div>
<div class="block">Computes the given aggregations, returning a <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> of tuples for each unique key
 and the result of computing these aggregations over all elements in the group.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>col1</code> - (undocumented)</dd>
<dd><code>col2</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>1.6.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="agg(org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn)">
<h3>agg</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;U1,<wbr>
U2,<wbr>
U3&gt;</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;scala.Tuple4&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>U1,<wbr>U2,<wbr>U3&gt;&gt;</span>&nbsp;<span class="element-name">agg</span><wbr><span class="parameters">(<a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U1&gt;&nbsp;col1,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U2&gt;&nbsp;col2,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U3&gt;&nbsp;col3)</span></div>
<div class="block">Computes the given aggregations, returning a <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> of tuples for each unique key
 and the result of computing these aggregations over all elements in the group.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>col1</code> - (undocumented)</dd>
<dd><code>col2</code> - (undocumented)</dd>
<dd><code>col3</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>1.6.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="agg(org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn)">
<h3>agg</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;U1,<wbr>
U2,<wbr>
U3,<wbr>
U4&gt;</span>
<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;scala.Tuple5&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>U1,<wbr>U2,<wbr>U3,<wbr>U4&gt;&gt;</span>&nbsp;<span class="element-name">agg</span><wbr><span class="parameters">(<a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U1&gt;&nbsp;col1,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U2&gt;&nbsp;col2,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U3&gt;&nbsp;col3,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U4&gt;&nbsp;col4)</span></div>
<div class="block">Computes the given aggregations, returning a <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> of tuples for each unique key
 and the result of computing these aggregations over all elements in the group.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>col1</code> - (undocumented)</dd>
<dd><code>col2</code> - (undocumented)</dd>
<dd><code>col3</code> - (undocumented)</dd>
<dd><code>col4</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>1.6.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="agg(org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn)">
<h3>agg</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;U1,<wbr>
U2,<wbr>
U3,<wbr>
U4,<wbr>
U5&gt;</span>
<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;scala.Tuple6&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>U1,<wbr>U2,<wbr>U3,<wbr>U4,<wbr>U5&gt;&gt;</span>&nbsp;<span class="element-name">agg</span><wbr><span class="parameters">(<a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U1&gt;&nbsp;col1,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U2&gt;&nbsp;col2,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U3&gt;&nbsp;col3,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U4&gt;&nbsp;col4,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U5&gt;&nbsp;col5)</span></div>
<div class="block">Computes the given aggregations, returning a <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> of tuples for each unique key
 and the result of computing these aggregations over all elements in the group.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>col1</code> - (undocumented)</dd>
<dd><code>col2</code> - (undocumented)</dd>
<dd><code>col3</code> - (undocumented)</dd>
<dd><code>col4</code> - (undocumented)</dd>
<dd><code>col5</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>3.0.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="agg(org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn)">
<h3>agg</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;U1,<wbr>
U2,<wbr>
U3,<wbr>
U4,<wbr>
U5,<wbr>
U6&gt;</span>
<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;scala.Tuple7&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>U1,<wbr>U2,<wbr>U3,<wbr>U4,<wbr>U5,<wbr>U6&gt;&gt;</span>&nbsp;<span class="element-name">agg</span><wbr><span class="parameters">(<a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U1&gt;&nbsp;col1,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U2&gt;&nbsp;col2,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U3&gt;&nbsp;col3,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U4&gt;&nbsp;col4,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U5&gt;&nbsp;col5,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U6&gt;&nbsp;col6)</span></div>
<div class="block">Computes the given aggregations, returning a <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> of tuples for each unique key
 and the result of computing these aggregations over all elements in the group.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>col1</code> - (undocumented)</dd>
<dd><code>col2</code> - (undocumented)</dd>
<dd><code>col3</code> - (undocumented)</dd>
<dd><code>col4</code> - (undocumented)</dd>
<dd><code>col5</code> - (undocumented)</dd>
<dd><code>col6</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>3.0.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="agg(org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn)">
<h3>agg</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;U1,<wbr>
U2,<wbr>
U3,<wbr>
U4,<wbr>
U5,<wbr>
U6,<wbr>
U7&gt;</span>
<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;scala.Tuple8&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>U1,<wbr>U2,<wbr>U3,<wbr>U4,<wbr>U5,<wbr>U6,<wbr>U7&gt;&gt;</span>&nbsp;<span class="element-name">agg</span><wbr><span class="parameters">(<a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U1&gt;&nbsp;col1,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U2&gt;&nbsp;col2,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U3&gt;&nbsp;col3,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U4&gt;&nbsp;col4,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U5&gt;&nbsp;col5,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U6&gt;&nbsp;col6,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U7&gt;&nbsp;col7)</span></div>
<div class="block">Computes the given aggregations, returning a <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> of tuples for each unique key
 and the result of computing these aggregations over all elements in the group.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>col1</code> - (undocumented)</dd>
<dd><code>col2</code> - (undocumented)</dd>
<dd><code>col3</code> - (undocumented)</dd>
<dd><code>col4</code> - (undocumented)</dd>
<dd><code>col5</code> - (undocumented)</dd>
<dd><code>col6</code> - (undocumented)</dd>
<dd><code>col7</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>3.0.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="agg(org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn,org.apache.spark.sql.TypedColumn)">
<h3>agg</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;U1,<wbr>
U2,<wbr>
U3,<wbr>
U4,<wbr>
U5,<wbr>
U6,<wbr>
U7,<wbr>
U8&gt;</span>
<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;scala.Tuple9&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>U1,<wbr>U2,<wbr>U3,<wbr>U4,<wbr>U5,<wbr>U6,<wbr>U7,<wbr>U8&gt;&gt;</span>&nbsp;<span class="element-name">agg</span><wbr><span class="parameters">(<a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U1&gt;&nbsp;col1,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U2&gt;&nbsp;col2,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U3&gt;&nbsp;col3,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U4&gt;&nbsp;col4,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U5&gt;&nbsp;col5,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U6&gt;&nbsp;col6,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U7&gt;&nbsp;col7,
 <a href="TypedColumn.html" title="class in org.apache.spark.sql">TypedColumn</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U8&gt;&nbsp;col8)</span></div>
<div class="block">Computes the given aggregations, returning a <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> of tuples for each unique key
 and the result of computing these aggregations over all elements in the group.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>col1</code> - (undocumented)</dd>
<dd><code>col2</code> - (undocumented)</dd>
<dd><code>col3</code> - (undocumented)</dd>
<dd><code>col4</code> - (undocumented)</dd>
<dd><code>col5</code> - (undocumented)</dd>
<dd><code>col6</code> - (undocumented)</dd>
<dd><code>col7</code> - (undocumented)</dd>
<dd><code>col8</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>3.0.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="cogroup(org.apache.spark.sql.KeyValueGroupedDataset,scala.Function3,org.apache.spark.sql.Encoder)">
<h3>cogroup</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;U,<wbr>
R&gt;</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;R&gt;</span>&nbsp;<span class="element-name">cogroup</span><wbr><span class="parameters">(<a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql">KeyValueGroupedDataset</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>U&gt;&nbsp;other,
 scala.Function3&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>scala.collection.Iterator&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;,<wbr>scala.collection.Iterator&lt;U&gt;,<wbr>scala.collection.TraversableOnce&lt;R&gt;&gt;&nbsp;f,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;R&gt;&nbsp;evidence$16)</span></div>
<div class="block">(Scala-specific)
 Applies the given function to each cogrouped data.  For each unique group, the function will
 be passed the grouping key and 2 iterators containing all elements in the group from
 <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> <code>this</code> and <code>other</code>.  The function can return an iterator containing elements of an
 arbitrary type which will be returned as a new <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a>.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>other</code> - (undocumented)</dd>
<dd><code>f</code> - (undocumented)</dd>
<dd><code>evidence$16</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>1.6.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="cogroup(org.apache.spark.sql.KeyValueGroupedDataset,org.apache.spark.api.java.function.CoGroupFunction,org.apache.spark.sql.Encoder)">
<h3>cogroup</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;U,<wbr>
R&gt;</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;R&gt;</span>&nbsp;<span class="element-name">cogroup</span><wbr><span class="parameters">(<a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql">KeyValueGroupedDataset</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>U&gt;&nbsp;other,
 <a href="../api/java/function/CoGroupFunction.html" title="interface in org.apache.spark.api.java.function">CoGroupFunction</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U,<wbr>R&gt;&nbsp;f,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;R&gt;&nbsp;encoder)</span></div>
<div class="block">(Java-specific)
 Applies the given function to each cogrouped data.  For each unique group, the function will
 be passed the grouping key and 2 iterators containing all elements in the group from
 <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> <code>this</code> and <code>other</code>.  The function can return an iterator containing elements of an
 arbitrary type which will be returned as a new <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a>.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>other</code> - (undocumented)</dd>
<dd><code>f</code> - (undocumented)</dd>
<dd><code>encoder</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>1.6.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="cogroupSorted(org.apache.spark.sql.KeyValueGroupedDataset,scala.collection.Seq,scala.collection.Seq,scala.Function3,org.apache.spark.sql.Encoder)">
<h3>cogroupSorted</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;U,<wbr>
R&gt;</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;R&gt;</span>&nbsp;<span class="element-name">cogroupSorted</span><wbr><span class="parameters">(<a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql">KeyValueGroupedDataset</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>U&gt;&nbsp;other,
 scala.collection.Seq&lt;<a href="Column.html" title="class in org.apache.spark.sql">Column</a>&gt;&nbsp;thisSortExprs,
 scala.collection.Seq&lt;<a href="Column.html" title="class in org.apache.spark.sql">Column</a>&gt;&nbsp;otherSortExprs,
 scala.Function3&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>scala.collection.Iterator&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;,<wbr>scala.collection.Iterator&lt;U&gt;,<wbr>scala.collection.TraversableOnce&lt;R&gt;&gt;&nbsp;f,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;R&gt;&nbsp;evidence$17)</span></div>
<div class="block">(Scala-specific)
 Applies the given function to each sorted cogrouped data.  For each unique group, the function
 will be passed the grouping key and 2 sorted iterators containing all elements in the group
 from <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> <code>this</code> and <code>other</code>.  The function can return an iterator containing elements
 of an arbitrary type which will be returned as a new <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a>.
 <p>
 This is equivalent to <a href="#cogroup(org.apache.spark.sql.KeyValueGroupedDataset,scala.Function3,org.apache.spark.sql.Encoder)"><code>cogroup(org.apache.spark.sql.KeyValueGroupedDataset&lt;K, U&gt;, scala.Function3&lt;K, scala.collection.Iterator&lt;V&gt;, scala.collection.Iterator&lt;U&gt;, scala.collection.TraversableOnce&lt;R&gt;&gt;, org.apache.spark.sql.Encoder&lt;R&gt;)</code></a>, except for the iterators
 to be sorted according to the given sort expressions. That sorting does not add
 computational complexity.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>other</code> - (undocumented)</dd>
<dd><code>thisSortExprs</code> - (undocumented)</dd>
<dd><code>otherSortExprs</code> - (undocumented)</dd>
<dd><code>f</code> - (undocumented)</dd>
<dd><code>evidence$17</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>3.4.0</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#cogroup(org.apache.spark.sql.KeyValueGroupedDataset,scala.Function3,org.apache.spark.sql.Encoder)"><code>cogroup(org.apache.spark.sql.KeyValueGroupedDataset&lt;K, U&gt;, scala.Function3&lt;K, scala.collection.Iterator&lt;V&gt;, scala.collection.Iterator&lt;U&gt;, scala.collection.TraversableOnce&lt;R&gt;&gt;, org.apache.spark.sql.Encoder&lt;R&gt;)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="cogroupSorted(org.apache.spark.sql.KeyValueGroupedDataset,org.apache.spark.sql.Column[],org.apache.spark.sql.Column[],org.apache.spark.api.java.function.CoGroupFunction,org.apache.spark.sql.Encoder)">
<h3>cogroupSorted</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;U,<wbr>
R&gt;</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;R&gt;</span>&nbsp;<span class="element-name">cogroupSorted</span><wbr><span class="parameters">(<a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql">KeyValueGroupedDataset</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>U&gt;&nbsp;other,
 <a href="Column.html" title="class in org.apache.spark.sql">Column</a>[]&nbsp;thisSortExprs,
 <a href="Column.html" title="class in org.apache.spark.sql">Column</a>[]&nbsp;otherSortExprs,
 <a href="../api/java/function/CoGroupFunction.html" title="interface in org.apache.spark.api.java.function">CoGroupFunction</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U,<wbr>R&gt;&nbsp;f,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;R&gt;&nbsp;encoder)</span></div>
<div class="block">(Java-specific)
 Applies the given function to each sorted cogrouped data.  For each unique group, the function
 will be passed the grouping key and 2 sorted iterators containing all elements in the group
 from <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> <code>this</code> and <code>other</code>.  The function can return an iterator containing elements
 of an arbitrary type which will be returned as a new <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a>.
 <p>
 This is equivalent to <a href="#cogroup(org.apache.spark.sql.KeyValueGroupedDataset,scala.Function3,org.apache.spark.sql.Encoder)"><code>cogroup(org.apache.spark.sql.KeyValueGroupedDataset&lt;K, U&gt;, scala.Function3&lt;K, scala.collection.Iterator&lt;V&gt;, scala.collection.Iterator&lt;U&gt;, scala.collection.TraversableOnce&lt;R&gt;&gt;, org.apache.spark.sql.Encoder&lt;R&gt;)</code></a>, except for the iterators
 to be sorted according to the given sort expressions. That sorting does not add
 computational complexity.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>other</code> - (undocumented)</dd>
<dd><code>thisSortExprs</code> - (undocumented)</dd>
<dd><code>otherSortExprs</code> - (undocumented)</dd>
<dd><code>f</code> - (undocumented)</dd>
<dd><code>encoder</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>3.4.0</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#cogroup(org.apache.spark.sql.KeyValueGroupedDataset,scala.Function3,org.apache.spark.sql.Encoder)"><code>cogroup(org.apache.spark.sql.KeyValueGroupedDataset&lt;K, U&gt;, scala.Function3&lt;K, scala.collection.Iterator&lt;V&gt;, scala.collection.Iterator&lt;U&gt;, scala.collection.TraversableOnce&lt;R&gt;&gt;, org.apache.spark.sql.Encoder&lt;R&gt;)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="count()">
<h3>count</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;scala.Tuple2&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a>&gt;&gt;</span>&nbsp;<span class="element-name">count</span>()</div>
<div class="block">Returns a <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> that contains a tuple with each key and the number of items present
 for that key.
 <p></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>1.6.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="flatMapGroups(scala.Function2,org.apache.spark.sql.Encoder)">
<h3>flatMapGroups</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;U&gt;</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</span>&nbsp;<span class="element-name">flatMapGroups</span><wbr><span class="parameters">(scala.Function2&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>scala.collection.Iterator&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;,<wbr>scala.collection.TraversableOnce&lt;U&gt;&gt;&nbsp;f,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;evidence$3)</span></div>
<div class="block">(Scala-specific)
 Applies the given function to each group of data.  For each unique group, the function will
 be passed the group key and an iterator that contains all of the elements in the group. The
 function can return an iterator containing elements of an arbitrary type which will be returned
 as a new <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a>.
 <p>
 This function does not support partial aggregation, and as a result requires shuffling all
 the data in the <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a>. If an application intends to perform an aggregation over each
 key, it is best to use the reduce function or an
 <code>org.apache.spark.sql.expressions#Aggregator</code>.
 <p>
 Internally, the implementation will spill to disk if any given group is too large to fit into
 memory.  However, users must take care to avoid materializing the whole iterator for a group
 (for example, by calling <code>toList</code>) unless they are sure that this is possible given the memory
 constraints of their cluster.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>f</code> - (undocumented)</dd>
<dd><code>evidence$3</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>1.6.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="flatMapGroups(org.apache.spark.api.java.function.FlatMapGroupsFunction,org.apache.spark.sql.Encoder)">
<h3>flatMapGroups</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;U&gt;</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</span>&nbsp;<span class="element-name">flatMapGroups</span><wbr><span class="parameters">(<a href="../api/java/function/FlatMapGroupsFunction.html" title="interface in org.apache.spark.api.java.function">FlatMapGroupsFunction</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U&gt;&nbsp;f,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;encoder)</span></div>
<div class="block">(Java-specific)
 Applies the given function to each group of data.  For each unique group, the function will
 be passed the group key and an iterator that contains all of the elements in the group. The
 function can return an iterator containing elements of an arbitrary type which will be returned
 as a new <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a>.
 <p>
 This function does not support partial aggregation, and as a result requires shuffling all
 the data in the <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a>. If an application intends to perform an aggregation over each
 key, it is best to use the reduce function or an
 <code>org.apache.spark.sql.expressions#Aggregator</code>.
 <p>
 Internally, the implementation will spill to disk if any given group is too large to fit into
 memory.  However, users must take care to avoid materializing the whole iterator for a group
 (for example, by calling <code>toList</code>) unless they are sure that this is possible given the memory
 constraints of their cluster.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>f</code> - (undocumented)</dd>
<dd><code>encoder</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>1.6.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="flatMapGroupsWithState(org.apache.spark.sql.streaming.OutputMode,org.apache.spark.sql.streaming.GroupStateTimeout,scala.Function3,org.apache.spark.sql.Encoder,org.apache.spark.sql.Encoder)">
<h3>flatMapGroupsWithState</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;S,<wbr>
U&gt;</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</span>&nbsp;<span class="element-name">flatMapGroupsWithState</span><wbr><span class="parameters">(<a href="streaming/OutputMode.html" title="class in org.apache.spark.sql.streaming">OutputMode</a>&nbsp;outputMode,
 <a href="streaming/GroupStateTimeout.html" title="class in org.apache.spark.sql.streaming">GroupStateTimeout</a>&nbsp;timeoutConf,
 scala.Function3&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>scala.collection.Iterator&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;,<wbr><a href="streaming/GroupState.html" title="interface in org.apache.spark.sql.streaming">GroupState</a>&lt;S&gt;,<wbr>scala.collection.Iterator&lt;U&gt;&gt;&nbsp;func,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;S&gt;&nbsp;evidence$12,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;evidence$13)</span></div>
<div class="block">(Scala-specific)
 Applies the given function to each group of data, while maintaining a user-defined per-group
 state. The result Dataset will represent the objects returned by the function.
 For a static batch Dataset, the function will be invoked once per group. For a streaming
 Dataset, the function will be invoked for each group repeatedly in every trigger, and
 updates to each group's state will be saved across invocations.
 See <code>GroupState</code> for more details.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>func</code> - Function to be called on every group.</dd>
<dd><code>outputMode</code> - The output mode of the function.</dd>
<dd><code>timeoutConf</code> - Timeout configuration for groups that do not receive data for a while.
 <p>
 See <a href="Encoder.html" title="interface in org.apache.spark.sql"><code>Encoder</code></a> for more details on what types are encodable to Spark SQL.</dd>
<dd><code>evidence$12</code> - (undocumented)</dd>
<dd><code>evidence$13</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>2.2.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="flatMapGroupsWithState(org.apache.spark.sql.streaming.OutputMode,org.apache.spark.sql.streaming.GroupStateTimeout,org.apache.spark.sql.KeyValueGroupedDataset,scala.Function3,org.apache.spark.sql.Encoder,org.apache.spark.sql.Encoder)">
<h3>flatMapGroupsWithState</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;S,<wbr>
U&gt;</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</span>&nbsp;<span class="element-name">flatMapGroupsWithState</span><wbr><span class="parameters">(<a href="streaming/OutputMode.html" title="class in org.apache.spark.sql.streaming">OutputMode</a>&nbsp;outputMode,
 <a href="streaming/GroupStateTimeout.html" title="class in org.apache.spark.sql.streaming">GroupStateTimeout</a>&nbsp;timeoutConf,
 <a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql">KeyValueGroupedDataset</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>S&gt;&nbsp;initialState,
 scala.Function3&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>scala.collection.Iterator&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;,<wbr><a href="streaming/GroupState.html" title="interface in org.apache.spark.sql.streaming">GroupState</a>&lt;S&gt;,<wbr>scala.collection.Iterator&lt;U&gt;&gt;&nbsp;func,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;S&gt;&nbsp;evidence$14,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;evidence$15)</span></div>
<div class="block">(Scala-specific)
 Applies the given function to each group of data, while maintaining a user-defined per-group
 state. The result Dataset will represent the objects returned by the function.
 For a static batch Dataset, the function will be invoked once per group. For a streaming
 Dataset, the function will be invoked for each group repeatedly in every trigger, and
 updates to each group's state will be saved across invocations.
 See <code>GroupState</code> for more details.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>func</code> - Function to be called on every group.</dd>
<dd><code>outputMode</code> - The output mode of the function.</dd>
<dd><code>timeoutConf</code> - Timeout configuration for groups that do not receive data for a while.</dd>
<dd><code>initialState</code> - The user provided state that will be initialized when the first batch
                     of data is processed in the streaming query. The user defined function
                     will be called on the state data even if there are no other values in
                     the group. To covert a Dataset <code>ds</code> of type  of type <code>Dataset[(K, S)]</code>
                     to a <code>KeyValueGroupedDataset[K, S]</code>, use
                     <pre><code> ds.groupByKey(x =&gt; x._1).mapValues(_._2) </code></pre>
 See {&#64;link Encoder} for more details on what types are encodable to Spark SQL.
 &#64;since 3.2.0</dd>
<dd><code>evidence$14</code> - (undocumented)</dd>
<dd><code>evidence$15</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="flatMapGroupsWithState(org.apache.spark.api.java.function.FlatMapGroupsWithStateFunction,org.apache.spark.sql.streaming.OutputMode,org.apache.spark.sql.Encoder,org.apache.spark.sql.Encoder,org.apache.spark.sql.streaming.GroupStateTimeout)">
<h3>flatMapGroupsWithState</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;S,<wbr>
U&gt;</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</span>&nbsp;<span class="element-name">flatMapGroupsWithState</span><wbr><span class="parameters">(<a href="../api/java/function/FlatMapGroupsWithStateFunction.html" title="interface in org.apache.spark.api.java.function">FlatMapGroupsWithStateFunction</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>S,<wbr>U&gt;&nbsp;func,
 <a href="streaming/OutputMode.html" title="class in org.apache.spark.sql.streaming">OutputMode</a>&nbsp;outputMode,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;S&gt;&nbsp;stateEncoder,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;outputEncoder,
 <a href="streaming/GroupStateTimeout.html" title="class in org.apache.spark.sql.streaming">GroupStateTimeout</a>&nbsp;timeoutConf)</span></div>
<div class="block">(Java-specific)
 Applies the given function to each group of data, while maintaining a user-defined per-group
 state. The result Dataset will represent the objects returned by the function.
 For a static batch Dataset, the function will be invoked once per group. For a streaming
 Dataset, the function will be invoked for each group repeatedly in every trigger, and
 updates to each group's state will be saved across invocations.
 See <code>GroupState</code> for more details.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>func</code> - Function to be called on every group.</dd>
<dd><code>outputMode</code> - The output mode of the function.</dd>
<dd><code>stateEncoder</code> - Encoder for the state type.</dd>
<dd><code>outputEncoder</code> - Encoder for the output type.</dd>
<dd><code>timeoutConf</code> - Timeout configuration for groups that do not receive data for a while.
 <p>
 See <a href="Encoder.html" title="interface in org.apache.spark.sql"><code>Encoder</code></a> for more details on what types are encodable to Spark SQL.</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>2.2.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="flatMapGroupsWithState(org.apache.spark.api.java.function.FlatMapGroupsWithStateFunction,org.apache.spark.sql.streaming.OutputMode,org.apache.spark.sql.Encoder,org.apache.spark.sql.Encoder,org.apache.spark.sql.streaming.GroupStateTimeout,org.apache.spark.sql.KeyValueGroupedDataset)">
<h3>flatMapGroupsWithState</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;S,<wbr>
U&gt;</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</span>&nbsp;<span class="element-name">flatMapGroupsWithState</span><wbr><span class="parameters">(<a href="../api/java/function/FlatMapGroupsWithStateFunction.html" title="interface in org.apache.spark.api.java.function">FlatMapGroupsWithStateFunction</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>S,<wbr>U&gt;&nbsp;func,
 <a href="streaming/OutputMode.html" title="class in org.apache.spark.sql.streaming">OutputMode</a>&nbsp;outputMode,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;S&gt;&nbsp;stateEncoder,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;outputEncoder,
 <a href="streaming/GroupStateTimeout.html" title="class in org.apache.spark.sql.streaming">GroupStateTimeout</a>&nbsp;timeoutConf,
 <a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql">KeyValueGroupedDataset</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>S&gt;&nbsp;initialState)</span></div>
<div class="block">(Java-specific)
 Applies the given function to each group of data, while maintaining a user-defined per-group
 state. The result Dataset will represent the objects returned by the function.
 For a static batch Dataset, the function will be invoked once per group. For a streaming
 Dataset, the function will be invoked for each group repeatedly in every trigger, and
 updates to each group's state will be saved across invocations.
 See <code>GroupState</code> for more details.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>func</code> - Function to be called on every group.</dd>
<dd><code>outputMode</code> - The output mode of the function.</dd>
<dd><code>stateEncoder</code> - Encoder for the state type.</dd>
<dd><code>outputEncoder</code> - Encoder for the output type.</dd>
<dd><code>timeoutConf</code> - Timeout configuration for groups that do not receive data for a while.</dd>
<dd><code>initialState</code> - The user provided state that will be initialized when the first batch
                     of data is processed in the streaming query. The user defined function
                     will be called on the state data even if there are no other values in
                     the group. To covert a Dataset <code>ds</code> of type  of type <code>Dataset[(K, S)]</code>
                     to a <code>KeyValueGroupedDataset[K, S]</code>, use
                     <pre><code> ds.groupByKey(x =&gt; x._1).mapValues(_._2) </code></pre>

 See {&#64;link Encoder} for more details on what types are encodable to Spark SQL.
 &#64;since 3.2.0</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="flatMapSortedGroups(scala.collection.Seq,scala.Function2,org.apache.spark.sql.Encoder)">
<h3>flatMapSortedGroups</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;U&gt;</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</span>&nbsp;<span class="element-name">flatMapSortedGroups</span><wbr><span class="parameters">(scala.collection.Seq&lt;<a href="Column.html" title="class in org.apache.spark.sql">Column</a>&gt;&nbsp;sortExprs,
 scala.Function2&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>scala.collection.Iterator&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;,<wbr>scala.collection.TraversableOnce&lt;U&gt;&gt;&nbsp;f,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;evidence$4)</span></div>
<div class="block">(Scala-specific)
 Applies the given function to each group of data.  For each unique group, the function will
 be passed the group key and a sorted iterator that contains all of the elements in the group.
 The function can return an iterator containing elements of an arbitrary type which will be
 returned as a new <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a>.
 <p>
 This function does not support partial aggregation, and as a result requires shuffling all
 the data in the <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a>. If an application intends to perform an aggregation over each
 key, it is best to use the reduce function or an
 <code>org.apache.spark.sql.expressions#Aggregator</code>.
 <p>
 Internally, the implementation will spill to disk if any given group is too large to fit into
 memory.  However, users must take care to avoid materializing the whole iterator for a group
 (for example, by calling <code>toList</code>) unless they are sure that this is possible given the memory
 constraints of their cluster.
 <p>
 This is equivalent to <a href="#flatMapGroups(scala.Function2,org.apache.spark.sql.Encoder)"><code>flatMapGroups(scala.Function2&lt;K, scala.collection.Iterator&lt;V&gt;, scala.collection.TraversableOnce&lt;U&gt;&gt;, org.apache.spark.sql.Encoder&lt;U&gt;)</code></a>, except for the iterator
 to be sorted according to the given sort expressions. That sorting does not add
 computational complexity.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>sortExprs</code> - (undocumented)</dd>
<dd><code>f</code> - (undocumented)</dd>
<dd><code>evidence$4</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>3.4.0</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#flatMapGroups(scala.Function2,org.apache.spark.sql.Encoder)"><code>flatMapGroups(scala.Function2&lt;K, scala.collection.Iterator&lt;V&gt;, scala.collection.TraversableOnce&lt;U&gt;&gt;, org.apache.spark.sql.Encoder&lt;U&gt;)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="flatMapSortedGroups(org.apache.spark.sql.Column[],org.apache.spark.api.java.function.FlatMapGroupsFunction,org.apache.spark.sql.Encoder)">
<h3>flatMapSortedGroups</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;U&gt;</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</span>&nbsp;<span class="element-name">flatMapSortedGroups</span><wbr><span class="parameters">(<a href="Column.html" title="class in org.apache.spark.sql">Column</a>[]&nbsp;SortExprs,
 <a href="../api/java/function/FlatMapGroupsFunction.html" title="interface in org.apache.spark.api.java.function">FlatMapGroupsFunction</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U&gt;&nbsp;f,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;encoder)</span></div>
<div class="block">(Java-specific)
 Applies the given function to each group of data.  For each unique group, the function will
 be passed the group key and a sorted iterator that contains all of the elements in the group.
 The function can return an iterator containing elements of an arbitrary type which will be
 returned as a new <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a>.
 <p>
 This function does not support partial aggregation, and as a result requires shuffling all
 the data in the <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a>. If an application intends to perform an aggregation over each
 key, it is best to use the reduce function or an
 <code>org.apache.spark.sql.expressions#Aggregator</code>.
 <p>
 Internally, the implementation will spill to disk if any given group is too large to fit into
 memory.  However, users must take care to avoid materializing the whole iterator for a group
 (for example, by calling <code>toList</code>) unless they are sure that this is possible given the memory
 constraints of their cluster.
 <p>
 This is equivalent to <a href="#flatMapGroups(scala.Function2,org.apache.spark.sql.Encoder)"><code>flatMapGroups(scala.Function2&lt;K, scala.collection.Iterator&lt;V&gt;, scala.collection.TraversableOnce&lt;U&gt;&gt;, org.apache.spark.sql.Encoder&lt;U&gt;)</code></a>, except for the iterator
 to be sorted according to the given sort expressions. That sorting does not add
 computational complexity.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>SortExprs</code> - (undocumented)</dd>
<dd><code>f</code> - (undocumented)</dd>
<dd><code>encoder</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>3.4.0</dd>
<dt>See Also:</dt>
<dd>
<ul class="see-list-long">
<li><a href="#flatMapGroups(scala.Function2,org.apache.spark.sql.Encoder)"><code>flatMapGroups(scala.Function2&lt;K, scala.collection.Iterator&lt;V&gt;, scala.collection.TraversableOnce&lt;U&gt;&gt;, org.apache.spark.sql.Encoder&lt;U&gt;)</code></a></li>
</ul>
</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="keyAs(org.apache.spark.sql.Encoder)">
<h3>keyAs</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;L&gt;</span>&nbsp;<span class="return-type"><a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql">KeyValueGroupedDataset</a>&lt;L,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;</span>&nbsp;<span class="element-name">keyAs</span><wbr><span class="parameters">(<a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;L&gt;&nbsp;evidence$1)</span></div>
<div class="block">Returns a new <a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql"><code>KeyValueGroupedDataset</code></a> where the type of the key has been mapped to the
 specified type. The mapping of key columns to the type follows the same rules as <code>as</code> on
 <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a>.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>evidence$1</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>1.6.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="keys()">
<h3>keys</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>&gt;</span>&nbsp;<span class="element-name">keys</span>()</div>
<div class="block">Returns a <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a> that contains each unique key. This is equivalent to doing mapping
 over the Dataset to extract the keys and then running a distinct operation on those.
 <p></div>
<dl class="notes">
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>1.6.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mapGroups(scala.Function2,org.apache.spark.sql.Encoder)">
<h3>mapGroups</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;U&gt;</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</span>&nbsp;<span class="element-name">mapGroups</span><wbr><span class="parameters">(scala.Function2&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>scala.collection.Iterator&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;,<wbr>U&gt;&nbsp;f,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;evidence$5)</span></div>
<div class="block">(Scala-specific)
 Applies the given function to each group of data.  For each unique group, the function will
 be passed the group key and an iterator that contains all of the elements in the group. The
 function can return an element of arbitrary type which will be returned as a new <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a>.
 <p>
 This function does not support partial aggregation, and as a result requires shuffling all
 the data in the <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a>. If an application intends to perform an aggregation over each
 key, it is best to use the reduce function or an
 <code>org.apache.spark.sql.expressions#Aggregator</code>.
 <p>
 Internally, the implementation will spill to disk if any given group is too large to fit into
 memory.  However, users must take care to avoid materializing the whole iterator for a group
 (for example, by calling <code>toList</code>) unless they are sure that this is possible given the memory
 constraints of their cluster.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>f</code> - (undocumented)</dd>
<dd><code>evidence$5</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>1.6.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mapGroups(org.apache.spark.api.java.function.MapGroupsFunction,org.apache.spark.sql.Encoder)">
<h3>mapGroups</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;U&gt;</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</span>&nbsp;<span class="element-name">mapGroups</span><wbr><span class="parameters">(<a href="../api/java/function/MapGroupsFunction.html" title="interface in org.apache.spark.api.java.function">MapGroupsFunction</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>U&gt;&nbsp;f,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;encoder)</span></div>
<div class="block">(Java-specific)
 Applies the given function to each group of data.  For each unique group, the function will
 be passed the group key and an iterator that contains all of the elements in the group. The
 function can return an element of arbitrary type which will be returned as a new <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a>.
 <p>
 This function does not support partial aggregation, and as a result requires shuffling all
 the data in the <a href="Dataset.html" title="class in org.apache.spark.sql"><code>Dataset</code></a>. If an application intends to perform an aggregation over each
 key, it is best to use the reduce function or an
 <code>org.apache.spark.sql.expressions#Aggregator</code>.
 <p>
 Internally, the implementation will spill to disk if any given group is too large to fit into
 memory.  However, users must take care to avoid materializing the whole iterator for a group
 (for example, by calling <code>toList</code>) unless they are sure that this is possible given the memory
 constraints of their cluster.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>f</code> - (undocumented)</dd>
<dd><code>encoder</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>1.6.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mapGroupsWithState(scala.Function3,org.apache.spark.sql.Encoder,org.apache.spark.sql.Encoder)">
<h3>mapGroupsWithState</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;S,<wbr>
U&gt;</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</span>&nbsp;<span class="element-name">mapGroupsWithState</span><wbr><span class="parameters">(scala.Function3&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>scala.collection.Iterator&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;,<wbr><a href="streaming/GroupState.html" title="interface in org.apache.spark.sql.streaming">GroupState</a>&lt;S&gt;,<wbr>U&gt;&nbsp;func,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;S&gt;&nbsp;evidence$6,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;evidence$7)</span></div>
<div class="block">(Scala-specific)
 Applies the given function to each group of data, while maintaining a user-defined per-group
 state. The result Dataset will represent the objects returned by the function.
 For a static batch Dataset, the function will be invoked once per group. For a streaming
 Dataset, the function will be invoked for each group repeatedly in every trigger, and
 updates to each group's state will be saved across invocations.
 See <a href="streaming/GroupState.html" title="interface in org.apache.spark.sql.streaming"><code>GroupState</code></a> for more details.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>func</code> - Function to be called on every group.
 <p>
 See <a href="Encoder.html" title="interface in org.apache.spark.sql"><code>Encoder</code></a> for more details on what types are encodable to Spark SQL.</dd>
<dd><code>evidence$6</code> - (undocumented)</dd>
<dd><code>evidence$7</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>2.2.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mapGroupsWithState(org.apache.spark.sql.streaming.GroupStateTimeout,scala.Function3,org.apache.spark.sql.Encoder,org.apache.spark.sql.Encoder)">
<h3>mapGroupsWithState</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;S,<wbr>
U&gt;</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</span>&nbsp;<span class="element-name">mapGroupsWithState</span><wbr><span class="parameters">(<a href="streaming/GroupStateTimeout.html" title="class in org.apache.spark.sql.streaming">GroupStateTimeout</a>&nbsp;timeoutConf,
 scala.Function3&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>scala.collection.Iterator&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;,<wbr><a href="streaming/GroupState.html" title="interface in org.apache.spark.sql.streaming">GroupState</a>&lt;S&gt;,<wbr>U&gt;&nbsp;func,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;S&gt;&nbsp;evidence$8,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;evidence$9)</span></div>
<div class="block">(Scala-specific)
 Applies the given function to each group of data, while maintaining a user-defined per-group
 state. The result Dataset will represent the objects returned by the function.
 For a static batch Dataset, the function will be invoked once per group. For a streaming
 Dataset, the function will be invoked for each group repeatedly in every trigger, and
 updates to each group's state will be saved across invocations.
 See <a href="streaming/GroupState.html" title="interface in org.apache.spark.sql.streaming"><code>GroupState</code></a> for more details.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>func</code> - Function to be called on every group.</dd>
<dd><code>timeoutConf</code> - Timeout configuration for groups that do not receive data for a while.
 <p>
 See <a href="Encoder.html" title="interface in org.apache.spark.sql"><code>Encoder</code></a> for more details on what types are encodable to Spark SQL.</dd>
<dd><code>evidence$8</code> - (undocumented)</dd>
<dd><code>evidence$9</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>2.2.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mapGroupsWithState(org.apache.spark.sql.streaming.GroupStateTimeout,org.apache.spark.sql.KeyValueGroupedDataset,scala.Function3,org.apache.spark.sql.Encoder,org.apache.spark.sql.Encoder)">
<h3>mapGroupsWithState</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;S,<wbr>
U&gt;</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</span>&nbsp;<span class="element-name">mapGroupsWithState</span><wbr><span class="parameters">(<a href="streaming/GroupStateTimeout.html" title="class in org.apache.spark.sql.streaming">GroupStateTimeout</a>&nbsp;timeoutConf,
 <a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql">KeyValueGroupedDataset</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>S&gt;&nbsp;initialState,
 scala.Function3&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>scala.collection.Iterator&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;,<wbr><a href="streaming/GroupState.html" title="interface in org.apache.spark.sql.streaming">GroupState</a>&lt;S&gt;,<wbr>U&gt;&nbsp;func,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;S&gt;&nbsp;evidence$10,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;evidence$11)</span></div>
<div class="block">(Scala-specific)
 Applies the given function to each group of data, while maintaining a user-defined per-group
 state. The result Dataset will represent the objects returned by the function.
 For a static batch Dataset, the function will be invoked once per group. For a streaming
 Dataset, the function will be invoked for each group repeatedly in every trigger, and
 updates to each group's state will be saved across invocations.
 See <a href="streaming/GroupState.html" title="interface in org.apache.spark.sql.streaming"><code>GroupState</code></a> for more details.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>func</code> - Function to be called on every group.</dd>
<dd><code>timeoutConf</code> - Timeout Conf, see GroupStateTimeout for more details</dd>
<dd><code>initialState</code> - The user provided state that will be initialized when the first batch
                     of data is processed in the streaming query. The user defined function
                     will be called on the state data even if there are no other values in
                     the group. To convert a Dataset ds of type Dataset[(K, S)] to a
                     KeyValueGroupedDataset[K, S]
                     do <pre><code> ds.groupByKey(x =&gt; x._1).mapValues(_._2) </code></pre>

 See {&#64;link Encoder} for more details on what types are encodable to Spark SQL.
 &#64;since 3.2.0</dd>
<dd><code>evidence$10</code> - (undocumented)</dd>
<dd><code>evidence$11</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mapGroupsWithState(org.apache.spark.api.java.function.MapGroupsWithStateFunction,org.apache.spark.sql.Encoder,org.apache.spark.sql.Encoder)">
<h3>mapGroupsWithState</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;S,<wbr>
U&gt;</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</span>&nbsp;<span class="element-name">mapGroupsWithState</span><wbr><span class="parameters">(<a href="../api/java/function/MapGroupsWithStateFunction.html" title="interface in org.apache.spark.api.java.function">MapGroupsWithStateFunction</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>S,<wbr>U&gt;&nbsp;func,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;S&gt;&nbsp;stateEncoder,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;outputEncoder)</span></div>
<div class="block">(Java-specific)
 Applies the given function to each group of data, while maintaining a user-defined per-group
 state. The result Dataset will represent the objects returned by the function.
 For a static batch Dataset, the function will be invoked once per group. For a streaming
 Dataset, the function will be invoked for each group repeatedly in every trigger, and
 updates to each group's state will be saved across invocations.
 See <code>GroupState</code> for more details.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>func</code> - Function to be called on every group.</dd>
<dd><code>stateEncoder</code> - Encoder for the state type.</dd>
<dd><code>outputEncoder</code> - Encoder for the output type.
 <p>
 See <a href="Encoder.html" title="interface in org.apache.spark.sql"><code>Encoder</code></a> for more details on what types are encodable to Spark SQL.</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>2.2.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mapGroupsWithState(org.apache.spark.api.java.function.MapGroupsWithStateFunction,org.apache.spark.sql.Encoder,org.apache.spark.sql.Encoder,org.apache.spark.sql.streaming.GroupStateTimeout)">
<h3>mapGroupsWithState</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;S,<wbr>
U&gt;</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</span>&nbsp;<span class="element-name">mapGroupsWithState</span><wbr><span class="parameters">(<a href="../api/java/function/MapGroupsWithStateFunction.html" title="interface in org.apache.spark.api.java.function">MapGroupsWithStateFunction</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>S,<wbr>U&gt;&nbsp;func,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;S&gt;&nbsp;stateEncoder,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;outputEncoder,
 <a href="streaming/GroupStateTimeout.html" title="class in org.apache.spark.sql.streaming">GroupStateTimeout</a>&nbsp;timeoutConf)</span></div>
<div class="block">(Java-specific)
 Applies the given function to each group of data, while maintaining a user-defined per-group
 state. The result Dataset will represent the objects returned by the function.
 For a static batch Dataset, the function will be invoked once per group. For a streaming
 Dataset, the function will be invoked for each group repeatedly in every trigger, and
 updates to each group's state will be saved across invocations.
 See <code>GroupState</code> for more details.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>func</code> - Function to be called on every group.</dd>
<dd><code>stateEncoder</code> - Encoder for the state type.</dd>
<dd><code>outputEncoder</code> - Encoder for the output type.</dd>
<dd><code>timeoutConf</code> - Timeout configuration for groups that do not receive data for a while.
 <p>
 See <a href="Encoder.html" title="interface in org.apache.spark.sql"><code>Encoder</code></a> for more details on what types are encodable to Spark SQL.</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>2.2.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mapGroupsWithState(org.apache.spark.api.java.function.MapGroupsWithStateFunction,org.apache.spark.sql.Encoder,org.apache.spark.sql.Encoder,org.apache.spark.sql.streaming.GroupStateTimeout,org.apache.spark.sql.KeyValueGroupedDataset)">
<h3>mapGroupsWithState</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;S,<wbr>
U&gt;</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;U&gt;</span>&nbsp;<span class="element-name">mapGroupsWithState</span><wbr><span class="parameters">(<a href="../api/java/function/MapGroupsWithStateFunction.html" title="interface in org.apache.spark.api.java.function">MapGroupsWithStateFunction</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>S,<wbr>U&gt;&nbsp;func,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;S&gt;&nbsp;stateEncoder,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;U&gt;&nbsp;outputEncoder,
 <a href="streaming/GroupStateTimeout.html" title="class in org.apache.spark.sql.streaming">GroupStateTimeout</a>&nbsp;timeoutConf,
 <a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql">KeyValueGroupedDataset</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>S&gt;&nbsp;initialState)</span></div>
<div class="block">(Java-specific)
 Applies the given function to each group of data, while maintaining a user-defined per-group
 state. The result Dataset will represent the objects returned by the function.
 For a static batch Dataset, the function will be invoked once per group. For a streaming
 Dataset, the function will be invoked for each group repeatedly in every trigger, and
 updates to each group's state will be saved across invocations.
 See <code>GroupState</code> for more details.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>func</code> - Function to be called on every group.</dd>
<dd><code>stateEncoder</code> - Encoder for the state type.</dd>
<dd><code>outputEncoder</code> - Encoder for the output type.</dd>
<dd><code>timeoutConf</code> - Timeout configuration for groups that do not receive data for a while.</dd>
<dd><code>initialState</code> - The user provided state that will be initialized when the first batch
                     of data is processed in the streaming query. The user defined function
                     will be called on the state data even if there are no other values in
                     the group.
 <p>
 See <a href="Encoder.html" title="interface in org.apache.spark.sql"><code>Encoder</code></a> for more details on what types are encodable to Spark SQL.</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>3.2.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mapValues(scala.Function1,org.apache.spark.sql.Encoder)">
<h3>mapValues</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;W&gt;</span>&nbsp;<span class="return-type"><a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql">KeyValueGroupedDataset</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>W&gt;</span>&nbsp;<span class="element-name">mapValues</span><wbr><span class="parameters">(scala.Function1&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>W&gt;&nbsp;func,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;W&gt;&nbsp;evidence$2)</span></div>
<div class="block">Returns a new <a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql"><code>KeyValueGroupedDataset</code></a> where the given function <code>func</code> has been applied
 to the data. The grouping key is unchanged by this.
 <p>
 <pre><code>
   // Create values grouped by key from a Dataset[(K, V)]
   ds.groupByKey(_._1).mapValues(_._2) // Scala
 </code></pre>
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>func</code> - (undocumented)</dd>
<dd><code>evidence$2</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>2.1.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mapValues(org.apache.spark.api.java.function.MapFunction,org.apache.spark.sql.Encoder)">
<h3>mapValues</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="type-parameters">&lt;W&gt;</span>&nbsp;<span class="return-type"><a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql">KeyValueGroupedDataset</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr>W&gt;</span>&nbsp;<span class="element-name">mapValues</span><wbr><span class="parameters">(<a href="../api/java/function/MapFunction.html" title="interface in org.apache.spark.api.java.function">MapFunction</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr>W&gt;&nbsp;func,
 <a href="Encoder.html" title="interface in org.apache.spark.sql">Encoder</a>&lt;W&gt;&nbsp;encoder)</span></div>
<div class="block">Returns a new <a href="KeyValueGroupedDataset.html" title="class in org.apache.spark.sql"><code>KeyValueGroupedDataset</code></a> where the given function <code>func</code> has been applied
 to the data. The grouping key is unchanged by this.
 <p>
 <pre><code>
   // Create Integer values grouped by String key from a Dataset&lt;Tuple2&lt;String, Integer&gt;&gt;
   Dataset&lt;Tuple2&lt;String, Integer&gt;&gt; ds = ...;
   KeyValueGroupedDataset&lt;String, Integer&gt; grouped =
     ds.groupByKey(t -&gt; t._1, Encoders.STRING()).mapValues(t -&gt; t._2, Encoders.INT());
 </code></pre>
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>func</code> - (undocumented)</dd>
<dd><code>encoder</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>2.1.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="queryExecution()">
<h3>queryExecution</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type">org.apache.spark.sql.execution.QueryExecution</span>&nbsp;<span class="element-name">queryExecution</span>()</div>
</section>
</li>
<li>
<section class="detail" id="reduceGroups(scala.Function2)">
<h3>reduceGroups</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;scala.Tuple2&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;&gt;</span>&nbsp;<span class="element-name">reduceGroups</span><wbr><span class="parameters">(scala.Function2&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;&nbsp;f)</span></div>
<div class="block">(Scala-specific)
 Reduces the elements of each group of data using the specified binary function.
 The given function must be commutative and associative or the result may be non-deterministic.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>f</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>1.6.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="reduceGroups(org.apache.spark.api.java.function.ReduceFunction)">
<h3>reduceGroups</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type"><a href="Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;scala.Tuple2&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">K</a>,<wbr><a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;&gt;</span>&nbsp;<span class="element-name">reduceGroups</span><wbr><span class="parameters">(<a href="../api/java/function/ReduceFunction.html" title="interface in org.apache.spark.api.java.function">ReduceFunction</a>&lt;<a href="KeyValueGroupedDataset.html" title="type parameter in KeyValueGroupedDataset">V</a>&gt;&nbsp;f)</span></div>
<div class="block">(Java-specific)
 Reduces the elements of each group of data using the specified binary function.
 The given function must be commutative and associative or the result may be non-deterministic.
 <p></div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>f</code> - (undocumented)</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
<dt>Since:</dt>
<dd>1.6.0</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toString()">
<h3>toString</h3>
<div class="member-signature"><span class="modifiers">public</span>&nbsp;<span class="return-type"><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a></span>&nbsp;<span class="element-name">toString</span>()</div>
<dl class="notes">
<dt>Overrides:</dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html#toString()" title="class or interface in java.lang" class="external-link">toString</a></code>&nbsp;in class&nbsp;<code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a></code></dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</div>
</div>
<script defer="defer" type="text/javascript" src="../../../../lib/jquery.js"></script><script defer="defer" type="text/javascript" src="../../../../lib/api-javadocs.js"></script></body>
</html>
