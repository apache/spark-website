<!DOCTYPE HTML>
<html lang="ko">
<head>
<!-- Generated by javadoc (17) on Sat Feb 24 16:16:59 KST 2024 -->
<title>CachedBatchSerializer (Spark 3.5.1 JavaDoc)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2024-02-24">
<meta name="description" content="declaration: package: org.apache.spark.sql.columnar, interface: CachedBatchSerializer">
<meta name="generator" content="javadoc/ClassWriterImpl">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var evenRowColor = "even-row-color";
var oddRowColor = "odd-row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top">
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html#class">Help</a></li>
</ul>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search-input">SEARCH:</label>
<input type="text" id="search-input" value="search" disabled="disabled">
<input type="reset" id="reset-button" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">org.apache.spark.sql.columnar</a></div>
<h1 title="Interface CachedBatchSerializer" class="title">Interface CachedBatchSerializer</h1>
</div>
<section class="class-description" id="class-description">
<dl class="notes">
<dt>All Superinterfaces:</dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/io/Serializable.html" title="class or interface in java.io" class="external-link">Serializable</a></code>, <code>scala.Serializable</code></dd>
</dl>
<dl class="notes">
<dt>All Known Implementing Classes:</dt>
<dd><code><a href="SimpleMetricsCachedBatchSerializer.html" title="class in org.apache.spark.sql.columnar">SimpleMetricsCachedBatchSerializer</a></code></dd>
</dl>
<hr>
<div class="type-signature"><span class="modifiers">public interface </span><span class="element-name type-name-label">CachedBatchSerializer</span><span class="extends-implements">
extends scala.Serializable</span></div>
<div class="block">Provides APIs that handle transformations of SQL data associated with the cache/persist APIs.</div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab2" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab2', 3)" class="table-tab">Instance Methods</button><button id="method-summary-table-tab3" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab3', 3)" class="table-tab">Abstract Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>scala.Function2&lt;<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a>,<wbr>scala.collection.Iterator&lt;<a href="CachedBatch.html" title="interface in org.apache.spark.sql.columnar">CachedBatch</a>&gt;,<wbr>scala.collection.Iterator&lt;<a href="CachedBatch.html" title="interface in org.apache.spark.sql.columnar">CachedBatch</a>&gt;&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#buildFilter(scala.collection.Seq,scala.collection.Seq)" class="member-name-link">buildFilter</a><wbr>(scala.collection.Seq&lt;org.apache.spark.sql.catalyst.expressions.Expression&gt;&nbsp;predicates,
 scala.collection.Seq&lt;org.apache.spark.sql.catalyst.expressions.Attribute&gt;&nbsp;cachedAttributes)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Builds a function that can be used to filter batches prior to being decompressed.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="../../rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</a>&lt;<a href="../vectorized/ColumnarBatch.html" title="class in org.apache.spark.sql.vectorized">ColumnarBatch</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#convertCachedBatchToColumnarBatch(org.apache.spark.rdd.RDD,scala.collection.Seq,scala.collection.Seq,org.apache.spark.sql.internal.SQLConf)" class="member-name-link">convertCachedBatchToColumnarBatch</a><wbr>(<a href="../../rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</a>&lt;<a href="CachedBatch.html" title="interface in org.apache.spark.sql.columnar">CachedBatch</a>&gt;&nbsp;input,
 scala.collection.Seq&lt;org.apache.spark.sql.catalyst.expressions.Attribute&gt;&nbsp;cacheAttributes,
 scala.collection.Seq&lt;org.apache.spark.sql.catalyst.expressions.Attribute&gt;&nbsp;selectedAttributes,
 org.apache.spark.sql.internal.SQLConf&nbsp;conf)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Convert the cached data into a ColumnarBatch.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="../../rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</a>&lt;org.apache.spark.sql.catalyst.InternalRow&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#convertCachedBatchToInternalRow(org.apache.spark.rdd.RDD,scala.collection.Seq,scala.collection.Seq,org.apache.spark.sql.internal.SQLConf)" class="member-name-link">convertCachedBatchToInternalRow</a><wbr>(<a href="../../rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</a>&lt;<a href="CachedBatch.html" title="interface in org.apache.spark.sql.columnar">CachedBatch</a>&gt;&nbsp;input,
 scala.collection.Seq&lt;org.apache.spark.sql.catalyst.expressions.Attribute&gt;&nbsp;cacheAttributes,
 scala.collection.Seq&lt;org.apache.spark.sql.catalyst.expressions.Attribute&gt;&nbsp;selectedAttributes,
 org.apache.spark.sql.internal.SQLConf&nbsp;conf)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Convert the cached batch into <code>InternalRow</code>s.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="../../rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</a>&lt;<a href="CachedBatch.html" title="interface in org.apache.spark.sql.columnar">CachedBatch</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#convertColumnarBatchToCachedBatch(org.apache.spark.rdd.RDD,scala.collection.Seq,org.apache.spark.storage.StorageLevel,org.apache.spark.sql.internal.SQLConf)" class="member-name-link">convertColumnarBatchToCachedBatch</a><wbr>(<a href="../../rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</a>&lt;<a href="../vectorized/ColumnarBatch.html" title="class in org.apache.spark.sql.vectorized">ColumnarBatch</a>&gt;&nbsp;input,
 scala.collection.Seq&lt;org.apache.spark.sql.catalyst.expressions.Attribute&gt;&nbsp;schema,
 <a href="../../storage/StorageLevel.html" title="class in org.apache.spark.storage">StorageLevel</a>&nbsp;storageLevel,
 org.apache.spark.sql.internal.SQLConf&nbsp;conf)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Convert an <code>RDD[ColumnarBatch]</code> into an <code>RDD[CachedBatch]</code> in preparation for caching the data.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="../../rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</a>&lt;<a href="CachedBatch.html" title="interface in org.apache.spark.sql.columnar">CachedBatch</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#convertInternalRowToCachedBatch(org.apache.spark.rdd.RDD,scala.collection.Seq,org.apache.spark.storage.StorageLevel,org.apache.spark.sql.internal.SQLConf)" class="member-name-link">convertInternalRowToCachedBatch</a><wbr>(<a href="../../rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</a>&lt;org.apache.spark.sql.catalyst.InternalRow&gt;&nbsp;input,
 scala.collection.Seq&lt;org.apache.spark.sql.catalyst.expressions.Attribute&gt;&nbsp;schema,
 <a href="../../storage/StorageLevel.html" title="class in org.apache.spark.storage">StorageLevel</a>&nbsp;storageLevel,
 org.apache.spark.sql.internal.SQLConf&nbsp;conf)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Convert an <code>RDD[InternalRow]</code> into an <code>RDD[CachedBatch]</code> in preparation for caching the data.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#supportsColumnarInput(scala.collection.Seq)" class="member-name-link">supportsColumnarInput</a><wbr>(scala.collection.Seq&lt;org.apache.spark.sql.catalyst.expressions.Attribute&gt;&nbsp;schema)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Can <code>convertColumnarBatchToCachedBatch()</code> be called instead of
 <code>convertInternalRowToCachedBatch()</code> for this given schema?</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#supportsColumnarOutput(org.apache.spark.sql.types.StructType)" class="member-name-link">supportsColumnarOutput</a><wbr>(<a href="../types/StructType.html" title="class in org.apache.spark.sql.types">StructType</a>&nbsp;schema)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Can <code>convertCachedBatchToColumnarBatch()</code> be called instead of
 <code>convertCachedBatchToInternalRow()</code> for this given schema?</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>scala.Option&lt;scala.collection.Seq&lt;<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&gt;&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#vectorTypes(scala.collection.Seq,org.apache.spark.sql.internal.SQLConf)" class="member-name-link">vectorTypes</a><wbr>(scala.collection.Seq&lt;org.apache.spark.sql.catalyst.expressions.Attribute&gt;&nbsp;attributes,
 org.apache.spark.sql.internal.SQLConf&nbsp;conf)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">The exact java types of the columns that are output in columnar processing mode.</div>
</div>
</div>
</div>
</div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="buildFilter(scala.collection.Seq,scala.collection.Seq)">
<h3>buildFilter</h3>
<div class="member-signature"><span class="return-type">scala.Function2&lt;<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Object.html" title="class or interface in java.lang" class="external-link">Object</a>,<wbr>scala.collection.Iterator&lt;<a href="CachedBatch.html" title="interface in org.apache.spark.sql.columnar">CachedBatch</a>&gt;,<wbr>scala.collection.Iterator&lt;<a href="CachedBatch.html" title="interface in org.apache.spark.sql.columnar">CachedBatch</a>&gt;&gt;</span>&nbsp;<span class="element-name">buildFilter</span><wbr><span class="parameters">(scala.collection.Seq&lt;org.apache.spark.sql.catalyst.expressions.Expression&gt;&nbsp;predicates,
 scala.collection.Seq&lt;org.apache.spark.sql.catalyst.expressions.Attribute&gt;&nbsp;cachedAttributes)</span></div>
<div class="block">Builds a function that can be used to filter batches prior to being decompressed.
 In most cases extending <a href="SimpleMetricsCachedBatchSerializer.html" title="class in org.apache.spark.sql.columnar"><code>SimpleMetricsCachedBatchSerializer</code></a> will provide the filter logic
 necessary. You will need to provide metrics for this to work. <a href="SimpleMetricsCachedBatch.html" title="interface in org.apache.spark.sql.columnar"><code>SimpleMetricsCachedBatch</code></a>
 provides the APIs to hold those metrics and explains the metrics used, really just min and max.
 Note that this is intended to skip batches that are not needed, and the actual filtering of
 individual rows is handled later.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>predicates</code> - the set of expressions to use for filtering.</dd>
<dd><code>cachedAttributes</code> - the schema/attributes of the data that is cached. This can be helpful
                         if you don't store it with the data.</dd>
<dt>Returns:</dt>
<dd>a function that takes the partition id and the iterator of batches in the partition.
         It returns an iterator of batches that should be decompressed.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="convertCachedBatchToColumnarBatch(org.apache.spark.rdd.RDD,scala.collection.Seq,scala.collection.Seq,org.apache.spark.sql.internal.SQLConf)">
<h3>convertCachedBatchToColumnarBatch</h3>
<div class="member-signature"><span class="return-type"><a href="../../rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</a>&lt;<a href="../vectorized/ColumnarBatch.html" title="class in org.apache.spark.sql.vectorized">ColumnarBatch</a>&gt;</span>&nbsp;<span class="element-name">convertCachedBatchToColumnarBatch</span><wbr><span class="parameters">(<a href="../../rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</a>&lt;<a href="CachedBatch.html" title="interface in org.apache.spark.sql.columnar">CachedBatch</a>&gt;&nbsp;input,
 scala.collection.Seq&lt;org.apache.spark.sql.catalyst.expressions.Attribute&gt;&nbsp;cacheAttributes,
 scala.collection.Seq&lt;org.apache.spark.sql.catalyst.expressions.Attribute&gt;&nbsp;selectedAttributes,
 org.apache.spark.sql.internal.SQLConf&nbsp;conf)</span></div>
<div class="block">Convert the cached data into a ColumnarBatch. This currently is only used if
 <code>supportsColumnarOutput()</code> returns true for the associated schema, but there are other checks
 that can force row based output. One of the main advantages of doing columnar output over row
 based output is that the code generation is more standard and can be combined with code
 generation for downstream operations.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>input</code> - the cached batches that should be converted.</dd>
<dd><code>cacheAttributes</code> - the attributes of the data in the batch.</dd>
<dd><code>selectedAttributes</code> - the fields that should be loaded from the data and the order they
                           should appear in the output batch.</dd>
<dd><code>conf</code> - the configuration for the job.</dd>
<dt>Returns:</dt>
<dd>an RDD of the input cached batches transformed into the ColumnarBatch format.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="convertCachedBatchToInternalRow(org.apache.spark.rdd.RDD,scala.collection.Seq,scala.collection.Seq,org.apache.spark.sql.internal.SQLConf)">
<h3>convertCachedBatchToInternalRow</h3>
<div class="member-signature"><span class="return-type"><a href="../../rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</a>&lt;org.apache.spark.sql.catalyst.InternalRow&gt;</span>&nbsp;<span class="element-name">convertCachedBatchToInternalRow</span><wbr><span class="parameters">(<a href="../../rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</a>&lt;<a href="CachedBatch.html" title="interface in org.apache.spark.sql.columnar">CachedBatch</a>&gt;&nbsp;input,
 scala.collection.Seq&lt;org.apache.spark.sql.catalyst.expressions.Attribute&gt;&nbsp;cacheAttributes,
 scala.collection.Seq&lt;org.apache.spark.sql.catalyst.expressions.Attribute&gt;&nbsp;selectedAttributes,
 org.apache.spark.sql.internal.SQLConf&nbsp;conf)</span></div>
<div class="block">Convert the cached batch into <code>InternalRow</code>s. If you want this to be performant, code
 generation is advised.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>input</code> - the cached batches that should be converted.</dd>
<dd><code>cacheAttributes</code> - the attributes of the data in the batch.</dd>
<dd><code>selectedAttributes</code> - the field that should be loaded from the data and the order they
                           should appear in the output rows.</dd>
<dd><code>conf</code> - the configuration for the job.</dd>
<dt>Returns:</dt>
<dd>RDD of the rows that were stored in the cached batches.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="convertColumnarBatchToCachedBatch(org.apache.spark.rdd.RDD,scala.collection.Seq,org.apache.spark.storage.StorageLevel,org.apache.spark.sql.internal.SQLConf)">
<h3>convertColumnarBatchToCachedBatch</h3>
<div class="member-signature"><span class="return-type"><a href="../../rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</a>&lt;<a href="CachedBatch.html" title="interface in org.apache.spark.sql.columnar">CachedBatch</a>&gt;</span>&nbsp;<span class="element-name">convertColumnarBatchToCachedBatch</span><wbr><span class="parameters">(<a href="../../rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</a>&lt;<a href="../vectorized/ColumnarBatch.html" title="class in org.apache.spark.sql.vectorized">ColumnarBatch</a>&gt;&nbsp;input,
 scala.collection.Seq&lt;org.apache.spark.sql.catalyst.expressions.Attribute&gt;&nbsp;schema,
 <a href="../../storage/StorageLevel.html" title="class in org.apache.spark.storage">StorageLevel</a>&nbsp;storageLevel,
 org.apache.spark.sql.internal.SQLConf&nbsp;conf)</span></div>
<div class="block">Convert an <code>RDD[ColumnarBatch]</code> into an <code>RDD[CachedBatch]</code> in preparation for caching the data.
 This will only be called if <code>supportsColumnarInput()</code> returned true for the given schema and
 the plan up to this point would could produce columnar output without modifying it.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>input</code> - the input <code>RDD</code> to be converted.</dd>
<dd><code>schema</code> - the schema of the data being stored.</dd>
<dd><code>storageLevel</code> - where the data will be stored.</dd>
<dd><code>conf</code> - the config for the query.</dd>
<dt>Returns:</dt>
<dd>The data converted into a format more suitable for caching.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="convertInternalRowToCachedBatch(org.apache.spark.rdd.RDD,scala.collection.Seq,org.apache.spark.storage.StorageLevel,org.apache.spark.sql.internal.SQLConf)">
<h3>convertInternalRowToCachedBatch</h3>
<div class="member-signature"><span class="return-type"><a href="../../rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</a>&lt;<a href="CachedBatch.html" title="interface in org.apache.spark.sql.columnar">CachedBatch</a>&gt;</span>&nbsp;<span class="element-name">convertInternalRowToCachedBatch</span><wbr><span class="parameters">(<a href="../../rdd/RDD.html" title="class in org.apache.spark.rdd">RDD</a>&lt;org.apache.spark.sql.catalyst.InternalRow&gt;&nbsp;input,
 scala.collection.Seq&lt;org.apache.spark.sql.catalyst.expressions.Attribute&gt;&nbsp;schema,
 <a href="../../storage/StorageLevel.html" title="class in org.apache.spark.storage">StorageLevel</a>&nbsp;storageLevel,
 org.apache.spark.sql.internal.SQLConf&nbsp;conf)</span></div>
<div class="block">Convert an <code>RDD[InternalRow]</code> into an <code>RDD[CachedBatch]</code> in preparation for caching the data.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>input</code> - the input <code>RDD</code> to be converted.</dd>
<dd><code>schema</code> - the schema of the data being stored.</dd>
<dd><code>storageLevel</code> - where the data will be stored.</dd>
<dd><code>conf</code> - the config for the query.</dd>
<dt>Returns:</dt>
<dd>The data converted into a format more suitable for caching.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="supportsColumnarInput(scala.collection.Seq)">
<h3>supportsColumnarInput</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">supportsColumnarInput</span><wbr><span class="parameters">(scala.collection.Seq&lt;org.apache.spark.sql.catalyst.expressions.Attribute&gt;&nbsp;schema)</span></div>
<div class="block">Can <code>convertColumnarBatchToCachedBatch()</code> be called instead of
 <code>convertInternalRowToCachedBatch()</code> for this given schema? True if it can and false if it
 cannot. Columnar input is only supported if the plan could produce columnar output. Currently
 this is mostly supported by input formats like parquet and orc, but more operations are likely
 to be supported soon.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>schema</code> - the schema of the data being stored.</dd>
<dt>Returns:</dt>
<dd>True if columnar input can be supported, else false.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="supportsColumnarOutput(org.apache.spark.sql.types.StructType)">
<h3>supportsColumnarOutput</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">supportsColumnarOutput</span><wbr><span class="parameters">(<a href="../types/StructType.html" title="class in org.apache.spark.sql.types">StructType</a>&nbsp;schema)</span></div>
<div class="block">Can <code>convertCachedBatchToColumnarBatch()</code> be called instead of
 <code>convertCachedBatchToInternalRow()</code> for this given schema? True if it can and false if it
 cannot. Columnar output is typically preferred because it is more efficient. Note that
 <code>convertCachedBatchToInternalRow()</code> must always be supported as there are other checks that
 can force row based output.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>schema</code> - the schema of the data being checked.</dd>
<dt>Returns:</dt>
<dd>true if columnar output should be used for this schema, else false.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="vectorTypes(scala.collection.Seq,org.apache.spark.sql.internal.SQLConf)">
<h3>vectorTypes</h3>
<div class="member-signature"><span class="return-type">scala.Option&lt;scala.collection.Seq&lt;<a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html" title="class or interface in java.lang" class="external-link">String</a>&gt;&gt;</span>&nbsp;<span class="element-name">vectorTypes</span><wbr><span class="parameters">(scala.collection.Seq&lt;org.apache.spark.sql.catalyst.expressions.Attribute&gt;&nbsp;attributes,
 org.apache.spark.sql.internal.SQLConf&nbsp;conf)</span></div>
<div class="block">The exact java types of the columns that are output in columnar processing mode. This
 is a performance optimization for code generation and is optional.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>attributes</code> - the attributes to be output.</dd>
<dd><code>conf</code> - the config for the query that will read the data.</dd>
<dt>Returns:</dt>
<dd>(undocumented)</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
</div>
</div>
<script defer="defer" type="text/javascript" src="../../../../../lib/jquery.js"></script><script defer="defer" type="text/javascript" src="../../../../../lib/api-javadocs.js"></script></body>
</html>
