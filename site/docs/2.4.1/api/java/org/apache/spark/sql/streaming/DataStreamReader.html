<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_191) on Wed Mar 27 05:00:37 UTC 2019 -->
<title>DataStreamReader (Spark 2.4.1 JavaDoc)</title>
<meta name="date" content="2019-03-27">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="DataStreamReader (Spark 2.4.1 JavaDoc)";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":10,"i13":10,"i14":10,"i15":10,"i16":10};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../../../../org/apache/spark/sql/streaming/DataStreamWriter.html" title="class in org.apache.spark.sql.streaming"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?org/apache/spark/sql/streaming/DataStreamReader.html" target="_top">Frames</a></li>
<li><a href="DataStreamReader.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.apache.spark.sql.streaming</div>
<h2 title="Class DataStreamReader" class="title">Class DataStreamReader</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>Object</li>
<li>
<ul class="inheritance">
<li>org.apache.spark.sql.streaming.DataStreamReader</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><a href="../../../../../org/apache/spark/internal/Logging.html" title="interface in org.apache.spark.internal">Logging</a></dd>
</dl>
<hr>
<br>
<pre>public final class <span class="typeNameLabel">DataStreamReader</span>
extends Object
implements <a href="../../../../../org/apache/spark/internal/Logging.html" title="interface in org.apache.spark.internal">Logging</a></pre>
<div class="block">Interface used to load a streaming <code>Dataset</code> from external storage systems (e.g. file systems,
 key-value stores, etc). Use <code>SparkSession.readStream</code> to access this.
 <p></div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2.0.0</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html#csv-java.lang.String-">csv</a></span>(String&nbsp;path)</code>
<div class="block">Loads a CSV file stream and returns the result as a <code>DataFrame</code>.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html" title="class in org.apache.spark.sql.streaming">DataStreamReader</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html#format-java.lang.String-">format</a></span>(String&nbsp;source)</code>
<div class="block">Specifies the input data source format.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html#json-java.lang.String-">json</a></span>(String&nbsp;path)</code>
<div class="block">Loads a JSON file stream and returns the results as a <code>DataFrame</code>.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html#load--">load</a></span>()</code>
<div class="block">Loads input data stream in as a <code>DataFrame</code>, for data streams that don't require a path
 (e.g.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html#load-java.lang.String-">load</a></span>(String&nbsp;path)</code>
<div class="block">Loads input in as a <code>DataFrame</code>, for data streams that read from some path.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html" title="class in org.apache.spark.sql.streaming">DataStreamReader</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html#option-java.lang.String-boolean-">option</a></span>(String&nbsp;key,
      boolean&nbsp;value)</code>
<div class="block">Adds an input option for the underlying data source.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html" title="class in org.apache.spark.sql.streaming">DataStreamReader</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html#option-java.lang.String-double-">option</a></span>(String&nbsp;key,
      double&nbsp;value)</code>
<div class="block">Adds an input option for the underlying data source.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html" title="class in org.apache.spark.sql.streaming">DataStreamReader</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html#option-java.lang.String-long-">option</a></span>(String&nbsp;key,
      long&nbsp;value)</code>
<div class="block">Adds an input option for the underlying data source.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html" title="class in org.apache.spark.sql.streaming">DataStreamReader</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html#option-java.lang.String-java.lang.String-">option</a></span>(String&nbsp;key,
      String&nbsp;value)</code>
<div class="block">Adds an input option for the underlying data source.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html" title="class in org.apache.spark.sql.streaming">DataStreamReader</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html#options-scala.collection.Map-">options</a></span>(scala.collection.Map&lt;String,String&gt;&nbsp;options)</code>
<div class="block">(Scala-specific) Adds input options for the underlying data source.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html" title="class in org.apache.spark.sql.streaming">DataStreamReader</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html#options-java.util.Map-">options</a></span>(java.util.Map&lt;String,String&gt;&nbsp;options)</code>
<div class="block">(Java-specific) Adds input options for the underlying data source.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html#orc-java.lang.String-">orc</a></span>(String&nbsp;path)</code>
<div class="block">Loads a ORC file stream, returning the result as a <code>DataFrame</code>.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html#parquet-java.lang.String-">parquet</a></span>(String&nbsp;path)</code>
<div class="block">Loads a Parquet file stream, returning the result as a <code>DataFrame</code>.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html" title="class in org.apache.spark.sql.streaming">DataStreamReader</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html#schema-java.lang.String-">schema</a></span>(String&nbsp;schemaString)</code>
<div class="block">Specifies the schema by using the input DDL-formatted string.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html" title="class in org.apache.spark.sql.streaming">DataStreamReader</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html#schema-org.apache.spark.sql.types.StructType-">schema</a></span>(<a href="../../../../../org/apache/spark/sql/types/StructType.html" title="class in org.apache.spark.sql.types">StructType</a>&nbsp;schema)</code>
<div class="block">Specifies the input schema.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html#text-java.lang.String-">text</a></span>(String&nbsp;path)</code>
<div class="block">Loads text files and returns a <code>DataFrame</code> whose schema starts with a string column named
 "value", and followed by partitioned columns if there are any.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;String&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html#textFile-java.lang.String-">textFile</a></span>(String&nbsp;path)</code>
<div class="block">Loads text file(s) and returns a <code>Dataset</code> of String.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.org.apache.spark.internal.Logging">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;org.apache.spark.internal.<a href="../../../../../org/apache/spark/internal/Logging.html" title="interface in org.apache.spark.internal">Logging</a></h3>
<code><a href="../../../../../org/apache/spark/internal/Logging.html#initializeLogging-boolean-boolean-">initializeLogging</a>, <a href="../../../../../org/apache/spark/internal/Logging.html#initializeLogIfNecessary-boolean-">initializeLogIfNecessary</a>, <a href="../../../../../org/apache/spark/internal/Logging.html#initializeLogIfNecessary-boolean-boolean-">initializeLogIfNecessary</a>, <a href="../../../../../org/apache/spark/internal/Logging.html#isTraceEnabled--">isTraceEnabled</a>, <a href="../../../../../org/apache/spark/internal/Logging.html#log_--">log_</a>, <a href="../../../../../org/apache/spark/internal/Logging.html#log--">log</a>, <a href="../../../../../org/apache/spark/internal/Logging.html#logDebug-scala.Function0-">logDebug</a>, <a href="../../../../../org/apache/spark/internal/Logging.html#logDebug-scala.Function0-java.lang.Throwable-">logDebug</a>, <a href="../../../../../org/apache/spark/internal/Logging.html#logError-scala.Function0-">logError</a>, <a href="../../../../../org/apache/spark/internal/Logging.html#logError-scala.Function0-java.lang.Throwable-">logError</a>, <a href="../../../../../org/apache/spark/internal/Logging.html#logInfo-scala.Function0-">logInfo</a>, <a href="../../../../../org/apache/spark/internal/Logging.html#logInfo-scala.Function0-java.lang.Throwable-">logInfo</a>, <a href="../../../../../org/apache/spark/internal/Logging.html#logName--">logName</a>, <a href="../../../../../org/apache/spark/internal/Logging.html#logTrace-scala.Function0-">logTrace</a>, <a href="../../../../../org/apache/spark/internal/Logging.html#logTrace-scala.Function0-java.lang.Throwable-">logTrace</a>, <a href="../../../../../org/apache/spark/internal/Logging.html#logWarning-scala.Function0-">logWarning</a>, <a href="../../../../../org/apache/spark/internal/Logging.html#logWarning-scala.Function0-java.lang.Throwable-">logWarning</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="csv-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>csv</h4>
<pre>public&nbsp;<a href="../../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;csv(String&nbsp;path)</pre>
<div class="block">Loads a CSV file stream and returns the result as a <code>DataFrame</code>.
 <p>
 This function will go through the input once to determine the input schema if <code>inferSchema</code>
 is enabled. To avoid going through the entire data once, disable <code>inferSchema</code> option or
 specify the schema explicitly using <code>schema</code>.
 <p>
 You can set the following CSV-specific options to deal with CSV files:
 <ul>
 <li><code>maxFilesPerTrigger</code> (default: no max limit): sets the maximum number of new files to be
 considered in every trigger.</li>
 <li><code>sep</code> (default <code>,</code>): sets a single character as a separator for each
 field and value.</li>
 <li><code>encoding</code> (default <code>UTF-8</code>): decodes the CSV files by the given encoding
 type.</li>
 <li><code>quote</code> (default <code>"</code>): sets a single character used for escaping quoted values where
 the separator can be part of the value. If you would like to turn off quotations, you need to
 set not <code>null</code> but an empty string. This behaviour is different form
 <code>com.databricks.spark.csv</code>.</li>
 <li><code>escape</code> (default <code>\</code>): sets a single character used for escaping quotes inside
 an already quoted value.</li>
 <li><code>charToEscapeQuoteEscaping</code> (default <code>escape</code> or <code>\0</code>): sets a single character used for
 escaping the escape for the quote character. The default value is escape character when escape
 and quote characters are different, <code>\0</code> otherwise.</li>
 <li><code>comment</code> (default empty string): sets a single character used for skipping lines
 beginning with this character. By default, it is disabled.</li>
 <li><code>header</code> (default <code>false</code>): uses the first line as names of columns.</li>
 <li><code>inferSchema</code> (default <code>false</code>): infers the input schema automatically from data. It
 requires one extra pass over the data.</li>
 <li><code>ignoreLeadingWhiteSpace</code> (default <code>false</code>): a flag indicating whether or not leading
 whitespaces from values being read should be skipped.</li>
 <li><code>ignoreTrailingWhiteSpace</code> (default <code>false</code>): a flag indicating whether or not trailing
 whitespaces from values being read should be skipped.</li>
 <li><code>nullValue</code> (default empty string): sets the string representation of a null value. Since
 2.0.1, this applies to all supported types including the string type.</li>
 <li><code>emptyValue</code> (default empty string): sets the string representation of an empty value.</li>
 <li><code>nanValue</code> (default <code>NaN</code>): sets the string representation of a non-number" value.</li>
 <li><code>positiveInf</code> (default <code>Inf</code>): sets the string representation of a positive infinity
 value.</li>
 <li><code>negativeInf</code> (default <code>-Inf</code>): sets the string representation of a negative infinity
 value.</li>
 <li><code>dateFormat</code> (default <code>yyyy-MM-dd</code>): sets the string that indicates a date format.
 Custom date formats follow the formats at <code>java.text.SimpleDateFormat</code>. This applies to
 date type.</li>
 <li><code>timestampFormat</code> (default <code>yyyy-MM-dd'T'HH:mm:ss.SSSXXX</code>): sets the string that
 indicates a timestamp format. Custom date formats follow the formats at
 <code>java.text.SimpleDateFormat</code>. This applies to timestamp type.</li>
 <li><code>maxColumns</code> (default <code>20480</code>): defines a hard limit of how many columns
 a record can have.</li>
 <li><code>maxCharsPerColumn</code> (default <code>-1</code>): defines the maximum number of characters allowed
 for any given value being read. By default, it is -1 meaning unlimited length</li>
 <li><code>mode</code> (default <code>PERMISSIVE</code>): allows a mode for dealing with corrupt records
    during parsing. It supports the following case-insensitive modes.
   <ul>
     <li><code>PERMISSIVE</code> : when it meets a corrupted record, puts the malformed string into a
     field configured by <code>columnNameOfCorruptRecord</code>, and sets other fields to <code>null</code>. To keep
     corrupt records, an user can set a string type field named <code>columnNameOfCorruptRecord</code>
     in an user-defined schema. If a schema does not have the field, it drops corrupt records
     during parsing. A record with less/more tokens than schema is not a corrupted record to
     CSV. When it meets a record having fewer tokens than the length of the schema, sets
     <code>null</code> to extra fields. When the record has more tokens than the length of the schema,
     it drops extra tokens.</li>
     <li><code>DROPMALFORMED</code> : ignores the whole corrupted records.</li>
     <li><code>FAILFAST</code> : throws an exception when it meets corrupted records.</li>
   </ul>
 </li>
 <li><code>columnNameOfCorruptRecord</code> (default is the value specified in
 <code>spark.sql.columnNameOfCorruptRecord</code>): allows renaming the new field having malformed string
 created by <code>PERMISSIVE</code> mode. This overrides <code>spark.sql.columnNameOfCorruptRecord</code>.</li>
 <li><code>multiLine</code> (default <code>false</code>): parse one record, which may span multiple lines.</li>
 </ul>
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>path</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2.0.0</dd>
</dl>
</li>
</ul>
<a name="format-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>format</h4>
<pre>public&nbsp;<a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html" title="class in org.apache.spark.sql.streaming">DataStreamReader</a>&nbsp;format(String&nbsp;source)</pre>
<div class="block">Specifies the input data source format.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>source</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2.0.0</dd>
</dl>
</li>
</ul>
<a name="json-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>json</h4>
<pre>public&nbsp;<a href="../../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;json(String&nbsp;path)</pre>
<div class="block">Loads a JSON file stream and returns the results as a <code>DataFrame</code>.
 <p>
 <a href="http://jsonlines.org/">JSON Lines</a> (newline-delimited JSON) is supported by
 default. For JSON (one record per file), set the <code>multiLine</code> option to true.
 <p>
 This function goes through the input once to determine the input schema. If you know the
 schema in advance, use the version that specifies the schema to avoid the extra scan.
 <p>
 You can set the following JSON-specific options to deal with non-standard JSON files:
 <ul>
 <li><code>maxFilesPerTrigger</code> (default: no max limit): sets the maximum number of new files to be
 considered in every trigger.</li>
 <li><code>primitivesAsString</code> (default <code>false</code>): infers all primitive values as a string type</li>
 <li><code>prefersDecimal</code> (default <code>false</code>): infers all floating-point values as a decimal
 type. If the values do not fit in decimal, then it infers them as doubles.</li>
 <li><code>allowComments</code> (default <code>false</code>): ignores Java/C++ style comment in JSON records</li>
 <li><code>allowUnquotedFieldNames</code> (default <code>false</code>): allows unquoted JSON field names</li>
 <li><code>allowSingleQuotes</code> (default <code>true</code>): allows single quotes in addition to double quotes
 </li>
 <li><code>allowNumericLeadingZeros</code> (default <code>false</code>): allows leading zeros in numbers
 (e.g. 00012)</li>
 <li><code>allowBackslashEscapingAnyCharacter</code> (default <code>false</code>): allows accepting quoting of all
 character using backslash quoting mechanism</li>
 <li><code>allowUnquotedControlChars</code> (default <code>false</code>): allows JSON Strings to contain unquoted
 control characters (ASCII characters with value less than 32, including tab and line feed
 characters) or not.</li>
 <li><code>mode</code> (default <code>PERMISSIVE</code>): allows a mode for dealing with corrupt records
 during parsing.
   <ul>
     <li><code>PERMISSIVE</code> : when it meets a corrupted record, puts the malformed string into a
     field configured by <code>columnNameOfCorruptRecord</code>, and sets other fields to <code>null</code>. To
     keep corrupt records, an user can set a string type field named
     <code>columnNameOfCorruptRecord</code> in an user-defined schema. If a schema does not have the
     field, it drops corrupt records during parsing. When inferring a schema, it implicitly
     adds a <code>columnNameOfCorruptRecord</code> field in an output schema.</li>
     <li><code>DROPMALFORMED</code> : ignores the whole corrupted records.</li>
     <li><code>FAILFAST</code> : throws an exception when it meets corrupted records.</li>
   </ul>
 </li>
 <li><code>columnNameOfCorruptRecord</code> (default is the value specified in
 <code>spark.sql.columnNameOfCorruptRecord</code>): allows renaming the new field having malformed string
 created by <code>PERMISSIVE</code> mode. This overrides <code>spark.sql.columnNameOfCorruptRecord</code>.</li>
 <li><code>dateFormat</code> (default <code>yyyy-MM-dd</code>): sets the string that indicates a date format.
 Custom date formats follow the formats at <code>java.text.SimpleDateFormat</code>. This applies to
 date type.</li>
 <li><code>timestampFormat</code> (default <code>yyyy-MM-dd'T'HH:mm:ss.SSSXXX</code>): sets the string that
 indicates a timestamp format. Custom date formats follow the formats at
 <code>java.text.SimpleDateFormat</code>. This applies to timestamp type.</li>
 <li><code>multiLine</code> (default <code>false</code>): parse one record, which may span multiple lines,
 per file</li>
 <li><code>lineSep</code> (default covers all <code>\r</code>, <code>\r\n</code> and <code>\n</code>): defines the line separator
 that should be used for parsing.</li>
 <li><code>dropFieldIfAllNull</code> (default <code>false</code>): whether to ignore column of all null values or
 empty array/struct during schema inference.</li>
 </ul>
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>path</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2.0.0</dd>
</dl>
</li>
</ul>
<a name="load--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>load</h4>
<pre>public&nbsp;<a href="../../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;load()</pre>
<div class="block">Loads input data stream in as a <code>DataFrame</code>, for data streams that don't require a path
 (e.g. external key-value stores).
 <p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2.0.0</dd>
</dl>
</li>
</ul>
<a name="load-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>load</h4>
<pre>public&nbsp;<a href="../../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;load(String&nbsp;path)</pre>
<div class="block">Loads input in as a <code>DataFrame</code>, for data streams that read from some path.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>path</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2.0.0</dd>
</dl>
</li>
</ul>
<a name="option-java.lang.String-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>option</h4>
<pre>public&nbsp;<a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html" title="class in org.apache.spark.sql.streaming">DataStreamReader</a>&nbsp;option(String&nbsp;key,
                               String&nbsp;value)</pre>
<div class="block">Adds an input option for the underlying data source.
 <p>
 You can set the following option(s):
 <ul>
 <li><code>timeZone</code> (default session local timezone): sets the string that indicates a timezone
 to be used to parse timestamps in the JSON/CSV datasources or partition values.</li>
 </ul>
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>key</code> - (undocumented)</dd>
<dd><code>value</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2.0.0</dd>
</dl>
</li>
</ul>
<a name="option-java.lang.String-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>option</h4>
<pre>public&nbsp;<a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html" title="class in org.apache.spark.sql.streaming">DataStreamReader</a>&nbsp;option(String&nbsp;key,
                               boolean&nbsp;value)</pre>
<div class="block">Adds an input option for the underlying data source.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>key</code> - (undocumented)</dd>
<dd><code>value</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2.0.0</dd>
</dl>
</li>
</ul>
<a name="option-java.lang.String-long-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>option</h4>
<pre>public&nbsp;<a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html" title="class in org.apache.spark.sql.streaming">DataStreamReader</a>&nbsp;option(String&nbsp;key,
                               long&nbsp;value)</pre>
<div class="block">Adds an input option for the underlying data source.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>key</code> - (undocumented)</dd>
<dd><code>value</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2.0.0</dd>
</dl>
</li>
</ul>
<a name="option-java.lang.String-double-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>option</h4>
<pre>public&nbsp;<a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html" title="class in org.apache.spark.sql.streaming">DataStreamReader</a>&nbsp;option(String&nbsp;key,
                               double&nbsp;value)</pre>
<div class="block">Adds an input option for the underlying data source.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>key</code> - (undocumented)</dd>
<dd><code>value</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2.0.0</dd>
</dl>
</li>
</ul>
<a name="options-scala.collection.Map-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>options</h4>
<pre>public&nbsp;<a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html" title="class in org.apache.spark.sql.streaming">DataStreamReader</a>&nbsp;options(scala.collection.Map&lt;String,String&gt;&nbsp;options)</pre>
<div class="block">(Scala-specific) Adds input options for the underlying data source.
 <p>
 You can set the following option(s):
 <ul>
 <li><code>timeZone</code> (default session local timezone): sets the string that indicates a timezone
 to be used to parse timestamps in the JSON/CSV data sources or partition values.</li>
 </ul>
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>options</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2.0.0</dd>
</dl>
</li>
</ul>
<a name="options-java.util.Map-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>options</h4>
<pre>public&nbsp;<a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html" title="class in org.apache.spark.sql.streaming">DataStreamReader</a>&nbsp;options(java.util.Map&lt;String,String&gt;&nbsp;options)</pre>
<div class="block">(Java-specific) Adds input options for the underlying data source.
 <p>
 You can set the following option(s):
 <ul>
 <li><code>timeZone</code> (default session local timezone): sets the string that indicates a timezone
 to be used to parse timestamps in the JSON/CSV data sources or partition values.</li>
 </ul>
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>options</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2.0.0</dd>
</dl>
</li>
</ul>
<a name="orc-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>orc</h4>
<pre>public&nbsp;<a href="../../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;orc(String&nbsp;path)</pre>
<div class="block">Loads a ORC file stream, returning the result as a <code>DataFrame</code>.
 <p>
 You can set the following ORC-specific option(s) for reading ORC files:
 <ul>
 <li><code>maxFilesPerTrigger</code> (default: no max limit): sets the maximum number of new files to be
 considered in every trigger.</li>
 </ul>
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>path</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2.3.0</dd>
</dl>
</li>
</ul>
<a name="parquet-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parquet</h4>
<pre>public&nbsp;<a href="../../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;parquet(String&nbsp;path)</pre>
<div class="block">Loads a Parquet file stream, returning the result as a <code>DataFrame</code>.
 <p>
 You can set the following Parquet-specific option(s) for reading Parquet files:
 <ul>
 <li><code>maxFilesPerTrigger</code> (default: no max limit): sets the maximum number of new files to be
 considered in every trigger.</li>
 <li><code>mergeSchema</code> (default is the value specified in <code>spark.sql.parquet.mergeSchema</code>): sets
 whether we should merge schemas collected from all
 Parquet part-files. This will override
 <code>spark.sql.parquet.mergeSchema</code>.</li>
 </ul>
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>path</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2.0.0</dd>
</dl>
</li>
</ul>
<a name="schema-org.apache.spark.sql.types.StructType-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>schema</h4>
<pre>public&nbsp;<a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html" title="class in org.apache.spark.sql.streaming">DataStreamReader</a>&nbsp;schema(<a href="../../../../../org/apache/spark/sql/types/StructType.html" title="class in org.apache.spark.sql.types">StructType</a>&nbsp;schema)</pre>
<div class="block">Specifies the input schema. Some data sources (e.g. JSON) can infer the input schema
 automatically from data. By specifying the schema here, the underlying data source can
 skip the schema inference step, and thus speed up data loading.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>schema</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2.0.0</dd>
</dl>
</li>
</ul>
<a name="schema-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>schema</h4>
<pre>public&nbsp;<a href="../../../../../org/apache/spark/sql/streaming/DataStreamReader.html" title="class in org.apache.spark.sql.streaming">DataStreamReader</a>&nbsp;schema(String&nbsp;schemaString)</pre>
<div class="block">Specifies the schema by using the input DDL-formatted string. Some data sources (e.g. JSON) can
 infer the input schema automatically from data. By specifying the schema here, the underlying
 data source can skip the schema inference step, and thus speed up data loading.
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>schemaString</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2.3.0</dd>
</dl>
</li>
</ul>
<a name="text-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>text</h4>
<pre>public&nbsp;<a href="../../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;<a href="../../../../../org/apache/spark/sql/Row.html" title="interface in org.apache.spark.sql">Row</a>&gt;&nbsp;text(String&nbsp;path)</pre>
<div class="block">Loads text files and returns a <code>DataFrame</code> whose schema starts with a string column named
 "value", and followed by partitioned columns if there are any.
 <p>
 By default, each line in the text files is a new row in the resulting DataFrame. For example:
 <pre><code>
   // Scala:
   spark.readStream.text("/path/to/directory/")

   // Java:
   spark.readStream().text("/path/to/directory/")
 </code></pre>
 <p>
 You can set the following text-specific options to deal with text files:
 <ul>
 <li><code>maxFilesPerTrigger</code> (default: no max limit): sets the maximum number of new files to be
 considered in every trigger.</li>
 <li><code>wholetext</code> (default <code>false</code>): If true, read a file as a single row and not split by "\n".
 </li>
 <li><code>lineSep</code> (default covers all <code>\r</code>, <code>\r\n</code> and <code>\n</code>): defines the line separator
 that should be used for parsing.</li>
 </ul>
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>path</code> - (undocumented)</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2.0.0</dd>
</dl>
</li>
</ul>
<a name="textFile-java.lang.String-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>textFile</h4>
<pre>public&nbsp;<a href="../../../../../org/apache/spark/sql/Dataset.html" title="class in org.apache.spark.sql">Dataset</a>&lt;String&gt;&nbsp;textFile(String&nbsp;path)</pre>
<div class="block">Loads text file(s) and returns a <code>Dataset</code> of String. The underlying schema of the Dataset
 contains a single string column named "value".
 <p>
 If the directory structure of the text files contains partitioning information, those are
 ignored in the resulting Dataset. To include partitioning information as columns, use <code>text</code>.
 <p>
 By default, each line in the text file is a new element in the resulting Dataset. For example:
 <pre><code>
   // Scala:
   spark.readStream.textFile("/path/to/spark/README.md")

   // Java:
   spark.readStream().textFile("/path/to/spark/README.md")
 </code></pre>
 <p>
 You can set the following text-specific options to deal with text files:
 <ul>
 <li><code>maxFilesPerTrigger</code> (default: no max limit): sets the maximum number of new files to be
 considered in every trigger.</li>
 <li><code>wholetext</code> (default <code>false</code>): If true, read a file as a single row and not split by "\n".
 </li>
 <li><code>lineSep</code> (default covers all <code>\r</code>, <code>\r\n</code> and <code>\n</code>): defines the line separator
 that should be used for parsing.</li>
 </ul>
 <p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>path</code> - input path</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>(undocumented)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2.1.0</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../../../../org/apache/spark/sql/streaming/DataStreamWriter.html" title="class in org.apache.spark.sql.streaming"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?org/apache/spark/sql/streaming/DataStreamReader.html" target="_top">Frames</a></li>
<li><a href="DataStreamReader.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<script defer="defer" type="text/javascript" src="../../../../../lib/jquery.js"></script><script defer="defer" type="text/javascript" src="../../../../../lib/api-javadocs.js"></script></body>
</html>
