
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <title>pyspark.pandas.indexes.base &#8212; PySpark 3.2.2 documentation</title>
    
  <link rel="stylesheet" href="../../../../_static/css/index.73d71520a4ca3b99cfee5594769eaaae.css">

    
  <link rel="stylesheet"
    href="../../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../../../../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../../../../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../../../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/css/pyspark.css" />
    
  <link rel="preload" as="script" href="../../../../_static/js/index.3da636dd464baa7582d2.js">

    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <script src="../../../../_static/language_data.js"></script>
    <script src="../../../../_static/copybutton.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    <link rel="search" title="Search" href="../../../../search.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main">
<div class="container-xl">

    <a class="navbar-brand" href="../../../../index.html">
    
      <img src="../../../../_static/spark-logo-reverse.png" class="logo" alt="logo" />
    
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-menu" aria-controls="navbar-menu" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar-menu" class="col-lg-9 collapse navbar-collapse">
      <ul id="navbar-main-elements" class="navbar-nav mr-auto">
        
        
        <li class="nav-item ">
            <a class="nav-link" href="../../../../getting_started/index.html">Getting Started</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../../../user_guide/index.html">User Guide</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../../../reference/index.html">API Reference</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../../../development/index.html">Development</a>
        </li>
        
        <li class="nav-item ">
            <a class="nav-link" href="../../../../migration_guide/index.html">Migration Guide</a>
        </li>
        
        
      </ul>


      

      <ul class="navbar-nav">
        
        
      </ul>
    </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
          <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">

    <div class="bd-toc-item active">
    
  
    <ul class="nav bd-sidenav">
        
        
        
        
        
        
        
        
        
        
        
      </ul>
  
  </nav>
          </div>
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
              

<nav id="bd-toc-nav">
    <ul class="nav section-nav flex-column">
    
    </ul>
</nav>


              
          </div>
          

          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <h1>Source code for pyspark.pandas.indexes.base</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># Licensed to the Apache Software Foundation (ASF) under one or more</span>
<span class="c1"># contributor license agreements.  See the NOTICE file distributed with</span>
<span class="c1"># this work for additional information regarding copyright ownership.</span>
<span class="c1"># The ASF licenses this file to You under the Apache License, Version 2.0</span>
<span class="c1"># (the &quot;License&quot;); you may not use this file except in compliance with</span>
<span class="c1"># the License.  You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#    http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1">#</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">cast</span><span class="p">,</span> <span class="n">no_type_check</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pandas.api.types</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">is_list_like</span><span class="p">,</span>
    <span class="n">is_interval_dtype</span><span class="p">,</span>
    <span class="n">is_bool_dtype</span><span class="p">,</span>
    <span class="n">is_categorical_dtype</span><span class="p">,</span>
    <span class="n">is_integer_dtype</span><span class="p">,</span>
    <span class="n">is_float_dtype</span><span class="p">,</span>
    <span class="n">is_numeric_dtype</span><span class="p">,</span>
    <span class="n">is_object_dtype</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pandas.core.accessor</span> <span class="kn">import</span> <span class="n">CachedAccessor</span>
<span class="kn">from</span> <span class="nn">pandas.io.formats.printing</span> <span class="kn">import</span> <span class="n">pprint_thing</span>
<span class="kn">from</span> <span class="nn">pandas.api.types</span> <span class="kn">import</span> <span class="n">CategoricalDtype</span><span class="p">,</span> <span class="n">is_hashable</span>
<span class="kn">from</span> <span class="nn">pandas._libs</span> <span class="kn">import</span> <span class="n">lib</span>

<span class="kn">from</span> <span class="nn">pyspark.sql</span> <span class="kn">import</span> <span class="n">functions</span> <span class="k">as</span> <span class="n">F</span><span class="p">,</span> <span class="n">Column</span>
<span class="kn">from</span> <span class="nn">pyspark.sql.types</span> <span class="kn">import</span> <span class="n">FractionalType</span><span class="p">,</span> <span class="n">IntegralType</span><span class="p">,</span> <span class="n">TimestampType</span>

<span class="kn">from</span> <span class="nn">pyspark</span> <span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">ps</span>  <span class="c1"># For running doctests and reference resolution in PyCharm.</span>
<span class="kn">from</span> <span class="nn">pyspark.pandas._typing</span> <span class="kn">import</span> <span class="n">Dtype</span><span class="p">,</span> <span class="n">Label</span><span class="p">,</span> <span class="n">Name</span><span class="p">,</span> <span class="n">Scalar</span>
<span class="kn">from</span> <span class="nn">pyspark.pandas.config</span> <span class="kn">import</span> <span class="n">get_option</span><span class="p">,</span> <span class="n">option_context</span>
<span class="kn">from</span> <span class="nn">pyspark.pandas.base</span> <span class="kn">import</span> <span class="n">IndexOpsMixin</span>
<span class="kn">from</span> <span class="nn">pyspark.pandas.frame</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="kn">from</span> <span class="nn">pyspark.pandas.missing.indexes</span> <span class="kn">import</span> <span class="n">MissingPandasLikeIndex</span>
<span class="kn">from</span> <span class="nn">pyspark.pandas.series</span> <span class="kn">import</span> <span class="n">Series</span><span class="p">,</span> <span class="n">first_series</span>
<span class="kn">from</span> <span class="nn">pyspark.pandas.spark</span> <span class="kn">import</span> <span class="n">functions</span> <span class="k">as</span> <span class="n">SF</span>
<span class="kn">from</span> <span class="nn">pyspark.pandas.spark.accessors</span> <span class="kn">import</span> <span class="n">SparkIndexMethods</span>
<span class="kn">from</span> <span class="nn">pyspark.pandas.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">is_name_like_tuple</span><span class="p">,</span>
    <span class="n">is_name_like_value</span><span class="p">,</span>
    <span class="n">name_like_string</span><span class="p">,</span>
    <span class="n">same_anchor</span><span class="p">,</span>
    <span class="n">scol_for</span><span class="p">,</span>
    <span class="n">verify_temp_column_name</span><span class="p">,</span>
    <span class="n">validate_bool_kwarg</span><span class="p">,</span>
    <span class="n">ERROR_MESSAGE_CANNOT_COMBINE</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pyspark.pandas.internal</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">InternalField</span><span class="p">,</span>
    <span class="n">InternalFrame</span><span class="p">,</span>
    <span class="n">DEFAULT_SERIES_NAME</span><span class="p">,</span>
    <span class="n">SPARK_DEFAULT_INDEX_NAME</span><span class="p">,</span>
    <span class="n">SPARK_INDEX_NAME_FORMAT</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="Index"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.html#pyspark.pandas.Index">[docs]</a><span class="k">class</span> <span class="nc">Index</span><span class="p">(</span><span class="n">IndexOpsMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    pandas-on-Spark Index that corresponds to pandas Index logically. This might hold Spark Column</span>
<span class="sd">    internally.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array-like (1-dimensional)</span>
<span class="sd">    dtype : dtype, default None</span>
<span class="sd">        If dtype is None, we find the dtype that best fits the data.</span>
<span class="sd">        If an actual dtype is provided, we coerce to that dtype if it&#39;s safe.</span>
<span class="sd">        Otherwise, an error will be raised.</span>
<span class="sd">    copy : bool</span>
<span class="sd">        Make a copy of input ndarray.</span>
<span class="sd">    name : object</span>
<span class="sd">        Name to be stored in the index.</span>
<span class="sd">    tupleize_cols : bool (default: True)</span>
<span class="sd">        When True, attempt to create a MultiIndex if possible.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    MultiIndex : A multi-level, or hierarchical, Index.</span>
<span class="sd">    DatetimeIndex : Index of datetime64 data.</span>
<span class="sd">    Int64Index : A special case of :class:`Index` with purely integer labels.</span>
<span class="sd">    Float64Index : A special case of :class:`Index` with purely float labels.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; ps.DataFrame({&#39;a&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]}, index=[1, 2, 3]).index</span>
<span class="sd">    Int64Index([1, 2, 3], dtype=&#39;int64&#39;)</span>

<span class="sd">    &gt;&gt;&gt; ps.DataFrame({&#39;a&#39;: [1, 2, 3]}, index=list(&#39;abc&#39;)).index</span>
<span class="sd">    Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</span>

<span class="sd">    &gt;&gt;&gt; ps.Index([1, 2, 3])</span>
<span class="sd">    Int64Index([1, 2, 3], dtype=&#39;int64&#39;)</span>

<span class="sd">    &gt;&gt;&gt; ps.Index(list(&#39;abc&#39;))</span>
<span class="sd">    Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</span>

<span class="sd">    From a Series:</span>

<span class="sd">    &gt;&gt;&gt; s = ps.Series([1, 2, 3], index=[10, 20, 30])</span>
<span class="sd">    &gt;&gt;&gt; ps.Index(s)</span>
<span class="sd">    Int64Index([1, 2, 3], dtype=&#39;int64&#39;)</span>

<span class="sd">    From an Index:</span>

<span class="sd">    &gt;&gt;&gt; idx = ps.Index([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; ps.Index(idx)</span>
<span class="sd">    Int64Index([1, 2, 3], dtype=&#39;int64&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tupleize_cols</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Index&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_hashable</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Index.name must be a hashable type&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

            <span class="n">internal</span> <span class="o">=</span> <span class="n">InternalFrame</span><span class="p">(</span>
                <span class="n">spark_frame</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_frame</span><span class="p">,</span>
                <span class="n">index_spark_columns</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">data_spark_columns</span><span class="p">,</span>
                <span class="n">index_names</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">column_labels</span><span class="p">,</span>
                <span class="n">index_fields</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">data_fields</span><span class="p">,</span>
                <span class="n">column_labels</span><span class="o">=</span><span class="p">[],</span>
                <span class="n">data_spark_columns</span><span class="o">=</span><span class="p">[],</span>
                <span class="n">data_fields</span><span class="o">=</span><span class="p">[],</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">internal</span><span class="p">)</span><span class="o">.</span><span class="n">index</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">data</span>

        <span class="k">return</span> <span class="n">cast</span><span class="p">(</span>
            <span class="n">Index</span><span class="p">,</span>
            <span class="n">ps</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span>
                    <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                    <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">tupleize_cols</span><span class="o">=</span><span class="n">tupleize_cols</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">kwargs</span>
                <span class="p">)</span>
            <span class="p">),</span>
        <span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_new_instance</span><span class="p">(</span><span class="n">anchor</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Index&quot;</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">pyspark.pandas.indexes.category</span> <span class="kn">import</span> <span class="n">CategoricalIndex</span>
        <span class="kn">from</span> <span class="nn">pyspark.pandas.indexes.datetimes</span> <span class="kn">import</span> <span class="n">DatetimeIndex</span>
        <span class="kn">from</span> <span class="nn">pyspark.pandas.indexes.multi</span> <span class="kn">import</span> <span class="n">MultiIndex</span>
        <span class="kn">from</span> <span class="nn">pyspark.pandas.indexes.numeric</span> <span class="kn">import</span> <span class="n">Float64Index</span><span class="p">,</span> <span class="n">Int64Index</span>

        <span class="k">if</span> <span class="n">anchor</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_level</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">MultiIndex</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">anchor</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">CategoricalDtype</span><span class="p">):</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">CategoricalIndex</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">anchor</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_type_for</span><span class="p">(</span><span class="n">anchor</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">IntegralType</span>
        <span class="p">):</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">Int64Index</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">anchor</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_type_for</span><span class="p">(</span><span class="n">anchor</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">FractionalType</span>
        <span class="p">):</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">Float64Index</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">anchor</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_type_for</span><span class="p">(</span><span class="n">anchor</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">TimestampType</span>
        <span class="p">):</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">DatetimeIndex</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">Index</span><span class="p">)</span>

        <span class="n">instance</span><span class="o">.</span><span class="n">_anchor</span> <span class="o">=</span> <span class="n">anchor</span>
        <span class="k">return</span> <span class="n">instance</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_psdf</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_anchor</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_internal</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">InternalFrame</span><span class="p">:</span>
        <span class="n">internal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psdf</span><span class="o">.</span><span class="n">_internal</span>
        <span class="k">return</span> <span class="n">internal</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
            <span class="n">column_labels</span><span class="o">=</span><span class="n">internal</span><span class="o">.</span><span class="n">index_names</span><span class="p">,</span>
            <span class="n">data_spark_columns</span><span class="o">=</span><span class="n">internal</span><span class="o">.</span><span class="n">index_spark_columns</span><span class="p">,</span>
            <span class="n">data_fields</span><span class="o">=</span><span class="n">internal</span><span class="o">.</span><span class="n">index_fields</span><span class="p">,</span>
            <span class="n">column_label_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_column_label</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Label</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psdf</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_with_new_scol</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scol</span><span class="p">:</span> <span class="n">Column</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">InternalField</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Index&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy pandas-on-Spark Index with the new Spark Column.</span>

<span class="sd">        :param scol: the new Spark Column</span>
<span class="sd">        :return: the copied Index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">internal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
            <span class="n">index_spark_columns</span><span class="o">=</span><span class="p">[</span><span class="n">scol</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">SPARK_DEFAULT_INDEX_NAME</span><span class="p">)],</span>
            <span class="n">index_fields</span><span class="o">=</span><span class="p">[</span>
                <span class="n">field</span>
                <span class="k">if</span> <span class="n">field</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">field</span><span class="o">.</span><span class="n">struct_field</span> <span class="ow">is</span> <span class="kc">None</span>
                <span class="k">else</span> <span class="n">field</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">SPARK_DEFAULT_INDEX_NAME</span><span class="p">)</span>
            <span class="p">],</span>
            <span class="n">column_labels</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">data_spark_columns</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">data_fields</span><span class="o">=</span><span class="p">[],</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">internal</span><span class="p">)</span><span class="o">.</span><span class="n">index</span>

    <span class="n">spark</span> <span class="o">=</span> <span class="n">CachedAccessor</span><span class="p">(</span><span class="s2">&quot;spark&quot;</span><span class="p">,</span> <span class="n">SparkIndexMethods</span><span class="p">)</span>

    <span class="c1"># This method is used via `DataFrame.info` API internally.</span>
    <span class="k">def</span> <span class="nf">_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a summarized representation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            name to use in the summary representation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        String with a summarized representation of the index</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">head</span><span class="p">,</span> <span class="n">tail</span><span class="p">,</span> <span class="n">total_count</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="n">cast</span><span class="p">(</span>
                <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_frame</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
                    <span class="n">F</span><span class="o">.</span><span class="n">first</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span><span class="p">),</span> <span class="n">F</span><span class="o">.</span><span class="n">last</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span><span class="p">),</span> <span class="n">F</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">expr</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">))</span>
                <span class="p">)</span><span class="o">.</span><span class="n">toPandas</span><span class="p">(),</span>
            <span class="p">)</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">total_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">index_summary</span> <span class="o">=</span> <span class="s2">&quot;, </span><span class="si">%s</span><span class="s2"> to </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pprint_thing</span><span class="p">(</span><span class="n">head</span><span class="p">),</span> <span class="n">pprint_thing</span><span class="p">(</span><span class="n">tail</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index_summary</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2"> entries</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">total_count</span><span class="p">,</span> <span class="n">index_summary</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an int representing the number of elements in this object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = ps.DataFrame([(.2, .3), (.0, .6), (.6, .0), (.2, .1)],</span>
<span class="sd">        ...                   columns=[&#39;dogs&#39;, &#39;cats&#39;],</span>
<span class="sd">        ...                   index=list(&#39;abcd&#39;))</span>
<span class="sd">        &gt;&gt;&gt; df.index.size</span>
<span class="sd">        4</span>

<span class="sd">        &gt;&gt;&gt; df.set_index(&#39;dogs&#39;, append=True).index.size</span>
<span class="sd">        4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a tuple of the shape of the underlying data.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = ps.Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</span>
<span class="sd">        &gt;&gt;&gt; idx.shape</span>
<span class="sd">        (3,)</span>

<span class="sd">        &gt;&gt;&gt; midx = ps.MultiIndex.from_tuples([(&#39;a&#39;, &#39;x&#39;), (&#39;b&#39;, &#39;y&#39;), (&#39;c&#39;, &#39;z&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; midx  # doctest: +SKIP</span>
<span class="sd">        MultiIndex([(&#39;a&#39;, &#39;x&#39;),</span>
<span class="sd">                    (&#39;b&#39;, &#39;y&#39;),</span>
<span class="sd">                    (&#39;c&#39;, &#39;z&#39;)],</span>
<span class="sd">                   )</span>
<span class="sd">        &gt;&gt;&gt; midx.shape</span>
<span class="sd">        (3,)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_psdf</span><span class="p">),)</span>

<div class="viewcode-block" id="Index.identical"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.identical.html#pyspark.pandas.Index.identical">[docs]</a>    <span class="k">def</span> <span class="nf">identical</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Index&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Similar to equals, but check that other comparable attributes are</span>
<span class="sd">        also equal.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            If two Index objects have equal elements and same type True,</span>
<span class="sd">            otherwise False.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from pyspark.pandas.config import option_context</span>
<span class="sd">        &gt;&gt;&gt; idx = ps.Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">        &gt;&gt;&gt; midx = ps.MultiIndex.from_tuples([(&#39;a&#39;, &#39;x&#39;), (&#39;b&#39;, &#39;y&#39;), (&#39;c&#39;, &#39;z&#39;)])</span>

<span class="sd">        For Index</span>

<span class="sd">        &gt;&gt;&gt; idx.identical(idx)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; with option_context(&#39;compute.ops_on_diff_frames&#39;, True):</span>
<span class="sd">        ...     idx.identical(ps.Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; with option_context(&#39;compute.ops_on_diff_frames&#39;, True):</span>
<span class="sd">        ...     idx.identical(ps.Index([&#39;b&#39;, &#39;b&#39;, &#39;a&#39;]))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; idx.identical(midx)</span>
<span class="sd">        False</span>

<span class="sd">        For MultiIndex</span>

<span class="sd">        &gt;&gt;&gt; midx.identical(midx)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; with option_context(&#39;compute.ops_on_diff_frames&#39;, True):</span>
<span class="sd">        ...     midx.identical(ps.MultiIndex.from_tuples([(&#39;a&#39;, &#39;x&#39;), (&#39;b&#39;, &#39;y&#39;), (&#39;c&#39;, &#39;z&#39;)]))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; with option_context(&#39;compute.ops_on_diff_frames&#39;, True):</span>
<span class="sd">        ...     midx.identical(ps.MultiIndex.from_tuples([(&#39;c&#39;, &#39;z&#39;), (&#39;b&#39;, &#39;y&#39;), (&#39;a&#39;, &#39;x&#39;)]))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; midx.identical(idx)</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pyspark.pandas.indexes.multi</span> <span class="kn">import</span> <span class="n">MultiIndex</span>

        <span class="n">self_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">other_name</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">names</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span> <span class="k">else</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">self_name</span> <span class="o">==</span> <span class="n">other_name</span>  <span class="c1"># to support non-index comparison by short-circuiting.</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Index.equals"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.equals.html#pyspark.pandas.Index.equals">[docs]</a>    <span class="k">def</span> <span class="nf">equals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Index&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine if two Index objects contain the same elements.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if &quot;other&quot; is an Index and it has the same elements as calling</span>
<span class="sd">            index; False otherwise.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; from pyspark.pandas.config import option_context</span>
<span class="sd">        &gt;&gt;&gt; idx = ps.Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">        &gt;&gt;&gt; idx.name = &quot;name&quot;</span>
<span class="sd">        &gt;&gt;&gt; midx = ps.MultiIndex.from_tuples([(&#39;a&#39;, &#39;x&#39;), (&#39;b&#39;, &#39;y&#39;), (&#39;c&#39;, &#39;z&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; midx.names = (&quot;nameA&quot;, &quot;nameB&quot;)</span>

<span class="sd">        For Index</span>

<span class="sd">        &gt;&gt;&gt; idx.equals(idx)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; with option_context(&#39;compute.ops_on_diff_frames&#39;, True):</span>
<span class="sd">        ...     idx.equals(ps.Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; with option_context(&#39;compute.ops_on_diff_frames&#39;, True):</span>
<span class="sd">        ...     idx.equals(ps.Index([&#39;b&#39;, &#39;b&#39;, &#39;a&#39;]))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; idx.equals(midx)</span>
<span class="sd">        False</span>

<span class="sd">        For MultiIndex</span>

<span class="sd">        &gt;&gt;&gt; midx.equals(midx)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; with option_context(&#39;compute.ops_on_diff_frames&#39;, True):</span>
<span class="sd">        ...     midx.equals(ps.MultiIndex.from_tuples([(&#39;a&#39;, &#39;x&#39;), (&#39;b&#39;, &#39;y&#39;), (&#39;c&#39;, &#39;z&#39;)]))</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; with option_context(&#39;compute.ops_on_diff_frames&#39;, True):</span>
<span class="sd">        ...     midx.equals(ps.MultiIndex.from_tuples([(&#39;c&#39;, &#39;z&#39;), (&#39;b&#39;, &#39;y&#39;), (&#39;a&#39;, &#39;x&#39;)]))</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; midx.equals(idx)</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">same_anchor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;compute.ops_on_diff_frames&quot;</span><span class="p">):</span>
                <span class="c1"># TODO: avoid using default index?</span>
                <span class="k">with</span> <span class="n">option_context</span><span class="p">(</span><span class="s2">&quot;compute.default_index_type&quot;</span><span class="p">,</span> <span class="s2">&quot;distributed-sequence&quot;</span><span class="p">):</span>
                    <span class="c1"># Directly using Series from both self and other seems causing</span>
                    <span class="c1"># some exceptions when &#39;compute.ops_on_diff_frames&#39; is enabled.</span>
                    <span class="c1"># Working around for now via using frame.</span>
                    <span class="k">return</span> <span class="p">(</span>
                        <span class="n">cast</span><span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_series</span><span class="p">(</span><span class="s2">&quot;self&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                        <span class="o">==</span> <span class="n">cast</span><span class="p">(</span><span class="n">Series</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">to_series</span><span class="p">(</span><span class="s2">&quot;other&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">ERROR_MESSAGE_CANNOT_COMBINE</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

    <span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Index&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the transpose, For index, It will be index itself.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = ps.Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</span>

<span class="sd">        &gt;&gt;&gt; idx.transpose()</span>
<span class="sd">        Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</span>

<span class="sd">        For MultiIndex</span>

<span class="sd">        &gt;&gt;&gt; midx = ps.MultiIndex.from_tuples([(&#39;a&#39;, &#39;x&#39;), (&#39;b&#39;, &#39;y&#39;), (&#39;c&#39;, &#39;z&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; midx  # doctest: +SKIP</span>
<span class="sd">        MultiIndex([(&#39;a&#39;, &#39;x&#39;),</span>
<span class="sd">                    (&#39;b&#39;, &#39;y&#39;),</span>
<span class="sd">                    (&#39;c&#39;, &#39;z&#39;)],</span>
<span class="sd">                   )</span>

<span class="sd">        &gt;&gt;&gt; midx.transpose()  # doctest: +SKIP</span>
<span class="sd">        MultiIndex([(&#39;a&#39;, &#39;x&#39;),</span>
<span class="sd">                    (&#39;b&#39;, &#39;y&#39;),</span>
<span class="sd">                    (&#39;c&#39;, &#39;z&#39;)],</span>
<span class="sd">                   )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="n">T</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">transpose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_to_internal_pandas</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a pandas Index directly from _internal to avoid overhead of copy.</span>

<span class="sd">        This method is for internal use only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psdf</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">to_pandas_frame</span><span class="o">.</span><span class="n">index</span>

    <span class="k">def</span> <span class="nf">to_pandas</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a pandas Index.</span>

<span class="sd">        .. note:: This method should only be used if the resulting pandas object is expected</span>
<span class="sd">                  to be small, as all the data is loaded into the driver&#39;s memory.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = ps.DataFrame([(.2, .3), (.0, .6), (.6, .0), (.2, .1)],</span>
<span class="sd">        ...                   columns=[&#39;dogs&#39;, &#39;cats&#39;],</span>
<span class="sd">        ...                   index=list(&#39;abcd&#39;))</span>
<span class="sd">        &gt;&gt;&gt; df[&#39;dogs&#39;].index.to_pandas()</span>
<span class="sd">        Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], dtype=&#39;object&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_internal_pandas</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<div class="viewcode-block" id="Index.to_numpy"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.to_numpy.html#pyspark.pandas.Index.to_numpy">[docs]</a>    <span class="k">def</span> <span class="nf">to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dtype</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A NumPy ndarray representing the values in this Index or MultiIndex.</span>

<span class="sd">        .. note:: This method should only be used if the resulting NumPy ndarray is expected</span>
<span class="sd">            to be small, as all the data is loaded into the driver&#39;s memory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : str or numpy.dtype, optional</span>
<span class="sd">            The dtype to pass to :meth:`numpy.asarray`</span>
<span class="sd">        copy : bool, default False</span>
<span class="sd">            Whether to ensure that the returned value is a not a view on</span>
<span class="sd">            another array. Note that ``copy=False`` does not *ensure* that</span>
<span class="sd">            ``to_numpy()`` is no-copy. Rather, ``copy=True`` ensure that</span>
<span class="sd">            a copy is made, even if not strictly necessary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ps.Series([1, 2, 3, 4]).index.to_numpy()</span>
<span class="sd">        array([0, 1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; ps.DataFrame({&#39;a&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]}, index=[[1, 2, 3], [4, 5, 6]]).index.to_numpy()</span>
<span class="sd">        array([(1, 4), (2, 5), (3, 6)], dtype=object)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_internal_pandas</span><span class="p">()</span><span class="o">.</span><span class="n">_values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Index.map"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.map.html#pyspark.pandas.Index.map">[docs]</a>    <span class="k">def</span> <span class="nf">map</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">dict</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Any</span><span class="p">],</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">],</span> <span class="n">na_action</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Index&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Map values using input correspondence (a dict, Series, or function).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mapper : function, dict, or pd.Series</span>
<span class="sd">            Mapping correspondence.</span>
<span class="sd">        na_action : {None, &#39;ignore&#39;}</span>
<span class="sd">            If ‘ignore’, propagate NA values, without passing them to the mapping correspondence.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        applied : Index, inferred</span>
<span class="sd">            The output of the mapping function applied to the index.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; psidx = ps.Index([1, 2, 3])</span>

<span class="sd">        &gt;&gt;&gt; psidx.map({1: &quot;one&quot;, 2: &quot;two&quot;, 3: &quot;three&quot;})</span>
<span class="sd">        Index([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], dtype=&#39;object&#39;)</span>

<span class="sd">        &gt;&gt;&gt; psidx.map(lambda id: &quot;{id} + 1&quot;.format(id=id))</span>
<span class="sd">        Index([&#39;1 + 1&#39;, &#39;2 + 1&#39;, &#39;3 + 1&#39;], dtype=&#39;object&#39;)</span>

<span class="sd">        &gt;&gt;&gt; pser = pd.Series([&quot;one&quot;, &quot;two&quot;, &quot;three&quot;], index=[1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; psidx.map(pser)</span>
<span class="sd">        Index([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;], dtype=&#39;object&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s2">&quot;If the mapper is a dictionary, its values must be of the same type&quot;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">Index</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_series</span><span class="p">()</span><span class="o">.</span><span class="n">pandas_on_spark</span><span class="o">.</span><span class="n">transform_batch</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">pser</span><span class="p">:</span> <span class="n">pser</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">na_action</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an array representing the data in the Index.</span>

<span class="sd">        .. warning:: We recommend using `Index.to_numpy()` instead.</span>

<span class="sd">        .. note:: This method should only be used if the resulting NumPy ndarray is expected</span>
<span class="sd">            to be small, as all the data is loaded into the driver&#39;s memory.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ps.Series([1, 2, 3, 4]).index.values</span>
<span class="sd">        array([0, 1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; ps.DataFrame({&#39;a&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]}, index=[[1, 2, 3], [4, 5, 6]]).index.values</span>
<span class="sd">        array([(1, 4), (2, 5), (3, 6)], dtype=object)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;We recommend using `</span><span class="si">{}</span><span class="s2">.to_numpy()` instead.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">asi8</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Integer representation of the values.</span>

<span class="sd">        .. warning:: We recommend using `Index.to_numpy()` instead.</span>

<span class="sd">        .. note:: This method should only be used if the resulting NumPy ndarray is expected</span>
<span class="sd">            to be small, as all the data is loaded into the driver&#39;s memory.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            An ndarray with int64 dtype.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ps.Index([1, 2, 3]).asi8</span>
<span class="sd">        array([1, 2, 3])</span>

<span class="sd">        Returns None for non-int64 dtype</span>

<span class="sd">        &gt;&gt;&gt; ps.Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]).asi8 is None</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;We recommend using `</span><span class="si">{}</span><span class="s2">.to_numpy()` instead.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">data_type</span><span class="p">,</span> <span class="n">IntegralType</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">data_type</span><span class="p">,</span> <span class="n">TimestampType</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If index has duplicates, return True, otherwise False.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = ps.Index([1, 5, 7, 7])</span>
<span class="sd">        &gt;&gt;&gt; idx.has_duplicates</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; idx = ps.Index([1, 5, 7])</span>
<span class="sd">        &gt;&gt;&gt; idx.has_duplicates</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; idx = ps.Index([&quot;Watermelon&quot;, &quot;Orange&quot;, &quot;Apple&quot;,</span>
<span class="sd">        ...                 &quot;Watermelon&quot;])</span>
<span class="sd">        &gt;&gt;&gt; idx.has_duplicates</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; idx = ps.Index([&quot;Orange&quot;, &quot;Apple&quot;,</span>
<span class="sd">        ...                 &quot;Watermelon&quot;])</span>
<span class="sd">        &gt;&gt;&gt; idx.has_duplicates</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_frame</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span><span class="p">)</span>
        <span class="n">scol</span> <span class="o">=</span> <span class="n">scol_for</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">sdf</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">sdf</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">scol</span><span class="p">)</span> <span class="o">!=</span> <span class="n">F</span><span class="o">.</span><span class="n">countDistinct</span><span class="p">(</span><span class="n">scol</span><span class="p">))</span><span class="o">.</span><span class="n">first</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_unique</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return if the index has unique values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = ps.Index([1, 5, 7, 7])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_unique</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; idx = ps.Index([1, 5, 7])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_unique</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; idx = ps.Index([&quot;Watermelon&quot;, &quot;Orange&quot;, &quot;Apple&quot;,</span>
<span class="sd">        ...                 &quot;Watermelon&quot;])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_unique</span>
<span class="sd">        False</span>

<span class="sd">        &gt;&gt;&gt; idx = ps.Index([&quot;Orange&quot;, &quot;Apple&quot;,</span>
<span class="sd">        ...                 &quot;Watermelon&quot;])</span>
<span class="sd">        &gt;&gt;&gt; idx.is_unique</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_duplicates</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Name</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return name of the Index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Name</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Name</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Return names of the Index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_names</span>
        <span class="p">]</span>

    <span class="nd">@names</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Name</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Names must be a list-like&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_level</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Length of new names must be </span><span class="si">{}</span><span class="s2">, got </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_level</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_level</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nlevels</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of levels in Index &amp; MultiIndex.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; psdf = ps.DataFrame({&quot;a&quot;: [1, 2, 3]}, index=pd.Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], name=&quot;idx&quot;))</span>
<span class="sd">        &gt;&gt;&gt; psdf.index.nlevels</span>
<span class="sd">        1</span>

<span class="sd">        &gt;&gt;&gt; psdf = ps.DataFrame({&#39;a&#39;: [1, 2, 3]}, index=[list(&#39;abc&#39;), list(&#39;def&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; psdf.index.nlevels</span>
<span class="sd">        2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_level</span>

<div class="viewcode-block" id="Index.rename"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.rename.html#pyspark.pandas.Index.rename">[docs]</a>    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Name</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Name</span><span class="p">]],</span> <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Index&quot;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Alter Index or MultiIndex name.</span>
<span class="sd">        Able to set new names without level. Defaults to returning new index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : label or list of labels</span>
<span class="sd">            Name(s) to set.</span>
<span class="sd">        inplace : boolean, default False</span>
<span class="sd">            Modifies the object directly, instead of creating a new Index or MultiIndex.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index or MultiIndex</span>
<span class="sd">            The same type as the caller or None if inplace is True.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = ps.DataFrame({&#39;a&#39;: [&#39;A&#39;, &#39;C&#39;], &#39;b&#39;: [&#39;A&#39;, &#39;B&#39;]}, columns=[&#39;a&#39;, &#39;b&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df.index.rename(&quot;c&quot;)</span>
<span class="sd">        Int64Index([0, 1], dtype=&#39;int64&#39;, name=&#39;c&#39;)</span>

<span class="sd">        &gt;&gt;&gt; df.set_index(&quot;a&quot;, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; df.index.rename(&quot;d&quot;)</span>
<span class="sd">        Index([&#39;A&#39;, &#39;C&#39;], dtype=&#39;object&#39;, name=&#39;d&#39;)</span>

<span class="sd">        You can also change the index name in place.</span>

<span class="sd">        &gt;&gt;&gt; df.index.rename(&quot;e&quot;, inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; df.index</span>
<span class="sd">        Index([&#39;A&#39;, &#39;C&#39;], dtype=&#39;object&#39;, name=&#39;e&#39;)</span>

<span class="sd">        &gt;&gt;&gt; df  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">           b</span>
<span class="sd">        e</span>
<span class="sd">        A  A</span>
<span class="sd">        C  B</span>

<span class="sd">        Support for MultiIndex</span>

<span class="sd">        &gt;&gt;&gt; psidx = ps.MultiIndex.from_tuples([(&#39;a&#39;, &#39;x&#39;), (&#39;b&#39;, &#39;y&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; psidx.names = [&#39;hello&#39;, &#39;pandas-on-Spark&#39;]</span>
<span class="sd">        &gt;&gt;&gt; psidx  # doctest: +SKIP</span>
<span class="sd">        MultiIndex([(&#39;a&#39;, &#39;x&#39;),</span>
<span class="sd">                    (&#39;b&#39;, &#39;y&#39;)],</span>
<span class="sd">                   names=[&#39;hello&#39;, &#39;pandas-on-Spark&#39;])</span>

<span class="sd">        &gt;&gt;&gt; psidx.rename([&#39;aloha&#39;, &#39;databricks&#39;])  # doctest: +SKIP</span>
<span class="sd">        MultiIndex([(&#39;a&#39;, &#39;x&#39;),</span>
<span class="sd">                    (&#39;b&#39;, &#39;y&#39;)],</span>
<span class="sd">                   names=[&#39;aloha&#39;, &#39;databricks&#39;])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verify_for_rename</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="n">internal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psdf</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">index_names</span><span class="o">=</span><span class="n">names</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_psdf</span><span class="o">.</span><span class="n">_update_internal_frame</span><span class="p">(</span><span class="n">internal</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">internal</span><span class="p">)</span><span class="o">.</span><span class="n">index</span></div>

    <span class="k">def</span> <span class="nf">_verify_for_rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Name</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Label</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">is_hashable</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_name_like_tuple</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">is_name_like_value</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[(</span><span class="n">name</span><span class="p">,)]</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Index.name must be a hashable type&quot;</span><span class="p">)</span>

    <span class="c1"># TODO: add downcast parameter for fillna function</span>
<div class="viewcode-block" id="Index.fillna"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.fillna.html#pyspark.pandas.Index.fillna">[docs]</a>    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Scalar</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Index&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill NA/NaN values with the specified value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : scalar</span>
<span class="sd">            Scalar value to use to fill holes (example: 0). This value cannot be a list-likes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index :</span>
<span class="sd">            filled with value</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = ps.Index([1, 2, None])</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        Float64Index([1.0, 2.0, nan], dtype=&#39;float64&#39;)</span>

<span class="sd">        &gt;&gt;&gt; idx.fillna(0)</span>
<span class="sd">        Float64Index([1.0, 2.0, 0.0], dtype=&#39;float64&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unsupported type </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="n">sdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_frame</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="n">internal</span> <span class="o">=</span> <span class="n">InternalFrame</span><span class="p">(</span>  <span class="c1"># TODO: dtypes?</span>
            <span class="n">spark_frame</span><span class="o">=</span><span class="n">sdf</span><span class="p">,</span>
            <span class="n">index_spark_columns</span><span class="o">=</span><span class="p">[</span>
                <span class="n">scol_for</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_column_names</span>
            <span class="p">],</span>
            <span class="n">index_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_names</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">internal</span><span class="p">)</span><span class="o">.</span><span class="n">index</span></div>

    <span class="c1"># TODO: ADD keep parameter</span>
<div class="viewcode-block" id="Index.drop_duplicates"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.drop_duplicates.html#pyspark.pandas.Index.drop_duplicates">[docs]</a>    <span class="k">def</span> <span class="nf">drop_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Index&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return Index with duplicate values removed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        deduplicated : Index</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.drop_duplicates : Equivalent method on Series.</span>
<span class="sd">        DataFrame.drop_duplicates : Equivalent method on DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Generate an pandas.Index with duplicate values.</span>

<span class="sd">        &gt;&gt;&gt; idx = ps.Index([&#39;lama&#39;, &#39;cow&#39;, &#39;lama&#39;, &#39;beetle&#39;, &#39;lama&#39;, &#39;hippo&#39;])</span>

<span class="sd">        &gt;&gt;&gt; idx.drop_duplicates().sort_values()</span>
<span class="sd">        Index([&#39;beetle&#39;, &#39;cow&#39;, &#39;hippo&#39;, &#39;lama&#39;], dtype=&#39;object&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_frame</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_columns</span>
        <span class="p">)</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
        <span class="n">internal</span> <span class="o">=</span> <span class="n">InternalFrame</span><span class="p">(</span>
            <span class="n">spark_frame</span><span class="o">=</span><span class="n">sdf</span><span class="p">,</span>
            <span class="n">index_spark_columns</span><span class="o">=</span><span class="p">[</span>
                <span class="n">scol_for</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_column_names</span>
            <span class="p">],</span>
            <span class="n">index_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_names</span><span class="p">,</span>
            <span class="n">index_fields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_fields</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">internal</span><span class="p">)</span><span class="o">.</span><span class="n">index</span></div>

<div class="viewcode-block" id="Index.to_series"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.to_series.html#pyspark.pandas.Index.to_series">[docs]</a>    <span class="k">def</span> <span class="nf">to_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Series</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a Series with both index and values equal to the index keys</span>
<span class="sd">        useful with map for returning an indexer based on an index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : string, optional</span>
<span class="sd">            name of resulting Series. If None, defaults to name of original</span>
<span class="sd">            index</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Series : dtype will be based on the type of the Index values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = ps.DataFrame([(.2, .3), (.0, .6), (.6, .0), (.2, .1)],</span>
<span class="sd">        ...                   columns=[&#39;dogs&#39;, &#39;cats&#39;],</span>
<span class="sd">        ...                   index=list(&#39;abcd&#39;))</span>
<span class="sd">        &gt;&gt;&gt; df[&#39;dogs&#39;].index.to_series()</span>
<span class="sd">        a    a</span>
<span class="sd">        b    b</span>
<span class="sd">        c    c</span>
<span class="sd">        d    d</span>
<span class="sd">        dtype: object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_hashable</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Series.name must be a hashable type&quot;</span><span class="p">)</span>
        <span class="n">scol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span>
        <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">data_fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scol</span> <span class="o">=</span> <span class="n">scol</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">name_like_string</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name_like_string</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_level</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">column_labels</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">name</span> <span class="k">if</span> <span class="n">is_name_like_tuple</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">name</span><span class="p">,)</span>
        <span class="p">]</span>  <span class="c1"># type: List[Optional[Label]]</span>
        <span class="n">internal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
            <span class="n">column_labels</span><span class="o">=</span><span class="n">column_labels</span><span class="p">,</span>
            <span class="n">data_spark_columns</span><span class="o">=</span><span class="p">[</span><span class="n">scol</span><span class="p">],</span>
            <span class="n">data_fields</span><span class="o">=</span><span class="p">[</span><span class="n">field</span><span class="p">],</span>
            <span class="n">column_label_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">first_series</span><span class="p">(</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">internal</span><span class="p">))</span></div>

<div class="viewcode-block" id="Index.to_frame"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.to_frame.html#pyspark.pandas.Index.to_frame">[docs]</a>    <span class="k">def</span> <span class="nf">to_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a DataFrame with a column containing the Index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : boolean, default True</span>
<span class="sd">            Set the index of the returned DataFrame as the original Index.</span>
<span class="sd">        name : object, default None</span>
<span class="sd">            The passed name should substitute for the index name (if it has</span>
<span class="sd">            one).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DataFrame</span>
<span class="sd">            DataFrame containing the original Index data.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index.to_series : Convert an Index to a Series.</span>
<span class="sd">        Series.to_frame : Convert Series to DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = ps.Index([&#39;Ant&#39;, &#39;Bear&#39;, &#39;Cow&#39;], name=&#39;animal&#39;)</span>
<span class="sd">        &gt;&gt;&gt; idx.to_frame()  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">               animal</span>
<span class="sd">        animal</span>
<span class="sd">        Ant       Ant</span>
<span class="sd">        Bear     Bear</span>
<span class="sd">        Cow       Cow</span>

<span class="sd">        By default, the original Index is reused. To enforce a new Index:</span>

<span class="sd">        &gt;&gt;&gt; idx.to_frame(index=False)</span>
<span class="sd">          animal</span>
<span class="sd">        0    Ant</span>
<span class="sd">        1   Bear</span>
<span class="sd">        2    Cow</span>

<span class="sd">        To override the name of the resulting column, specify `name`:</span>

<span class="sd">        &gt;&gt;&gt; idx.to_frame(name=&#39;zoo&#39;)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">                 zoo</span>
<span class="sd">        animal</span>
<span class="sd">        Ant      Ant</span>
<span class="sd">        Bear    Bear</span>
<span class="sd">        Cow      Cow</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">DEFAULT_SERIES_NAME</span><span class="p">,)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_name_like_tuple</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_name_like_value</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">name</span><span class="p">,)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;unhashable type: &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_frame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="n">name</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">_to_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Label</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">index</span><span class="p">:</span>
            <span class="n">index_spark_columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_columns</span>
            <span class="n">index_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_names</span>
            <span class="n">index_fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_fields</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index_spark_columns</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">index_names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">index_fields</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">internal</span> <span class="o">=</span> <span class="n">InternalFrame</span><span class="p">(</span>
            <span class="n">spark_frame</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_frame</span><span class="p">,</span>
            <span class="n">index_spark_columns</span><span class="o">=</span><span class="n">index_spark_columns</span><span class="p">,</span>
            <span class="n">index_names</span><span class="o">=</span><span class="n">index_names</span><span class="p">,</span>
            <span class="n">index_fields</span><span class="o">=</span><span class="n">index_fields</span><span class="p">,</span>
            <span class="n">column_labels</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
            <span class="n">data_spark_columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_columns</span><span class="p">,</span>
            <span class="n">data_fields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_fields</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">internal</span><span class="p">)</span>

<div class="viewcode-block" id="Index.is_boolean"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.is_boolean.html#pyspark.pandas.Index.is_boolean">[docs]</a>    <span class="k">def</span> <span class="nf">is_boolean</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return if the current index type is a boolean type.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ps.DataFrame({&#39;a&#39;: [1]}, index=[True]).index.is_boolean()</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">is_bool_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span></div>

<div class="viewcode-block" id="Index.is_categorical"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.is_categorical.html#pyspark.pandas.Index.is_categorical">[docs]</a>    <span class="k">def</span> <span class="nf">is_categorical</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return if the current index type is a categorical type.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ps.DataFrame({&#39;a&#39;: [1]}, index=[1]).index.is_categorical()</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">is_categorical_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span></div>

<div class="viewcode-block" id="Index.is_floating"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.is_floating.html#pyspark.pandas.Index.is_floating">[docs]</a>    <span class="k">def</span> <span class="nf">is_floating</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return if the current index type is a floating type.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ps.DataFrame({&#39;a&#39;: [1]}, index=[1]).index.is_floating()</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">is_float_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span></div>

<div class="viewcode-block" id="Index.is_integer"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.is_integer.html#pyspark.pandas.Index.is_integer">[docs]</a>    <span class="k">def</span> <span class="nf">is_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return if the current index type is a integer type.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ps.DataFrame({&#39;a&#39;: [1]}, index=[1]).index.is_integer()</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">is_integer_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span></div>

<div class="viewcode-block" id="Index.is_interval"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.is_interval.html#pyspark.pandas.Index.is_interval">[docs]</a>    <span class="k">def</span> <span class="nf">is_interval</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return if the current index type is an interval type.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ps.DataFrame({&#39;a&#39;: [1]}, index=[1]).index.is_interval()</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">is_interval_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span></div>

<div class="viewcode-block" id="Index.is_numeric"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.is_numeric.html#pyspark.pandas.Index.is_numeric">[docs]</a>    <span class="k">def</span> <span class="nf">is_numeric</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return if the current index type is a numeric type.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ps.DataFrame({&#39;a&#39;: [1]}, index=[1]).index.is_numeric()</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span></div>

<div class="viewcode-block" id="Index.is_object"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.is_object.html#pyspark.pandas.Index.is_object">[docs]</a>    <span class="k">def</span> <span class="nf">is_object</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return if the current index type is a object type.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ps.DataFrame({&#39;a&#39;: [1]}, index=[&quot;a&quot;]).index.is_object()</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">is_object_dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">is_type_compatible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether the index type is compatible with the provided type.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; psidx = ps.Index([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; psidx.is_type_compatible(&#39;integer&#39;)</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; psidx = ps.Index([1.0, 2.0, 3.0])</span>
<span class="sd">        &gt;&gt;&gt; psidx.is_type_compatible(&#39;integer&#39;)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; psidx.is_type_compatible(&#39;floating&#39;)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">kind</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">inferred_type</span>

<div class="viewcode-block" id="Index.dropna"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.dropna.html#pyspark.pandas.Index.dropna">[docs]</a>    <span class="k">def</span> <span class="nf">dropna</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Index&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return Index or MultiIndex without NA/NaN values</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; df = ps.DataFrame([[1, 2], [4, 5], [7, 8]],</span>
<span class="sd">        ...                   index=[&#39;cobra&#39;, &#39;viper&#39;, None],</span>
<span class="sd">        ...                   columns=[&#39;max_speed&#39;, &#39;shield&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">               max_speed  shield</span>
<span class="sd">        cobra          1       2</span>
<span class="sd">        viper          4       5</span>
<span class="sd">        NaN            7       8</span>

<span class="sd">        &gt;&gt;&gt; df.index.dropna()</span>
<span class="sd">        Index([&#39;cobra&#39;, &#39;viper&#39;], dtype=&#39;object&#39;)</span>

<span class="sd">        Also support for MultiIndex</span>

<span class="sd">        &gt;&gt;&gt; midx = pd.MultiIndex([[&#39;lama&#39;, &#39;cow&#39;, &#39;falcon&#39;],</span>
<span class="sd">        ...                       [None, &#39;weight&#39;, &#39;length&#39;]],</span>
<span class="sd">        ...                      [[0, 1, 1, 1, 1, 1, 2, 2, 2],</span>
<span class="sd">        ...                       [0, 1, 1, 0, 1, 2, 1, 1, 2]])</span>
<span class="sd">        &gt;&gt;&gt; s = ps.Series([45, 200, 1.2, 30, 250, 1.5, 320, 1, None],</span>
<span class="sd">        ...               index=midx)</span>
<span class="sd">        &gt;&gt;&gt; s</span>
<span class="sd">        lama    NaN        45.0</span>
<span class="sd">        cow     weight    200.0</span>
<span class="sd">                weight      1.2</span>
<span class="sd">                NaN        30.0</span>
<span class="sd">                weight    250.0</span>
<span class="sd">                length      1.5</span>
<span class="sd">        falcon  weight    320.0</span>
<span class="sd">                weight      1.0</span>
<span class="sd">                length      NaN</span>
<span class="sd">        dtype: float64</span>

<span class="sd">        &gt;&gt;&gt; s.index.dropna()  # doctest: +SKIP</span>
<span class="sd">        MultiIndex([(   &#39;cow&#39;, &#39;weight&#39;),</span>
<span class="sd">                    (   &#39;cow&#39;, &#39;weight&#39;),</span>
<span class="sd">                    (   &#39;cow&#39;, &#39;weight&#39;),</span>
<span class="sd">                    (   &#39;cow&#39;, &#39;length&#39;),</span>
<span class="sd">                    (&#39;falcon&#39;, &#39;weight&#39;),</span>
<span class="sd">                    (&#39;falcon&#39;, &#39;weight&#39;),</span>
<span class="sd">                    (&#39;falcon&#39;, &#39;length&#39;)],</span>
<span class="sd">                   )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_frame</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_columns</span><span class="p">)</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
        <span class="n">internal</span> <span class="o">=</span> <span class="n">InternalFrame</span><span class="p">(</span>
            <span class="n">spark_frame</span><span class="o">=</span><span class="n">sdf</span><span class="p">,</span>
            <span class="n">index_spark_columns</span><span class="o">=</span><span class="p">[</span>
                <span class="n">scol_for</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_column_names</span>
            <span class="p">],</span>
            <span class="n">index_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_names</span><span class="p">,</span>
            <span class="n">index_fields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_fields</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">internal</span><span class="p">)</span><span class="o">.</span><span class="n">index</span></div>

<div class="viewcode-block" id="Index.unique"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.unique.html#pyspark.pandas.Index.unique">[docs]</a>    <span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Name</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Index&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return unique values in the index.</span>

<span class="sd">        Be aware the order of unique values might be different than pandas.Index.unique</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int or str, optional, default is None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index without duplicates</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.unique</span>
<span class="sd">        groupby.SeriesGroupBy.unique</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ps.DataFrame({&#39;a&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]}, index=[1, 1, 3]).index.unique().sort_values()</span>
<span class="sd">        Int64Index([1, 3], dtype=&#39;int64&#39;)</span>

<span class="sd">        &gt;&gt;&gt; ps.DataFrame({&#39;a&#39;: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]}, index=[&#39;d&#39;, &#39;e&#39;, &#39;e&#39;]).index.unique().sort_values()</span>
<span class="sd">        Index([&#39;d&#39;, &#39;e&#39;], dtype=&#39;object&#39;)</span>

<span class="sd">        MultiIndex</span>

<span class="sd">        &gt;&gt;&gt; ps.MultiIndex.from_tuples([(&quot;A&quot;, &quot;X&quot;), (&quot;A&quot;, &quot;Y&quot;), (&quot;A&quot;, &quot;X&quot;)]).unique()</span>
<span class="sd">        ... # doctest: +SKIP</span>
<span class="sd">        MultiIndex([(&#39;A&#39;, &#39;X&#39;),</span>
<span class="sd">                    (&#39;A&#39;, &#39;Y&#39;)],</span>
<span class="sd">                   )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validate_index_level</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="n">scols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_columns</span>
        <span class="n">sdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psdf</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_frame</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">scols</span><span class="p">)</span><span class="o">.</span><span class="n">distinct</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">InternalFrame</span><span class="p">(</span>
                <span class="n">spark_frame</span><span class="o">=</span><span class="n">sdf</span><span class="p">,</span>
                <span class="n">index_spark_columns</span><span class="o">=</span><span class="p">[</span>
                    <span class="n">scol_for</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_column_names</span>
                <span class="p">],</span>
                <span class="n">index_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_names</span><span class="p">,</span>
                <span class="n">index_fields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_fields</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">index</span></div>

    <span class="c1"># TODO: add error parameter</span>
<div class="viewcode-block" id="Index.drop"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.drop.html#pyspark.pandas.Index.drop">[docs]</a>    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;Index&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make new Index with passed list of labels deleted.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels : array-like</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dropped : Index</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; index = ps.Index([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; index</span>
<span class="sd">        Int64Index([1, 2, 3], dtype=&#39;int64&#39;)</span>

<span class="sd">        &gt;&gt;&gt; index.drop([1])</span>
<span class="sd">        Int64Index([2, 3], dtype=&#39;int64&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">internal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">resolved_copy</span>
        <span class="n">sdf</span> <span class="o">=</span> <span class="n">internal</span><span class="o">.</span><span class="n">spark_frame</span><span class="p">[</span><span class="o">~</span><span class="n">internal</span><span class="o">.</span><span class="n">index_spark_columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">labels</span><span class="p">)]</span>

        <span class="n">internal</span> <span class="o">=</span> <span class="n">InternalFrame</span><span class="p">(</span>
            <span class="n">spark_frame</span><span class="o">=</span><span class="n">sdf</span><span class="p">,</span>
            <span class="n">index_spark_columns</span><span class="o">=</span><span class="p">[</span>
                <span class="n">scol_for</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_column_names</span>
            <span class="p">],</span>
            <span class="n">index_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_names</span><span class="p">,</span>
            <span class="n">index_fields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_fields</span><span class="p">,</span>
            <span class="n">column_labels</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">data_spark_columns</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">data_fields</span><span class="o">=</span><span class="p">[],</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">internal</span><span class="p">)</span><span class="o">.</span><span class="n">index</span></div>

    <span class="k">def</span> <span class="nf">_validate_index_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Name</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate index level.</span>
<span class="sd">        For single-level Index getting level number is a no-op, but some</span>
<span class="sd">        verification must be done like in MultiIndex.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">level</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                    <span class="s2">&quot;Too many levels: Index has only 1 level,&quot;</span>
                    <span class="s2">&quot; </span><span class="si">%d</span><span class="s2"> is not a valid level number&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">level</span><span class="p">,)</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Too many levels:&quot;</span> <span class="s2">&quot; Index has only 1 level, not </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">level</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                <span class="s2">&quot;Requested level (</span><span class="si">{}</span><span class="s2">) does not match index name (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_level_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Name</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;Index&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return Index if a valid level is given.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; psidx = ps.Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], name=&#39;ks&#39;)</span>
<span class="sd">        &gt;&gt;&gt; psidx.get_level_values(0)</span>
<span class="sd">        Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;object&#39;, name=&#39;ks&#39;)</span>

<span class="sd">        &gt;&gt;&gt; psidx.get_level_values(&#39;ks&#39;)</span>
<span class="sd">        Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;object&#39;, name=&#39;ks&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_index_level</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="Index.copy"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.copy.html#pyspark.pandas.Index.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">deep</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Index&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a copy of this object. name sets those attributes on the new object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : string, optional</span>
<span class="sd">            to set name of index</span>
<span class="sd">        deep : None</span>
<span class="sd">            this parameter is not supported but just dummy parameter to match pandas.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; df = ps.DataFrame([[1, 2], [4, 5], [7, 8]],</span>
<span class="sd">        ...                   index=[&#39;cobra&#39;, &#39;viper&#39;, &#39;sidewinder&#39;],</span>
<span class="sd">        ...                   columns=[&#39;max_speed&#39;, &#39;shield&#39;])</span>
<span class="sd">        &gt;&gt;&gt; df</span>
<span class="sd">                    max_speed  shield</span>
<span class="sd">        cobra               1       2</span>
<span class="sd">        viper               4       5</span>
<span class="sd">        sidewinder          7       8</span>
<span class="sd">        &gt;&gt;&gt; df.index</span>
<span class="sd">        Index([&#39;cobra&#39;, &#39;viper&#39;, &#39;sidewinder&#39;], dtype=&#39;object&#39;)</span>

<span class="sd">        Copy index</span>

<span class="sd">        &gt;&gt;&gt; df.index.copy()</span>
<span class="sd">        Index([&#39;cobra&#39;, &#39;viper&#39;, &#39;sidewinder&#39;], dtype=&#39;object&#39;)</span>

<span class="sd">        Copy index with name</span>

<span class="sd">        &gt;&gt;&gt; df.index.copy(name=&#39;snake&#39;)</span>
<span class="sd">        Index([&#39;cobra&#39;, &#39;viper&#39;, &#39;sidewinder&#39;], dtype=&#39;object&#39;, name=&#39;snake&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psdf</span><span class="p">[[]]</span><span class="o">.</span><span class="n">index</span>
        <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Index.droplevel"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.droplevel.html#pyspark.pandas.Index.droplevel">[docs]</a>    <span class="k">def</span> <span class="nf">droplevel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Name</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Name</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="s2">&quot;Index&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return index with requested level(s) removed.</span>
<span class="sd">        If resulting index has only 1 level left, the result will be</span>
<span class="sd">        of Index type, not MultiIndex.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level : int, str, tuple, or list-like, default 0</span>
<span class="sd">            If a string is given, must be the name of a level</span>
<span class="sd">            If list-like, elements must be names or indexes of levels.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index or MultiIndex</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; midx = ps.DataFrame({&#39;a&#39;: [&#39;a&#39;, &#39;b&#39;]}, index=[[&#39;a&#39;, &#39;x&#39;], [&#39;b&#39;, &#39;y&#39;], [1, 2]]).index</span>
<span class="sd">        &gt;&gt;&gt; midx  # doctest: +SKIP</span>
<span class="sd">        MultiIndex([(&#39;a&#39;, &#39;b&#39;, 1),</span>
<span class="sd">                    (&#39;x&#39;, &#39;y&#39;, 2)],</span>
<span class="sd">                   )</span>
<span class="sd">        &gt;&gt;&gt; midx.droplevel([0, 1])  # doctest: +SKIP</span>
<span class="sd">        Int64Index([1, 2], dtype=&#39;int64&#39;)</span>
<span class="sd">        &gt;&gt;&gt; midx.droplevel(0)  # doctest: +SKIP</span>
<span class="sd">        MultiIndex([(&#39;b&#39;, 1),</span>
<span class="sd">                    (&#39;y&#39;, 2)],</span>
<span class="sd">                   )</span>
<span class="sd">        &gt;&gt;&gt; midx.names = [(&quot;a&quot;, &quot;b&quot;), &quot;b&quot;, &quot;c&quot;]</span>
<span class="sd">        &gt;&gt;&gt; midx.droplevel([(&#39;a&#39;, &#39;b&#39;)])  # doctest: +SKIP</span>
<span class="sd">        MultiIndex([(&#39;b&#39;, 1),</span>
<span class="sd">                    (&#39;y&#39;, 2)],</span>
<span class="sd">                   names=[&#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span>
        <span class="n">nlevels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nlevels</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">level</span><span class="p">):</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="p">[</span><span class="n">cast</span><span class="p">(</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Name</span><span class="p">],</span> <span class="n">level</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Name</span><span class="p">]],</span> <span class="n">level</span><span class="p">)</span>

        <span class="n">int_level</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">levels</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">nlevels</span>
                    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                            <span class="s2">&quot;Too many levels: Index has only </span><span class="si">{}</span><span class="s2"> levels, &quot;</span>
                            <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is not a valid level number&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nlevels</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">nlevels</span><span class="p">))</span>
                        <span class="p">)</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="n">nlevels</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                        <span class="s2">&quot;Too many levels: Index has only </span><span class="si">{}</span><span class="s2"> levels, not </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nlevels</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Level </span><span class="si">{}</span><span class="s2"> not found&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="n">int_level</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">nlevels</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot remove </span><span class="si">{}</span><span class="s2"> levels from an index with </span><span class="si">{}</span><span class="s2"> &quot;</span>
                <span class="s2">&quot;levels: at least one level must be &quot;</span>
                <span class="s2">&quot;left.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="p">),</span> <span class="n">nlevels</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">index_spark_columns</span><span class="p">,</span> <span class="n">index_names</span><span class="p">,</span> <span class="n">index_fields</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="o">*</span><span class="p">[</span>
                <span class="n">item</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                    <span class="nb">zip</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_columns</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_names</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_fields</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">int_level</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="n">internal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span>
            <span class="n">index_spark_columns</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">index_spark_columns</span><span class="p">),</span>
            <span class="n">index_names</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">index_names</span><span class="p">),</span>
            <span class="n">index_fields</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">index_fields</span><span class="p">),</span>
            <span class="n">column_labels</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">data_spark_columns</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">data_fields</span><span class="o">=</span><span class="p">[],</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">internal</span><span class="p">)</span><span class="o">.</span><span class="n">index</span></div>

<div class="viewcode-block" id="Index.symmetric_difference"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.symmetric_difference.html#pyspark.pandas.Index.symmetric_difference">[docs]</a>    <span class="k">def</span> <span class="nf">symmetric_difference</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Index&quot;</span><span class="p">,</span>
        <span class="n">result_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sort</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Index&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the symmetric difference of two Index objects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Index or array-like</span>
<span class="sd">        result_name : str</span>
<span class="sd">        sort : True or None, default None</span>
<span class="sd">            Whether to sort the resulting index.</span>
<span class="sd">            * True : Attempt to sort the result.</span>
<span class="sd">            * None : Do not sort the result.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        symmetric_difference : Index</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        ``symmetric_difference`` contains elements that appear in either</span>
<span class="sd">        ``idx1`` or ``idx2`` but not both. Equivalent to the Index created by</span>
<span class="sd">        ``idx1.difference(idx2) | idx2.difference(idx1)`` with duplicates</span>
<span class="sd">        dropped.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; s1 = ps.Series([1, 2, 3, 4], index=[1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; s2 = ps.Series([1, 2, 3, 4], index=[2, 3, 4, 5])</span>

<span class="sd">        &gt;&gt;&gt; s1.index.symmetric_difference(s2.index)  # doctest: +SKIP</span>
<span class="sd">        Int64Index([5, 1], dtype=&#39;int64&#39;)</span>

<span class="sd">        You can set name of result Index.</span>

<span class="sd">        &gt;&gt;&gt; s1.index.symmetric_difference(s2.index, result_name=&#39;pandas-on-Spark&#39;)  # doctest: +SKIP</span>
<span class="sd">        Int64Index([5, 1], dtype=&#39;int64&#39;, name=&#39;pandas-on-Spark&#39;)</span>

<span class="sd">        You can set sort to `True`, if you want to sort the resulting index.</span>

<span class="sd">        &gt;&gt;&gt; s1.index.symmetric_difference(s2.index, sort=True)</span>
<span class="sd">        Int64Index([1, 5], dtype=&#39;int64&#39;)</span>

<span class="sd">        You can also use the ``^`` operator:</span>

<span class="sd">        &gt;&gt;&gt; s1.index ^ s2.index  # doctest: +SKIP</span>
<span class="sd">        Int64Index([5, 1], dtype=&#39;int64&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Doesn&#39;t support symmetric_difference between Index &amp; MultiIndex for now&quot;</span>
            <span class="p">)</span>

        <span class="n">sdf_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psdf</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_frame</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_columns</span><span class="p">)</span>
        <span class="n">sdf_other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_psdf</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_frame</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_columns</span><span class="p">)</span>

        <span class="n">sdf_symdiff</span> <span class="o">=</span> <span class="n">sdf_self</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">sdf_other</span><span class="p">)</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">sdf_self</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">sdf_other</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
            <span class="n">sdf_symdiff</span> <span class="o">=</span> <span class="n">sdf_symdiff</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_column_names</span><span class="p">)</span>

        <span class="n">internal</span> <span class="o">=</span> <span class="n">InternalFrame</span><span class="p">(</span>
            <span class="n">spark_frame</span><span class="o">=</span><span class="n">sdf_symdiff</span><span class="p">,</span>
            <span class="n">index_spark_columns</span><span class="o">=</span><span class="p">[</span>
                <span class="n">scol_for</span><span class="p">(</span><span class="n">sdf_symdiff</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_column_names</span>
            <span class="p">],</span>
            <span class="n">index_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_names</span><span class="p">,</span>
            <span class="n">index_fields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_fields</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">internal</span><span class="p">)</span><span class="o">.</span><span class="n">index</span>

        <span class="k">if</span> <span class="n">result_name</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">result_name</span>

        <span class="k">return</span> <span class="n">result</span></div>

    <span class="c1"># TODO: return_indexer</span>
<div class="viewcode-block" id="Index.sort_values"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.sort_values.html#pyspark.pandas.Index.sort_values">[docs]</a>    <span class="k">def</span> <span class="nf">sort_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ascending</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Index&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a sorted copy of the index.</span>

<span class="sd">        .. note:: This method is not supported for pandas when index has NaN value.</span>
<span class="sd">                  pandas raises unexpected TypeError, but we support treating NaN</span>
<span class="sd">                  as the smallest value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ascending : bool, default True</span>
<span class="sd">            Should the index values be sorted in an ascending order.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sorted_index : ps.Index or ps.MultiIndex</span>
<span class="sd">            Sorted copy of the index.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.sort_values : Sort values of a Series.</span>
<span class="sd">        DataFrame.sort_values : Sort values in a DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = ps.Index([10, 100, 1, 1000])</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        Int64Index([10, 100, 1, 1000], dtype=&#39;int64&#39;)</span>

<span class="sd">        Sort values in ascending order (default behavior).</span>

<span class="sd">        &gt;&gt;&gt; idx.sort_values()</span>
<span class="sd">        Int64Index([1, 10, 100, 1000], dtype=&#39;int64&#39;)</span>

<span class="sd">        Sort values in descending order.</span>

<span class="sd">        &gt;&gt;&gt; idx.sort_values(ascending=False)</span>
<span class="sd">        Int64Index([1000, 100, 10, 1], dtype=&#39;int64&#39;)</span>

<span class="sd">        Support for MultiIndex.</span>

<span class="sd">        &gt;&gt;&gt; psidx = ps.MultiIndex.from_tuples([(&#39;a&#39;, &#39;x&#39;, 1), (&#39;c&#39;, &#39;y&#39;, 2), (&#39;b&#39;, &#39;z&#39;, 3)])</span>
<span class="sd">        &gt;&gt;&gt; psidx  # doctest: +SKIP</span>
<span class="sd">        MultiIndex([(&#39;a&#39;, &#39;x&#39;, 1),</span>
<span class="sd">                    (&#39;c&#39;, &#39;y&#39;, 2),</span>
<span class="sd">                    (&#39;b&#39;, &#39;z&#39;, 3)],</span>
<span class="sd">                   )</span>

<span class="sd">        &gt;&gt;&gt; psidx.sort_values()  # doctest: +SKIP</span>
<span class="sd">        MultiIndex([(&#39;a&#39;, &#39;x&#39;, 1),</span>
<span class="sd">                    (&#39;b&#39;, &#39;z&#39;, 3),</span>
<span class="sd">                    (&#39;c&#39;, &#39;y&#39;, 2)],</span>
<span class="sd">                   )</span>

<span class="sd">        &gt;&gt;&gt; psidx.sort_values(ascending=False)  # doctest: +SKIP</span>
<span class="sd">        MultiIndex([(&#39;c&#39;, &#39;y&#39;, 2),</span>
<span class="sd">                    (&#39;b&#39;, &#39;z&#39;, 3),</span>
<span class="sd">                    (&#39;a&#39;, &#39;x&#39;, 1)],</span>
<span class="sd">                   )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_frame</span>
        <span class="n">sdf</span> <span class="o">=</span> <span class="n">sdf</span><span class="o">.</span><span class="n">orderBy</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_columns</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="n">ascending</span><span class="p">)</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_columns</span>
        <span class="p">)</span>

        <span class="n">internal</span> <span class="o">=</span> <span class="n">InternalFrame</span><span class="p">(</span>
            <span class="n">spark_frame</span><span class="o">=</span><span class="n">sdf</span><span class="p">,</span>
            <span class="n">index_spark_columns</span><span class="o">=</span><span class="p">[</span>
                <span class="n">scol_for</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_column_names</span>
            <span class="p">],</span>
            <span class="n">index_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_names</span><span class="p">,</span>
            <span class="n">index_fields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_fields</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">internal</span><span class="p">)</span><span class="o">.</span><span class="n">index</span></div>

    <span class="nd">@no_type_check</span>
    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use sort_values instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot sort an Index object in-place, use sort_values instead&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Index.min"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.min.html#pyspark.pandas.Index.min">[docs]</a>    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Scalar</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Scalar</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the minimum value of the Index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scalar</span>
<span class="sd">            Minimum value.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index.max : Return the maximum value of the object.</span>
<span class="sd">        Series.min : Return the minimum value in a Series.</span>
<span class="sd">        DataFrame.min : Return the minimum values in a DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = ps.Index([3, 2, 1])</span>
<span class="sd">        &gt;&gt;&gt; idx.min()</span>
<span class="sd">        1</span>

<span class="sd">        &gt;&gt;&gt; idx = ps.Index([&#39;c&#39;, &#39;b&#39;, &#39;a&#39;])</span>
<span class="sd">        &gt;&gt;&gt; idx.min()</span>
<span class="sd">        &#39;a&#39;</span>

<span class="sd">        For a MultiIndex, the maximum is determined lexicographically.</span>

<span class="sd">        &gt;&gt;&gt; idx = ps.MultiIndex.from_tuples([(&#39;a&#39;, &#39;x&#39;, 1), (&#39;b&#39;, &#39;y&#39;, 2)])</span>
<span class="sd">        &gt;&gt;&gt; idx.min()</span>
<span class="sd">        (&#39;a&#39;, &#39;x&#39;, 1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_frame</span>
        <span class="n">min_row</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
            <span class="n">sdf</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_columns</span><span class="p">))</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;min_row&quot;</span><span class="p">))</span>
            <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;min_row.*&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">toPandas</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">min_row</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">result</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Index.max"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.max.html#pyspark.pandas.Index.max">[docs]</a>    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Scalar</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Scalar</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the maximum value of the Index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scalar</span>
<span class="sd">            Maximum value.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index.min : Return the minimum value in an Index.</span>
<span class="sd">        Series.max : Return the maximum value in a Series.</span>
<span class="sd">        DataFrame.max : Return the maximum values in a DataFrame.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = ps.Index([3, 2, 1])</span>
<span class="sd">        &gt;&gt;&gt; idx.max()</span>
<span class="sd">        3</span>

<span class="sd">        &gt;&gt;&gt; idx = ps.Index([&#39;c&#39;, &#39;b&#39;, &#39;a&#39;])</span>
<span class="sd">        &gt;&gt;&gt; idx.max()</span>
<span class="sd">        &#39;c&#39;</span>

<span class="sd">        For a MultiIndex, the maximum is determined lexicographically.</span>

<span class="sd">        &gt;&gt;&gt; idx = ps.MultiIndex.from_tuples([(&#39;a&#39;, &#39;x&#39;, 1), (&#39;b&#39;, &#39;y&#39;, 2)])</span>
<span class="sd">        &gt;&gt;&gt; idx.max()</span>
<span class="sd">        (&#39;b&#39;, &#39;y&#39;, 2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_frame</span>
        <span class="n">max_row</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
            <span class="n">sdf</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_columns</span><span class="p">))</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;max_row&quot;</span><span class="p">))</span>
            <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;max_row.*&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">toPandas</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">max_row</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">result</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Index.delete"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.delete.html#pyspark.pandas.Index.delete">[docs]</a>    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="s2">&quot;Index&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make new Index with passed location(-s) deleted.</span>

<span class="sd">        .. note:: this API can be pretty expensive since it is based on</span>
<span class="sd">             a global sequence internally.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_index : Index</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; psidx = ps.Index([10, 10, 9, 8, 4, 2, 4, 4, 2, 2, 10, 10])</span>
<span class="sd">        &gt;&gt;&gt; psidx</span>
<span class="sd">        Int64Index([10, 10, 9, 8, 4, 2, 4, 4, 2, 2, 10, 10], dtype=&#39;int64&#39;)</span>

<span class="sd">        &gt;&gt;&gt; psidx.delete(0).sort_values()</span>
<span class="sd">        Int64Index([2, 2, 2, 4, 4, 4, 8, 9, 10, 10, 10], dtype=&#39;int64&#39;)</span>

<span class="sd">        &gt;&gt;&gt; psidx.delete([0, 1, 2, 3, 10, 11]).sort_values()</span>
<span class="sd">        Int64Index([2, 2, 2, 4, 4, 4], dtype=&#39;int64&#39;)</span>

<span class="sd">        MultiIndex</span>

<span class="sd">        &gt;&gt;&gt; psidx = ps.MultiIndex.from_tuples([(&#39;a&#39;, &#39;x&#39;, 1), (&#39;b&#39;, &#39;y&#39;, 2), (&#39;c&#39;, &#39;z&#39;, 3)])</span>
<span class="sd">        &gt;&gt;&gt; psidx  # doctest: +SKIP</span>
<span class="sd">        MultiIndex([(&#39;a&#39;, &#39;x&#39;, 1),</span>
<span class="sd">                    (&#39;b&#39;, &#39;y&#39;, 2),</span>
<span class="sd">                    (&#39;c&#39;, &#39;z&#39;, 3)],</span>
<span class="sd">                   )</span>

<span class="sd">        &gt;&gt;&gt; psidx.delete([0, 2]).sort_values()  # doctest: +SKIP</span>
<span class="sd">        MultiIndex([(&#39;b&#39;, &#39;y&#39;, 2)],</span>
<span class="sd">                   )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">is_len_exceeded</span><span class="p">(</span><span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="sd">&quot;&quot;&quot;Check if the given index is exceeded the length or not&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="n">length</span> <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">abs</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">length</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">loc</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_len_exceeded</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">loc</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                    <span class="s2">&quot;index </span><span class="si">{}</span><span class="s2"> is out of bounds for axis 0 with size </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="n">locs</span> <span class="o">=</span> <span class="p">[</span><span class="n">cast</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">loc</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">cast</span><span class="p">(</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">loc</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">is_len_exceeded</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
                        <span class="s2">&quot;index </span><span class="si">{}</span><span class="s2"> is out of bounds for axis 0 with size </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span>
                    <span class="p">)</span>
            <span class="n">locs</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">loc</span><span class="p">)</span>

        <span class="n">locs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">locs</span><span class="p">]</span>
        <span class="n">locs</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">if</span> <span class="n">item</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">length</span> <span class="o">+</span> <span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">locs</span><span class="p">]</span>

        <span class="c1"># we need a temporary column such as &#39;__index_value_0__&#39;</span>
        <span class="c1"># since &#39;InternalFrame.attach_default_index&#39; will be failed</span>
        <span class="c1"># when self._scol has name of &#39;__index_level_0__&#39;</span>
        <span class="n">index_value_column_format</span> <span class="o">=</span> <span class="s2">&quot;__index_value_</span><span class="si">{}</span><span class="s2">__&quot;</span>

        <span class="n">sdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">_sdf</span>
        <span class="n">index_value_column_names</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">verify_temp_column_name</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">index_value_column_format</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_level</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">index_value_columns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">index_scol</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">index_vcol_name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">index_scol</span><span class="p">,</span> <span class="n">index_vcol_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_columns</span><span class="p">,</span> <span class="n">index_value_column_names</span>
            <span class="p">)</span>
        <span class="p">]</span>
        <span class="n">sdf</span> <span class="o">=</span> <span class="n">sdf</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">index_value_columns</span><span class="p">)</span>

        <span class="n">sdf</span> <span class="o">=</span> <span class="n">InternalFrame</span><span class="o">.</span><span class="n">attach_default_index</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">default_index_type</span><span class="o">=</span><span class="s2">&quot;distributed-sequence&quot;</span><span class="p">)</span>
        <span class="c1"># sdf here looks as below</span>
        <span class="c1"># +-----------------+-----------------+-----------------+-----------------+</span>
        <span class="c1"># |__index_level_0__|__index_value_0__|__index_value_1__|__index_value_2__|</span>
        <span class="c1"># +-----------------+-----------------+-----------------+-----------------+</span>
        <span class="c1"># |                0|                a|                x|                1|</span>
        <span class="c1"># |                1|                b|                y|                2|</span>
        <span class="c1"># |                2|                c|                z|                3|</span>
        <span class="c1"># +-----------------+-----------------+-----------------+-----------------+</span>

        <span class="c1"># delete rows which are matched with given `loc`</span>
        <span class="n">sdf</span> <span class="o">=</span> <span class="n">sdf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">SPARK_INDEX_NAME_FORMAT</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">locs</span><span class="p">))</span>
        <span class="n">sdf</span> <span class="o">=</span> <span class="n">sdf</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">index_value_column_names</span><span class="p">)</span>
        <span class="c1"># sdf here looks as below, we should alias them back to origin spark column names</span>
        <span class="c1"># +-----------------+-----------------+-----------------+</span>
        <span class="c1"># |__index_value_0__|__index_value_1__|__index_value_2__|</span>
        <span class="c1"># +-----------------+-----------------+-----------------+</span>
        <span class="c1"># |                c|                z|                3|</span>
        <span class="c1"># +-----------------+-----------------+-----------------+</span>
        <span class="n">index_origin_columns</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">index_vcol_name</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">index_scol_name</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">index_vcol_name</span><span class="p">,</span> <span class="n">index_scol_name</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">index_value_column_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_column_names</span>
            <span class="p">)</span>
        <span class="p">]</span>
        <span class="n">sdf</span> <span class="o">=</span> <span class="n">sdf</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">index_origin_columns</span><span class="p">)</span>

        <span class="n">internal</span> <span class="o">=</span> <span class="n">InternalFrame</span><span class="p">(</span>
            <span class="n">spark_frame</span><span class="o">=</span><span class="n">sdf</span><span class="p">,</span>
            <span class="n">index_spark_columns</span><span class="o">=</span><span class="p">[</span>
                <span class="n">scol_for</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_column_names</span>
            <span class="p">],</span>
            <span class="n">index_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_names</span><span class="p">,</span>
            <span class="n">index_fields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_fields</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">internal</span><span class="p">)</span><span class="o">.</span><span class="n">index</span></div>

<div class="viewcode-block" id="Index.append"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.append.html#pyspark.pandas.Index.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Index&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Index&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append a collection of Index options together.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Index</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        appended : Index</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; psidx = ps.Index([10, 5, 0, 5, 10, 5, 0, 10])</span>
<span class="sd">        &gt;&gt;&gt; psidx</span>
<span class="sd">        Int64Index([10, 5, 0, 5, 10, 5, 0, 10], dtype=&#39;int64&#39;)</span>

<span class="sd">        &gt;&gt;&gt; psidx.append(psidx)</span>
<span class="sd">        Int64Index([10, 5, 0, 5, 10, 5, 0, 10, 10, 5, 0, 5, 10, 5, 0, 10], dtype=&#39;int64&#39;)</span>

<span class="sd">        Support for MiltiIndex</span>

<span class="sd">        &gt;&gt;&gt; psidx = ps.MultiIndex.from_tuples([(&#39;a&#39;, &#39;x&#39;), (&#39;b&#39;, &#39;y&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; psidx  # doctest: +SKIP</span>
<span class="sd">        MultiIndex([(&#39;a&#39;, &#39;x&#39;),</span>
<span class="sd">                    (&#39;b&#39;, &#39;y&#39;)],</span>
<span class="sd">                   )</span>

<span class="sd">        &gt;&gt;&gt; psidx.append(psidx)  # doctest: +SKIP</span>
<span class="sd">        MultiIndex([(&#39;a&#39;, &#39;x&#39;),</span>
<span class="sd">                    (&#39;b&#39;, &#39;y&#39;),</span>
<span class="sd">                    (&#39;a&#39;, &#39;x&#39;),</span>
<span class="sd">                    (&#39;b&#39;, &#39;y&#39;)],</span>
<span class="sd">                   )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pyspark.pandas.indexes.multi</span> <span class="kn">import</span> <span class="n">MultiIndex</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;append() between Index &amp; MultiIndex is currently not supported&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_level</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_level</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;append() between MultiIndexs with different levels is currently not supported&quot;</span>
            <span class="p">)</span>

        <span class="n">index_fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_fields_for_union_like</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">func_name</span><span class="o">=</span><span class="s2">&quot;append&quot;</span><span class="p">)</span>

        <span class="n">sdf_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_frame</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_columns</span><span class="p">)</span>
        <span class="n">sdf_other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_frame</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_columns</span><span class="p">)</span>
        <span class="n">sdf_appended</span> <span class="o">=</span> <span class="n">sdf_self</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">sdf_other</span><span class="p">)</span>

        <span class="c1"># names should be kept when MultiIndex, but Index wouldn&#39;t keep its name.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">index_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_names</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index_names</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">internal</span> <span class="o">=</span> <span class="n">InternalFrame</span><span class="p">(</span>
            <span class="n">spark_frame</span><span class="o">=</span><span class="n">sdf_appended</span><span class="p">,</span>
            <span class="n">index_spark_columns</span><span class="o">=</span><span class="p">[</span>
                <span class="n">scol_for</span><span class="p">(</span><span class="n">sdf_appended</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_column_names</span>
            <span class="p">],</span>
            <span class="n">index_names</span><span class="o">=</span><span class="n">index_names</span><span class="p">,</span>
            <span class="n">index_fields</span><span class="o">=</span><span class="n">index_fields</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">internal</span><span class="p">)</span><span class="o">.</span><span class="n">index</span></div>

<div class="viewcode-block" id="Index.argmax"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.argmax.html#pyspark.pandas.Index.argmax">[docs]</a>    <span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a maximum argument indexer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        skipna : bool, default True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        maximum argument indexer</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; psidx = ps.Index([10, 9, 8, 7, 100, 5, 4, 3, 100, 3])</span>
<span class="sd">        &gt;&gt;&gt; psidx</span>
<span class="sd">        Int64Index([10, 9, 8, 7, 100, 5, 4, 3, 100, 3], dtype=&#39;int64&#39;)</span>

<span class="sd">        &gt;&gt;&gt; psidx.argmax()</span>
<span class="sd">        4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_frame</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span><span class="p">)</span>
        <span class="n">sequence_col</span> <span class="o">=</span> <span class="n">verify_temp_column_name</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="s2">&quot;__distributed_sequence_column__&quot;</span><span class="p">)</span>
        <span class="n">sdf</span> <span class="o">=</span> <span class="n">InternalFrame</span><span class="o">.</span><span class="n">attach_distributed_sequence_column</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">column_name</span><span class="o">=</span><span class="n">sequence_col</span><span class="p">)</span>
        <span class="c1"># spark_frame here looks like below</span>
        <span class="c1"># +-----------------+---------------+</span>
        <span class="c1"># |__index_level_0__|__index_value__|</span>
        <span class="c1"># +-----------------+---------------+</span>
        <span class="c1"># |                0|             10|</span>
        <span class="c1"># |                4|            100|</span>
        <span class="c1"># |                2|              8|</span>
        <span class="c1"># |                3|              7|</span>
        <span class="c1"># |                6|              4|</span>
        <span class="c1"># |                5|              5|</span>
        <span class="c1"># |                7|              3|</span>
        <span class="c1"># |                8|            100|</span>
        <span class="c1"># |                1|              9|</span>
        <span class="c1"># +-----------------+---------------+</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">sdf</span><span class="o">.</span><span class="n">orderBy</span><span class="p">(</span>
                <span class="n">scol_for</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">data_spark_column_names</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">desc</span><span class="p">(),</span>
                <span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">sequence_col</span><span class="p">)</span><span class="o">.</span><span class="n">asc</span><span class="p">(),</span>
            <span class="p">)</span>
            <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">sequence_col</span><span class="p">)</span>
            <span class="o">.</span><span class="n">first</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Index.argmin"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.argmin.html#pyspark.pandas.Index.argmin">[docs]</a>    <span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a minimum argument indexer.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        skipna : bool, default True</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        minimum argument indexer</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; psidx = ps.Index([10, 9, 8, 7, 100, 5, 4, 3, 100, 3])</span>
<span class="sd">        &gt;&gt;&gt; psidx</span>
<span class="sd">        Int64Index([10, 9, 8, 7, 100, 5, 4, 3, 100, 3], dtype=&#39;int64&#39;)</span>

<span class="sd">        &gt;&gt;&gt; psidx.argmin()</span>
<span class="sd">        7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_frame</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span><span class="p">)</span>
        <span class="n">sequence_col</span> <span class="o">=</span> <span class="n">verify_temp_column_name</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="s2">&quot;__distributed_sequence_column__&quot;</span><span class="p">)</span>
        <span class="n">sdf</span> <span class="o">=</span> <span class="n">InternalFrame</span><span class="o">.</span><span class="n">attach_distributed_sequence_column</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">column_name</span><span class="o">=</span><span class="n">sequence_col</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="n">sdf</span><span class="o">.</span><span class="n">orderBy</span><span class="p">(</span>
                <span class="n">scol_for</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">data_spark_column_names</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">asc</span><span class="p">(),</span>
                <span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">sequence_col</span><span class="p">)</span><span class="o">.</span><span class="n">asc</span><span class="p">(),</span>
            <span class="p">)</span>
            <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">sequence_col</span><span class="p">)</span>
            <span class="o">.</span><span class="n">first</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Index.set_names"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.set_names.html#pyspark.pandas.Index.set_names">[docs]</a>    <span class="k">def</span> <span class="nf">set_names</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">names</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Name</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Name</span><span class="p">]],</span>
        <span class="n">level</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Name</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Name</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;Index&quot;</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set Index or MultiIndex name.</span>
<span class="sd">        Able to set new names partially and by level.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        names : label or list of label</span>
<span class="sd">            Name(s) to set.</span>
<span class="sd">        level : int, label or list of int or label, optional</span>
<span class="sd">            If the index is a MultiIndex, level(s) to set (None for all</span>
<span class="sd">            levels). Otherwise level must be None.</span>
<span class="sd">        inplace : bool, default False</span>
<span class="sd">            Modifies the object directly, instead of creating a new Index or</span>
<span class="sd">            MultiIndex.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Index</span>
<span class="sd">            The same type as the caller or None if inplace is True.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Index.rename : Able to set new names without level.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = ps.Index([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        Int64Index([1, 2, 3, 4], dtype=&#39;int64&#39;)</span>

<span class="sd">        &gt;&gt;&gt; idx.set_names(&#39;quarter&#39;)</span>
<span class="sd">        Int64Index([1, 2, 3, 4], dtype=&#39;int64&#39;, name=&#39;quarter&#39;)</span>

<span class="sd">        For MultiIndex</span>

<span class="sd">        &gt;&gt;&gt; idx = ps.MultiIndex.from_tuples([(&#39;a&#39;, &#39;x&#39;), (&#39;b&#39;, &#39;y&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; idx  # doctest: +SKIP</span>
<span class="sd">        MultiIndex([(&#39;a&#39;, &#39;x&#39;),</span>
<span class="sd">                    (&#39;b&#39;, &#39;y&#39;)],</span>
<span class="sd">                   )</span>

<span class="sd">        &gt;&gt;&gt; idx.set_names([&#39;kind&#39;, &#39;year&#39;], inplace=True)</span>
<span class="sd">        &gt;&gt;&gt; idx  # doctest: +SKIP</span>
<span class="sd">        MultiIndex([(&#39;a&#39;, &#39;x&#39;),</span>
<span class="sd">                    (&#39;b&#39;, &#39;y&#39;)],</span>
<span class="sd">                   names=[&#39;kind&#39;, &#39;year&#39;])</span>

<span class="sd">        &gt;&gt;&gt; idx.set_names(&#39;species&#39;, level=0)  # doctest: +SKIP</span>
<span class="sd">        MultiIndex([(&#39;a&#39;, &#39;x&#39;),</span>
<span class="sd">                    (&#39;b&#39;, &#39;y&#39;)],</span>
<span class="sd">                   names=[&#39;species&#39;, &#39;year&#39;])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pyspark.pandas.indexes.multi</span> <span class="kn">import</span> <span class="n">MultiIndex</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">self_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span>
                <span class="n">self_names</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">names</span>  <span class="c1"># type: ignore</span>
                <span class="n">names</span> <span class="o">=</span> <span class="n">self_names</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">names</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span></div>

<div class="viewcode-block" id="Index.difference"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.difference.html#pyspark.pandas.Index.difference">[docs]</a>    <span class="k">def</span> <span class="nf">difference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Index&quot;</span><span class="p">,</span> <span class="n">sort</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Index&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new Index with elements from the index that are not in</span>
<span class="sd">        `other`.</span>

<span class="sd">        This is the set difference of two Index objects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Index or array-like</span>
<span class="sd">        sort : True or None, default None</span>
<span class="sd">            Whether to sort the resulting index.</span>
<span class="sd">            * True : Attempt to sort the result.</span>
<span class="sd">            * None : Do not sort the result.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        difference : Index</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; idx1 = ps.Index([2, 1, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; idx2 = ps.Index([3, 4, 5, 6])</span>
<span class="sd">        &gt;&gt;&gt; idx1.difference(idx2, sort=True)</span>
<span class="sd">        Int64Index([1, 2], dtype=&#39;int64&#39;)</span>

<span class="sd">        MultiIndex</span>

<span class="sd">        &gt;&gt;&gt; midx1 = ps.MultiIndex.from_tuples([(&#39;a&#39;, &#39;x&#39;, 1), (&#39;b&#39;, &#39;y&#39;, 2), (&#39;c&#39;, &#39;z&#39;, 3)])</span>
<span class="sd">        &gt;&gt;&gt; midx2 = ps.MultiIndex.from_tuples([(&#39;a&#39;, &#39;x&#39;, 1), (&#39;b&#39;, &#39;z&#39;, 2), (&#39;k&#39;, &#39;z&#39;, 3)])</span>
<span class="sd">        &gt;&gt;&gt; midx1.difference(midx2)  # doctest: +SKIP</span>
<span class="sd">        MultiIndex([(&#39;b&#39;, &#39;y&#39;, 2),</span>
<span class="sd">                    (&#39;c&#39;, &#39;z&#39;, 3)],</span>
<span class="sd">                   )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pyspark.pandas.indexes.multi</span> <span class="kn">import</span> <span class="n">MultiIndex</span>

        <span class="c1"># Check if the `self` and `other` have different index types.</span>
        <span class="c1"># 1. `self` is Index, `other` is MultiIndex</span>
        <span class="c1"># 2. `self` is MultiIndex, `other` is Index</span>
        <span class="n">is_index_types_different</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Index</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">is_index_types_different</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                <span class="c1"># In case `self` is MultiIndex and `other` is Index,</span>
                <span class="c1"># return MultiIndex without its names.</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rename</span><span class="p">([</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
                <span class="c1"># In case `self` is Index and `other` is MultiIndex,</span>
                <span class="c1"># return Index without its name.</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">Index</span><span class="p">,</span> <span class="n">Series</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input must be Index or array-like&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sort</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="kc">True</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The &#39;sort&#39; keyword only takes the values of None or True; </span><span class="si">{}</span><span class="s2"> was passed.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">sort</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># Handling MultiIndex when `other` is not MultiIndex.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="n">is_other_list_of_tuples</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="nb">dict</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span>
                <span class="p">[</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">other</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">is_other_list_of_tuples</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;other must be a MultiIndex or a list of tuples&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="n">sdf_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_frame</span>
        <span class="n">sdf_other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_frame</span>
        <span class="n">idx_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_columns</span>
        <span class="n">idx_other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_columns</span>
        <span class="n">sdf_diff</span> <span class="o">=</span> <span class="n">sdf_self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">idx_self</span><span class="p">)</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">sdf_other</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">idx_other</span><span class="p">))</span>
        <span class="n">internal</span> <span class="o">=</span> <span class="n">InternalFrame</span><span class="p">(</span>
            <span class="n">spark_frame</span><span class="o">=</span><span class="n">sdf_diff</span><span class="p">,</span>
            <span class="n">index_spark_columns</span><span class="o">=</span><span class="p">[</span>
                <span class="n">scol_for</span><span class="p">(</span><span class="n">sdf_diff</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_column_names</span>
            <span class="p">],</span>
            <span class="n">index_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_names</span><span class="p">,</span>
            <span class="n">index_fields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_fields</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">internal</span><span class="p">)</span><span class="o">.</span><span class="n">index</span>
        <span class="c1"># Name(s) will be kept when only name(s) of (Multi)Index are the same.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="n">result</span> <span class="k">if</span> <span class="n">sort</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">result</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_all_dates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return if all data types of the index are datetime.</span>
<span class="sd">        remember that since pandas-on-Spark does not support multiple data types in an index,</span>
<span class="sd">        so it returns True if any type of data is datetime.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from datetime import datetime</span>

<span class="sd">        &gt;&gt;&gt; idx = ps.Index([datetime(2019, 1, 1, 0, 0, 0), datetime(2019, 2, 3, 0, 0, 0)])</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        DatetimeIndex([&#39;2019-01-01&#39;, &#39;2019-02-03&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)</span>

<span class="sd">        &gt;&gt;&gt; idx.is_all_dates</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; idx = ps.Index([datetime(2019, 1, 1, 0, 0, 0), None])</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        DatetimeIndex([&#39;2019-01-01&#39;, &#39;NaT&#39;], dtype=&#39;datetime64[ns]&#39;, freq=None)</span>

<span class="sd">        &gt;&gt;&gt; idx.is_all_dates</span>
<span class="sd">        True</span>

<span class="sd">        &gt;&gt;&gt; idx = ps.Index([0, 1, 2])</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        Int64Index([0, 1, 2], dtype=&#39;int64&#39;)</span>

<span class="sd">        &gt;&gt;&gt; idx.is_all_dates</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">data_type</span><span class="p">,</span> <span class="n">TimestampType</span><span class="p">)</span>

<div class="viewcode-block" id="Index.repeat"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.repeat.html#pyspark.pandas.Index.repeat">[docs]</a>    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">repeats</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Index&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Repeat elements of a Index/MultiIndex.</span>

<span class="sd">        Returns a new Index/MultiIndex where each element of the current Index/MultiIndex</span>
<span class="sd">        is repeated consecutively a given number of times.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        repeats : int</span>
<span class="sd">            The number of repetitions for each element. This should be a</span>
<span class="sd">            non-negative integer. Repeating 0 times will return an empty</span>
<span class="sd">            Index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        repeated_index : Index/MultiIndex</span>
<span class="sd">            Newly created Index/MultiIndex with repeated elements.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Series.repeat : Equivalent function for Series.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx = ps.Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">        &gt;&gt;&gt; idx</span>
<span class="sd">        Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</span>
<span class="sd">        &gt;&gt;&gt; idx.repeat(2)</span>
<span class="sd">        Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</span>

<span class="sd">        For MultiIndex,</span>

<span class="sd">        &gt;&gt;&gt; midx = ps.MultiIndex.from_tuples([(&#39;x&#39;, &#39;a&#39;), (&#39;x&#39;, &#39;b&#39;), (&#39;y&#39;, &#39;c&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; midx  # doctest: +SKIP</span>
<span class="sd">        MultiIndex([(&#39;x&#39;, &#39;a&#39;),</span>
<span class="sd">                    (&#39;x&#39;, &#39;b&#39;),</span>
<span class="sd">                    (&#39;y&#39;, &#39;c&#39;)],</span>
<span class="sd">                   )</span>
<span class="sd">        &gt;&gt;&gt; midx.repeat(2)  # doctest: +SKIP</span>
<span class="sd">        MultiIndex([(&#39;x&#39;, &#39;a&#39;),</span>
<span class="sd">                    (&#39;x&#39;, &#39;b&#39;),</span>
<span class="sd">                    (&#39;y&#39;, &#39;c&#39;),</span>
<span class="sd">                    (&#39;x&#39;, &#39;a&#39;),</span>
<span class="sd">                    (&#39;x&#39;, &#39;b&#39;),</span>
<span class="sd">                    (&#39;y&#39;, &#39;c&#39;)],</span>
<span class="sd">                   )</span>
<span class="sd">        &gt;&gt;&gt; midx.repeat(0)  # doctest: +SKIP</span>
<span class="sd">        MultiIndex([], )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">repeats</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s2">&quot;`repeats` argument must be integer, but got </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">repeats</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;negative dimensions are not allowed&quot;</span><span class="p">)</span>

        <span class="n">psdf</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">resolved_copy</span><span class="p">)</span>  <span class="c1"># type: DataFrame</span>
        <span class="k">if</span> <span class="n">repeats</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">psdf</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">with_filter</span><span class="p">(</span><span class="n">SF</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="kc">False</span><span class="p">)))</span><span class="o">.</span><span class="n">index</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ps</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">psdf</span><span class="p">]</span> <span class="o">*</span> <span class="n">repeats</span><span class="p">)</span><span class="o">.</span><span class="n">index</span></div>

<div class="viewcode-block" id="Index.asof"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.asof.html#pyspark.pandas.Index.asof">[docs]</a>    <span class="k">def</span> <span class="nf">asof</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Scalar</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the label from the index, or, if not present, the previous one.</span>

<span class="sd">        Assuming that the index is sorted, return the passed index label if it</span>
<span class="sd">        is in the index, or return the previous index label if the passed one</span>
<span class="sd">        is not in the index.</span>

<span class="sd">        .. note:: This API is dependent on :meth:`Index.is_monotonic_increasing`</span>
<span class="sd">            which can be expensive.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : object</span>
<span class="sd">            The label up to which the method returns the latest index label.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        object</span>
<span class="sd">            The passed label if it is in the index. The previous label if the</span>
<span class="sd">            passed label is not in the sorted index or `NaN` if there is no</span>
<span class="sd">            such label.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        `Index.asof` returns the latest index label up to the passed label.</span>

<span class="sd">        &gt;&gt;&gt; idx = ps.Index([&#39;2013-12-31&#39;, &#39;2014-01-02&#39;, &#39;2014-01-03&#39;])</span>
<span class="sd">        &gt;&gt;&gt; idx.asof(&#39;2014-01-01&#39;)</span>
<span class="sd">        &#39;2013-12-31&#39;</span>

<span class="sd">        If the label is in the index, the method returns the passed label.</span>

<span class="sd">        &gt;&gt;&gt; idx.asof(&#39;2014-01-02&#39;)</span>
<span class="sd">        &#39;2014-01-02&#39;</span>

<span class="sd">        If all of the labels in the index are later than the passed label,</span>
<span class="sd">        NaN is returned.</span>

<span class="sd">        &gt;&gt;&gt; idx.asof(&#39;1999-01-02&#39;)</span>
<span class="sd">        nan</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_frame</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic_increasing</span><span class="p">:</span>
            <span class="n">sdf</span> <span class="o">=</span> <span class="n">sdf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span> <span class="o">&lt;=</span> <span class="n">SF</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">data_type</span><span class="p">))</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
                <span class="n">F</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_monotonic_decreasing</span><span class="p">:</span>
            <span class="n">sdf</span> <span class="o">=</span> <span class="n">sdf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span> <span class="o">&gt;=</span> <span class="n">SF</span><span class="o">.</span><span class="n">lit</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">data_type</span><span class="p">))</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
                <span class="n">F</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">column</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;index must be monotonic increasing or decreasing&quot;</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">sdf</span><span class="o">.</span><span class="n">toPandas</span><span class="p">())</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span> <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>

    <span class="k">def</span> <span class="nf">_index_fields_for_union_like</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;Index&quot;</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Index&quot;</span><span class="p">,</span> <span class="n">func_name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">InternalField</span><span class="p">]]:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_fields</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_fields</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_fields</span>
        <span class="k">elif</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">left</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">right</span><span class="o">.</span><span class="n">dtype</span>
            <span class="ow">and</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">CategoricalDtype</span><span class="p">)</span> <span class="ow">or</span> <span class="n">left</span><span class="o">.</span><span class="n">spark_type</span> <span class="o">==</span> <span class="n">right</span><span class="o">.</span><span class="n">spark_type</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_fields</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_fields</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span>
                <span class="n">left</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">nullable</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">nullable</span> <span class="ow">or</span> <span class="n">right</span><span class="o">.</span><span class="n">nullable</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">left</span><span class="o">.</span><span class="n">spark_type</span> <span class="o">==</span> <span class="n">right</span><span class="o">.</span><span class="n">spark_type</span>
                <span class="k">else</span> <span class="n">InternalField</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">left</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_fields</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_fields</span><span class="p">)</span>
            <span class="p">]</span>
        <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">CategoricalDtype</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_fields</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_fields</span>
        <span class="p">):</span>
            <span class="c1"># TODO: non-categorical or categorical with different categories</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">() between CategoricalIndex and non-categorical or &quot;</span>
                <span class="s2">&quot;categorical with different categories is currently not supported&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">func_name</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="Index.union"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.union.html#pyspark.pandas.Index.union">[docs]</a>    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">Series</span><span class="p">,</span> <span class="s2">&quot;Index&quot;</span><span class="p">,</span> <span class="n">List</span><span class="p">],</span> <span class="n">sort</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Index&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Form the union of two Index objects.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Index or array-like</span>
<span class="sd">        sort : bool or None, default None</span>
<span class="sd">            Whether to sort the resulting Index.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        union : Index</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Index</span>

<span class="sd">        &gt;&gt;&gt; idx1 = ps.Index([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; idx2 = ps.Index([3, 4, 5, 6])</span>
<span class="sd">        &gt;&gt;&gt; idx1.union(idx2).sort_values()</span>
<span class="sd">        Int64Index([1, 2, 3, 4, 5, 6], dtype=&#39;int64&#39;)</span>

<span class="sd">        MultiIndex</span>

<span class="sd">        &gt;&gt;&gt; midx1 = ps.MultiIndex.from_tuples([(&quot;x&quot;, &quot;a&quot;), (&quot;x&quot;, &quot;b&quot;), (&quot;x&quot;, &quot;c&quot;), (&quot;x&quot;, &quot;d&quot;)])</span>
<span class="sd">        &gt;&gt;&gt; midx2 = ps.MultiIndex.from_tuples([(&quot;x&quot;, &quot;c&quot;), (&quot;x&quot;, &quot;d&quot;), (&quot;x&quot;, &quot;e&quot;), (&quot;x&quot;, &quot;f&quot;)])</span>
<span class="sd">        &gt;&gt;&gt; midx1.union(midx2).sort_values()  # doctest: +SKIP</span>
<span class="sd">        MultiIndex([(&#39;x&#39;, &#39;a&#39;),</span>
<span class="sd">                    (&#39;x&#39;, &#39;b&#39;),</span>
<span class="sd">                    (&#39;x&#39;, &#39;c&#39;),</span>
<span class="sd">                    (&#39;x&#39;, &#39;d&#39;),</span>
<span class="sd">                    (&#39;x&#39;, &#39;e&#39;),</span>
<span class="sd">                    (&#39;x&#39;, &#39;f&#39;)],</span>
<span class="sd">                   )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pyspark.pandas.indexes.multi</span> <span class="kn">import</span> <span class="n">MultiIndex</span>

        <span class="n">sort</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">sort</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sort</span>
        <span class="n">sort</span> <span class="o">=</span> <span class="n">validate_bool_kwarg</span><span class="p">(</span><span class="n">sort</span><span class="p">,</span> <span class="s2">&quot;sort&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                <span class="n">other_idx</span> <span class="o">=</span> <span class="n">other</span>  <span class="c1"># type: Index</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">other</span><span class="p">):</span>
                <span class="n">other_idx</span> <span class="o">=</span> <span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;other must be a MultiIndex or a list of tuples&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                <span class="c1"># TODO: We can&#39;t support different type of values in a single column for now.</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Union between Index and MultiIndex is not yet supported&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Index data must be 1-dimensional&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">other_idx</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="n">index_fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_fields_for_union_like</span><span class="p">(</span><span class="n">other_idx</span><span class="p">,</span> <span class="n">func_name</span><span class="o">=</span><span class="s2">&quot;union&quot;</span><span class="p">)</span>

        <span class="n">sdf_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_frame</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_columns</span><span class="p">)</span>
        <span class="n">sdf_other</span> <span class="o">=</span> <span class="n">other_idx</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">spark_frame</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">other_idx</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_columns</span><span class="p">)</span>
        <span class="n">sdf</span> <span class="o">=</span> <span class="n">sdf_self</span><span class="o">.</span><span class="n">unionAll</span><span class="p">(</span><span class="n">sdf_other</span><span class="p">)</span><span class="o">.</span><span class="n">exceptAll</span><span class="p">(</span><span class="n">sdf_self</span><span class="o">.</span><span class="n">intersectAll</span><span class="p">(</span><span class="n">sdf_other</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
            <span class="n">sdf</span> <span class="o">=</span> <span class="n">sdf</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_column_names</span><span class="p">)</span>

        <span class="n">internal</span> <span class="o">=</span> <span class="n">InternalFrame</span><span class="p">(</span>
            <span class="n">spark_frame</span><span class="o">=</span><span class="n">sdf</span><span class="p">,</span>
            <span class="n">index_spark_columns</span><span class="o">=</span><span class="p">[</span>
                <span class="n">scol_for</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_column_names</span>
            <span class="p">],</span>
            <span class="n">index_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_names</span><span class="p">,</span>
            <span class="n">index_fields</span><span class="o">=</span><span class="n">index_fields</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">internal</span><span class="p">)</span><span class="o">.</span><span class="n">index</span></div>

    <span class="k">def</span> <span class="nf">holds_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether the type is an integer type.</span>
<span class="sd">        Always return False for MultiIndex.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        When Index contains null values the result can be different with pandas</span>
<span class="sd">        since pandas-on-Spark cast integer to float when Index contains null values.</span>

<span class="sd">        &gt;&gt;&gt; ps.Index([1, 2, 3, None])</span>
<span class="sd">        Float64Index([1.0, 2.0, 3.0, nan], dtype=&#39;float64&#39;)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; psidx = ps.Index([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; psidx.holds_integer()</span>
<span class="sd">        True</span>

<span class="sd">        Returns False for string type.</span>

<span class="sd">        &gt;&gt;&gt; psidx = ps.Index([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;])</span>
<span class="sd">        &gt;&gt;&gt; psidx.holds_integer()</span>
<span class="sd">        False</span>

<span class="sd">        Returns False for float type.</span>

<span class="sd">        &gt;&gt;&gt; psidx = ps.Index([1.1, 2.2, 3.3, 4.4])</span>
<span class="sd">        &gt;&gt;&gt; psidx.holds_integer()</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spark</span><span class="o">.</span><span class="n">data_type</span><span class="p">,</span> <span class="n">IntegralType</span><span class="p">)</span>

<div class="viewcode-block" id="Index.intersection"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.intersection.html#pyspark.pandas.Index.intersection">[docs]</a>    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">Series</span><span class="p">,</span> <span class="s2">&quot;Index&quot;</span><span class="p">,</span> <span class="n">List</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;Index&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Form the intersection of two Index objects.</span>

<span class="sd">        This returns a new Index with elements common to the index and `other`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Index or array-like</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        intersection : Index</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; idx1 = ps.Index([1, 2, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; idx2 = ps.Index([3, 4, 5, 6])</span>
<span class="sd">        &gt;&gt;&gt; idx1.intersection(idx2).sort_values()</span>
<span class="sd">        Int64Index([3, 4], dtype=&#39;int64&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pyspark.pandas.indexes.multi</span> <span class="kn">import</span> <span class="n">MultiIndex</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataFrame</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Index data must be 1-dimensional&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
            <span class="c1"># Always returns a no-named empty Index if `other` is MultiIndex.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psdf</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Index</span><span class="p">):</span>
            <span class="n">spark_frame_other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">to_spark</span><span class="p">()</span>
            <span class="n">keep_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">name</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Series</span><span class="p">):</span>
            <span class="n">spark_frame_other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">to_spark</span><span class="p">()</span>
            <span class="n">keep_name</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">is_list_like</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">Index</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">MultiIndex</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">index</span>
            <span class="n">spark_frame_other</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">to_spark</span><span class="p">()</span>
            <span class="n">keep_name</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input must be Index or array-like&quot;</span><span class="p">)</span>

        <span class="n">index_fields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_fields_for_union_like</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">func_name</span><span class="o">=</span><span class="s2">&quot;intersection&quot;</span><span class="p">)</span>

        <span class="n">spark_frame_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">SPARK_DEFAULT_INDEX_NAME</span><span class="p">)</span><span class="o">.</span><span class="n">to_spark</span><span class="p">()</span>
        <span class="n">spark_frame_intersected</span> <span class="o">=</span> <span class="n">spark_frame_self</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">spark_frame_other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keep_name</span><span class="p">:</span>
            <span class="n">index_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_names</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index_names</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">internal</span> <span class="o">=</span> <span class="n">InternalFrame</span><span class="p">(</span>
            <span class="n">spark_frame</span><span class="o">=</span><span class="n">spark_frame_intersected</span><span class="p">,</span>
            <span class="n">index_spark_columns</span><span class="o">=</span><span class="p">[</span><span class="n">scol_for</span><span class="p">(</span><span class="n">spark_frame_intersected</span><span class="p">,</span> <span class="n">SPARK_DEFAULT_INDEX_NAME</span><span class="p">)],</span>
            <span class="n">index_names</span><span class="o">=</span><span class="n">index_names</span><span class="p">,</span>
            <span class="n">index_fields</span><span class="o">=</span><span class="n">index_fields</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">internal</span><span class="p">)</span><span class="o">.</span><span class="n">index</span></div>

<div class="viewcode-block" id="Index.item"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.item.html#pyspark.pandas.Index.item">[docs]</a>    <span class="k">def</span> <span class="nf">item</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Scalar</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Scalar</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the first element of the underlying data as a python scalar.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scalar</span>
<span class="sd">            The first element of Index.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the data is not length-1.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; psidx = ps.Index([10])</span>
<span class="sd">        &gt;&gt;&gt; psidx.item()</span>
<span class="sd">        10</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_series</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span></div>

<div class="viewcode-block" id="Index.insert"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.insert.html#pyspark.pandas.Index.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Index&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make new Index inserting new item at location.</span>

<span class="sd">        Follows Python list.append semantics for negative values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loc : int</span>
<span class="sd">        item : object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_index : Index</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; psidx = ps.Index([1, 2, 3, 4, 5])</span>
<span class="sd">        &gt;&gt;&gt; psidx.insert(3, 100)</span>
<span class="sd">        Int64Index([1, 2, 3, 100, 4, 5], dtype=&#39;int64&#39;)</span>

<span class="sd">        For negative values</span>

<span class="sd">        &gt;&gt;&gt; psidx = ps.Index([1, 2, 3, 4, 5])</span>
<span class="sd">        &gt;&gt;&gt; psidx.insert(-3, 100)</span>
<span class="sd">        Int64Index([1, 2, 100, 3, 4, 5], dtype=&#39;int64&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">+</span> <span class="n">length</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">loc</span>

        <span class="n">index_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_column_names</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sdf_before</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">index_name</span><span class="p">)[:</span><span class="n">loc</span><span class="p">]</span><span class="o">.</span><span class="n">to_spark</span><span class="p">()</span>
        <span class="n">sdf_middle</span> <span class="o">=</span> <span class="n">Index</span><span class="p">([</span><span class="n">item</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">index_name</span><span class="p">)</span><span class="o">.</span><span class="n">to_spark</span><span class="p">()</span>
        <span class="n">sdf_after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">index_name</span><span class="p">)[</span><span class="n">loc</span><span class="p">:]</span><span class="o">.</span><span class="n">to_spark</span><span class="p">()</span>
        <span class="n">sdf</span> <span class="o">=</span> <span class="n">sdf_before</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">sdf_middle</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">sdf_after</span><span class="p">)</span>

        <span class="n">internal</span> <span class="o">=</span> <span class="n">InternalFrame</span><span class="p">(</span>
            <span class="n">spark_frame</span><span class="o">=</span><span class="n">sdf</span><span class="p">,</span>
            <span class="n">index_spark_columns</span><span class="o">=</span><span class="p">[</span>
                <span class="n">scol_for</span><span class="p">(</span><span class="n">sdf</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_spark_column_names</span>
            <span class="p">],</span>
            <span class="n">index_names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_names</span><span class="p">,</span>
            <span class="n">index_fields</span><span class="o">=</span><span class="p">[</span><span class="n">InternalField</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">index_fields</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">internal</span><span class="p">)</span><span class="o">.</span><span class="n">index</span></div>

<div class="viewcode-block" id="Index.view"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.view.html#pyspark.pandas.Index.view">[docs]</a>    <span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Index&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        this is defined as a copy with the same identity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="Index.to_list"><a class="viewcode-back" href="../../../../reference/pyspark.pandas/api/pyspark.pandas.Index.to_list.html#pyspark.pandas.Index.to_list">[docs]</a>    <span class="k">def</span> <span class="nf">to_list</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of the values.</span>

<span class="sd">        These are each a scalar type, which is a Python scalar</span>
<span class="sd">        (for str, int, float) or a pandas scalar</span>
<span class="sd">        (for Timestamp/Timedelta/Interval/Period)</span>

<span class="sd">        .. note:: This method should only be used if the resulting list is expected</span>
<span class="sd">            to be small, as all the data is loaded into the driver&#39;s memory.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Index</span>

<span class="sd">        &gt;&gt;&gt; idx = ps.Index([1, 2, 3, 4, 5])</span>
<span class="sd">        &gt;&gt;&gt; idx.to_list()</span>
<span class="sd">        [1, 2, 3, 4, 5]</span>

<span class="sd">        MultiIndex</span>

<span class="sd">        &gt;&gt;&gt; tuples = [(1, &#39;red&#39;), (1, &#39;blue&#39;), (2, &#39;red&#39;), (2, &#39;green&#39;)]</span>
<span class="sd">        &gt;&gt;&gt; midx = ps.MultiIndex.from_tuples(tuples)</span>
<span class="sd">        &gt;&gt;&gt; midx.to_list()</span>
<span class="sd">        [(1, &#39;red&#39;), (1, &#39;blue&#39;), (2, &#39;red&#39;), (2, &#39;green&#39;)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_internal_pandas</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span></div>

    <span class="n">tolist</span> <span class="o">=</span> <span class="n">to_list</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">inferred_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a string of the type inferred from the values.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from datetime import datetime</span>
<span class="sd">        &gt;&gt;&gt; ps.Index([1, 2, 3]).inferred_type</span>
<span class="sd">        &#39;integer&#39;</span>

<span class="sd">        &gt;&gt;&gt; ps.Index([1.0, 2.0, 3.0]).inferred_type</span>
<span class="sd">        &#39;floating&#39;</span>

<span class="sd">        &gt;&gt;&gt; ps.Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]).inferred_type</span>
<span class="sd">        &#39;string&#39;</span>

<span class="sd">        &gt;&gt;&gt; ps.Index([True, False, True, False]).inferred_type</span>
<span class="sd">        &#39;boolean&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">lib</span><span class="o">.</span><span class="n">infer_dtype</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">to_series</span><span class="p">()</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()])</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">MissingPandasLikeIndex</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
            <span class="n">property_or_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">MissingPandasLikeIndex</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">property_or_func</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">property_or_func</span><span class="o">.</span><span class="n">fget</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">partial</span><span class="p">(</span><span class="n">property_or_func</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39; object has no attribute &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">item</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">max_display_count</span> <span class="o">=</span> <span class="n">get_option</span><span class="p">(</span><span class="s2">&quot;display.max_rows&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">max_display_count</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_to_internal_pandas</span><span class="p">())</span>

        <span class="n">pindex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_psdf</span><span class="o">.</span><span class="n">_get_or_create_repr_pandas_cache</span><span class="p">(</span><span class="n">max_display_count</span><span class="p">)</span><span class="o">.</span><span class="n">index</span>

        <span class="n">pindex_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pindex</span><span class="p">)</span>
        <span class="n">repr_string</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">pindex</span><span class="p">[:</span><span class="n">max_display_count</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">pindex_length</span> <span class="o">&gt;</span> <span class="n">max_display_count</span><span class="p">:</span>
            <span class="n">footer</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Showing only the first </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">max_display_count</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">repr_string</span> <span class="o">+</span> <span class="n">footer</span>
        <span class="k">return</span> <span class="n">repr_string</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">MissingPandasLikeIndex</span><span class="o">.</span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Index&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Index&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">symmetric_difference</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The truth value of a </span><span class="si">{0}</span><span class="s2"> is ambiguous. &quot;</span>
            <span class="s2">&quot;Use a.empty, a.bool(), a.item(), a.any() or a.all().&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_test</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">os</span>
    <span class="kn">import</span> <span class="nn">doctest</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="kn">from</span> <span class="nn">pyspark.sql</span> <span class="kn">import</span> <span class="n">SparkSession</span>
    <span class="kn">import</span> <span class="nn">pyspark.pandas.indexes.base</span>

    <span class="n">os</span><span class="o">.</span><span class="n">chdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;SPARK_HOME&quot;</span><span class="p">])</span>

    <span class="n">globs</span> <span class="o">=</span> <span class="n">pyspark</span><span class="o">.</span><span class="n">pandas</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">globs</span><span class="p">[</span><span class="s2">&quot;ps&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pyspark</span><span class="o">.</span><span class="n">pandas</span>
    <span class="n">spark</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">SparkSession</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">master</span><span class="p">(</span><span class="s2">&quot;local[4]&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">appName</span><span class="p">(</span><span class="s2">&quot;pyspark.pandas.indexes.base tests&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">getOrCreate</span><span class="p">()</span>
    <span class="p">)</span>
    <span class="p">(</span><span class="n">failure_count</span><span class="p">,</span> <span class="n">test_count</span><span class="p">)</span> <span class="o">=</span> <span class="n">doctest</span><span class="o">.</span><span class="n">testmod</span><span class="p">(</span>
        <span class="n">pyspark</span><span class="o">.</span><span class="n">pandas</span><span class="o">.</span><span class="n">indexes</span><span class="o">.</span><span class="n">base</span><span class="p">,</span>
        <span class="n">globs</span><span class="o">=</span><span class="n">globs</span><span class="p">,</span>
        <span class="n">optionflags</span><span class="o">=</span><span class="n">doctest</span><span class="o">.</span><span class="n">ELLIPSIS</span> <span class="o">|</span> <span class="n">doctest</span><span class="o">.</span><span class="n">NORMALIZE_WHITESPACE</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">spark</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">failure_count</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">_test</span><span class="p">()</span>
</pre></div>

              </div>
              
              
              <div class='prev-next-bottom'>
                

              </div>
              
          </main>
          

      </div>
    </div>

    
  <script src="../../../../_static/js/index.3da636dd464baa7582d2.js"></script>


    <footer class="footer mt-5 mt-md-0">
  <div class="container">
    <p>
          &copy; Copyright .<br/>
        Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.0.4.<br/>
    </p>
  </div>
</footer>
  </body>
</html>