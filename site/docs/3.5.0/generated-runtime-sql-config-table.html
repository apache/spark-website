
<table class="table">
<tr><th>Property Name</th><th>Default</th><th>Meaning</th><th>Since Version</th></tr>

<tr>
    <td><code>spark.sql.adaptive.advisoryPartitionSizeInBytes</code></td>
    <td>(value of <code>spark.sql.adaptive.shuffle.targetPostShuffleInputSize</code>)</td>
    <td><p>The advisory size in bytes of the shuffle partition during adaptive optimization (when spark.sql.adaptive.enabled is true). It takes effect when Spark coalesces small shuffle partitions or splits skewed shuffle partition.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.adaptive.autoBroadcastJoinThreshold</code></td>
    <td>(none)</td>
    <td><p>Configures the maximum size in bytes for a table that will be broadcast to all worker nodes when performing a join. By setting this value to -1 broadcasting can be disabled. The default value is same with spark.sql.autoBroadcastJoinThreshold. Note that, this config is used only in adaptive framework.</p></td>
    <td>3.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.adaptive.coalescePartitions.enabled</code></td>
    <td>true</td>
    <td><p>When true and 'spark.sql.adaptive.enabled' is true, Spark will coalesce contiguous shuffle partitions according to the target size (specified by 'spark.sql.adaptive.advisoryPartitionSizeInBytes'), to avoid too many small tasks.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.adaptive.coalescePartitions.initialPartitionNum</code></td>
    <td>(none)</td>
    <td><p>The initial number of shuffle partitions before coalescing. If not set, it equals to spark.sql.shuffle.partitions. This configuration only has an effect when 'spark.sql.adaptive.enabled' and 'spark.sql.adaptive.coalescePartitions.enabled' are both true.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.adaptive.coalescePartitions.minPartitionSize</code></td>
    <td>1MB</td>
    <td><p>The minimum size of shuffle partitions after coalescing. This is useful when the adaptively calculated target size is too small during partition coalescing.</p></td>
    <td>3.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.adaptive.coalescePartitions.parallelismFirst</code></td>
    <td>true</td>
    <td><p>When true, Spark does not respect the target size specified by 'spark.sql.adaptive.advisoryPartitionSizeInBytes' (default 64MB) when coalescing contiguous shuffle partitions, but adaptively calculate the target size according to the default parallelism of the Spark cluster. The calculated size is usually smaller than the configured target size. This is to maximize the parallelism and avoid performance regression when enabling adaptive query execution. It's recommended to set this config to false and respect the configured target size.</p></td>
    <td>3.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.adaptive.customCostEvaluatorClass</code></td>
    <td>(none)</td>
    <td><p>The custom cost evaluator class to be used for adaptive execution. If not being set, Spark will use its own SimpleCostEvaluator by default.</p></td>
    <td>3.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.adaptive.enabled</code></td>
    <td>true</td>
    <td><p>When true, enable adaptive query execution, which re-optimizes the query plan in the middle of query execution, based on accurate runtime statistics.</p></td>
    <td>1.6.0</td>
</tr>

<tr>
    <td><code>spark.sql.adaptive.forceOptimizeSkewedJoin</code></td>
    <td>false</td>
    <td><p>When true, force enable OptimizeSkewedJoin even if it introduces extra shuffle.</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.adaptive.localShuffleReader.enabled</code></td>
    <td>true</td>
    <td><p>When true and 'spark.sql.adaptive.enabled' is true, Spark tries to use local shuffle reader to read the shuffle data when the shuffle partitioning is not needed, for example, after converting sort-merge join to broadcast-hash join.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.adaptive.maxShuffledHashJoinLocalMapThreshold</code></td>
    <td>0b</td>
    <td><p>Configures the maximum size in bytes per partition that can be allowed to build local hash map. If this value is not smaller than spark.sql.adaptive.advisoryPartitionSizeInBytes and all the partition size are not larger than this config, join selection prefer to use shuffled hash join instead of sort merge join regardless of the value of spark.sql.join.preferSortMergeJoin.</p></td>
    <td>3.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.adaptive.optimizeSkewsInRebalancePartitions.enabled</code></td>
    <td>true</td>
    <td><p>When true and 'spark.sql.adaptive.enabled' is true, Spark will optimize the skewed shuffle partitions in RebalancePartitions and split them to smaller ones according to the target size (specified by 'spark.sql.adaptive.advisoryPartitionSizeInBytes'), to avoid data skew.</p></td>
    <td>3.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.adaptive.optimizer.excludedRules</code></td>
    <td>(none)</td>
    <td><p>Configures a list of rules to be disabled in the adaptive optimizer, in which the rules are specified by their rule names and separated by comma. The optimizer will log the rules that have indeed been excluded.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.adaptive.rebalancePartitionsSmallPartitionFactor</code></td>
    <td>0.2</td>
    <td><p>A partition will be merged during splitting if its size is small than this factor multiply spark.sql.adaptive.advisoryPartitionSizeInBytes.</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.adaptive.skewJoin.enabled</code></td>
    <td>true</td>
    <td><p>When true and 'spark.sql.adaptive.enabled' is true, Spark dynamically handles skew in shuffled join (sort-merge and shuffled hash) by splitting (and replicating if needed) skewed partitions.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.adaptive.skewJoin.skewedPartitionFactor</code></td>
    <td>5.0</td>
    <td><p>A partition is considered as skewed if its size is larger than this factor multiplying the median partition size and also larger than 'spark.sql.adaptive.skewJoin.skewedPartitionThresholdInBytes'</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.adaptive.skewJoin.skewedPartitionThresholdInBytes</code></td>
    <td>256MB</td>
    <td><p>A partition is considered as skewed if its size in bytes is larger than this threshold and also larger than 'spark.sql.adaptive.skewJoin.skewedPartitionFactor' multiplying the median partition size. Ideally this config should be set larger than 'spark.sql.adaptive.advisoryPartitionSizeInBytes'.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.allowNamedFunctionArguments</code></td>
    <td>true</td>
    <td><p>If true, Spark will turn on support for named parameters for all functions that has it implemented.</p></td>
    <td>3.5.0</td>
</tr>

<tr>
    <td><code>spark.sql.ansi.doubleQuotedIdentifiers</code></td>
    <td>false</td>
    <td><p>When true and 'spark.sql.ansi.enabled' is true, Spark SQL reads literals enclosed in double quoted (") as identifiers. When false they are read as string literals.</p></td>
    <td>3.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.ansi.enabled</code></td>
    <td>false</td>
    <td><p>When true, Spark SQL uses an ANSI compliant dialect instead of being Hive compliant. For example, Spark will throw an exception at runtime instead of returning null results when the inputs to a SQL operator/function are invalid.For full details of this dialect, you can find them in the section "ANSI Compliance" of Spark's documentation. Some ANSI dialect features may be not from the ANSI SQL standard directly, but their behaviors align with ANSI SQL's style</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.ansi.enforceReservedKeywords</code></td>
    <td>false</td>
    <td><p>When true and 'spark.sql.ansi.enabled' is true, the Spark SQL parser enforces the ANSI reserved keywords and forbids SQL queries that use reserved keywords as alias names and/or identifiers for table, view, function, etc.</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.ansi.relationPrecedence</code></td>
    <td>false</td>
    <td><p>When true and 'spark.sql.ansi.enabled' is true, JOIN takes precedence over comma when combining relation. For example, <code>t1, t2 JOIN t3</code> should result to <code>t1 X (t2 X t3)</code>. If the config is false, the result is <code>(t1 X t2) X t3</code>.</p></td>
    <td>3.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.autoBroadcastJoinThreshold</code></td>
    <td>10MB</td>
    <td><p>Configures the maximum size in bytes for a table that will be broadcast to all worker nodes when performing a join.  By setting this value to -1 broadcasting can be disabled. Note that currently statistics are only supported for Hive Metastore tables where the command <code>ANALYZE TABLE &lt;tableName&gt; COMPUTE STATISTICS noscan</code> has been run, and file-based data source tables where the statistics are computed directly on the files of data.</p></td>
    <td>1.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.avro.compression.codec</code></td>
    <td>snappy</td>
    <td><p>Compression codec used in writing of AVRO files. Supported codecs: uncompressed, deflate, snappy, bzip2, xz and zstandard. Default codec is snappy.</p></td>
    <td>2.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.avro.deflate.level</code></td>
    <td>-1</td>
    <td><p>Compression level for the deflate codec used in writing of AVRO files. Valid value must be in the range of from 1 to 9 inclusive or -1. The default value is -1 which corresponds to 6 level in the current implementation.</p></td>
    <td>2.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.avro.filterPushdown.enabled</code></td>
    <td>true</td>
    <td><p>When true, enable filter pushdown to Avro datasource.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.broadcastTimeout</code></td>
    <td>300</td>
    <td><p>Timeout in seconds for the broadcast wait time in broadcast joins.</p></td>
    <td>1.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.bucketing.coalesceBucketsInJoin.enabled</code></td>
    <td>false</td>
    <td><p>When true, if two bucketed tables with the different number of buckets are joined, the side with a bigger number of buckets will be coalesced to have the same number of buckets as the other side. Bigger number of buckets is divisible by the smaller number of buckets. Bucket coalescing is applied to sort-merge joins and shuffled hash join. Note: Coalescing bucketed table can avoid unnecessary shuffling in join, but it also reduces parallelism and could possibly cause OOM for shuffled hash join.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.bucketing.coalesceBucketsInJoin.maxBucketRatio</code></td>
    <td>4</td>
    <td><p>The ratio of the number of two buckets being coalesced should be less than or equal to this value for bucket coalescing to be applied. This configuration only has an effect when 'spark.sql.bucketing.coalesceBucketsInJoin.enabled' is set to true.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.catalog.spark_catalog</code></td>
    <td>(none)</td>
    <td><p>A catalog implementation that will be used as the v2 interface to Spark's built-in v1 catalog: spark_catalog. This catalog shares its identifier namespace with the spark_catalog and must be consistent with it; for example, if a table can be loaded by the spark_catalog, this catalog must also return the table metadata. To delegate operations to the spark_catalog, implementations can extend 'CatalogExtension'.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.cbo.enabled</code></td>
    <td>false</td>
    <td><p>Enables CBO for estimation of plan statistics when set true.</p></td>
    <td>2.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.cbo.joinReorder.dp.star.filter</code></td>
    <td>false</td>
    <td><p>Applies star-join filter heuristics to cost based join enumeration.</p></td>
    <td>2.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.cbo.joinReorder.dp.threshold</code></td>
    <td>12</td>
    <td><p>The maximum number of joined nodes allowed in the dynamic programming algorithm.</p></td>
    <td>2.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.cbo.joinReorder.enabled</code></td>
    <td>false</td>
    <td><p>Enables join reorder in CBO.</p></td>
    <td>2.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.cbo.planStats.enabled</code></td>
    <td>false</td>
    <td><p>When true, the logical plan will fetch row counts and column statistics from catalog.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.cbo.starSchemaDetection</code></td>
    <td>false</td>
    <td><p>When true, it enables join reordering based on star schema detection. </p></td>
    <td>2.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.charAsVarchar</code></td>
    <td>false</td>
    <td><p>When true, Spark replaces CHAR type with VARCHAR type in CREATE/REPLACE/ALTER TABLE commands, so that newly created/updated tables will not have CHAR type columns/fields. Existing tables with CHAR type columns/fields are not affected by this config.</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.cli.print.header</code></td>
    <td>false</td>
    <td><p>When set to true, spark-sql CLI prints the names of the columns in query output.</p></td>
    <td>3.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.columnNameOfCorruptRecord</code></td>
    <td>_corrupt_record</td>
    <td><p>The name of internal column for storing raw/un-parsed JSON and CSV records that fail to parse.</p></td>
    <td>1.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.csv.filterPushdown.enabled</code></td>
    <td>true</td>
    <td><p>When true, enable filter pushdown to CSV datasource.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.datetime.java8API.enabled</code></td>
    <td>false</td>
    <td><p>If the configuration property is set to true, java.time.Instant and java.time.LocalDate classes of Java 8 API are used as external types for Catalyst's TimestampType and DateType. If it is set to false, java.sql.Timestamp and java.sql.Date are used for the same purpose.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.debug.maxToStringFields</code></td>
    <td>25</td>
    <td><p>Maximum number of fields of sequence-like entries can be converted to strings in debug output. Any elements beyond the limit will be dropped and replaced by a "... N more fields" placeholder.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.defaultCatalog</code></td>
    <td>spark_catalog</td>
    <td><p>Name of the default catalog. This will be the current catalog if users have not explicitly set the current catalog yet.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.error.messageFormat</code></td>
    <td>PRETTY</td>
    <td><p>When PRETTY, the error message consists of textual representation of error class, message and query context. The MINIMAL and STANDARD formats are pretty JSON formats where STANDARD includes an additional JSON field <code>message</code>. This configuration property influences on error messages of Thrift Server and SQL CLI while running queries.</p></td>
    <td>3.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.execution.arrow.enabled</code></td>
    <td>false</td>
    <td><p>(Deprecated since Spark 3.0, please set 'spark.sql.execution.arrow.pyspark.enabled'.)</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.execution.arrow.fallback.enabled</code></td>
    <td>true</td>
    <td><p>(Deprecated since Spark 3.0, please set 'spark.sql.execution.arrow.pyspark.fallback.enabled'.)</p></td>
    <td>2.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.execution.arrow.localRelationThreshold</code></td>
    <td>48MB</td>
    <td><p>When converting Arrow batches to Spark DataFrame, local collections are used in the driver side if the byte size of Arrow batches is smaller than this threshold. Otherwise, the Arrow batches are sent and deserialized to Spark internal rows in the executors.</p></td>
    <td>3.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.execution.arrow.maxRecordsPerBatch</code></td>
    <td>10000</td>
    <td><p>When using Apache Arrow, limit the maximum number of records that can be written to a single ArrowRecordBatch in memory. If set to zero or negative there is no limit.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.execution.arrow.pyspark.enabled</code></td>
    <td>(value of <code>spark.sql.execution.arrow.enabled</code>)</td>
    <td><p>When true, make use of Apache Arrow for columnar data transfers in PySpark. This optimization applies to: 1. pyspark.sql.DataFrame.toPandas. 2. pyspark.sql.SparkSession.createDataFrame when its input is a Pandas DataFrame or a NumPy ndarray. The following data type is unsupported: ArrayType of TimestampType.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.execution.arrow.pyspark.fallback.enabled</code></td>
    <td>(value of <code>spark.sql.execution.arrow.fallback.enabled</code>)</td>
    <td><p>When true, optimizations enabled by 'spark.sql.execution.arrow.pyspark.enabled' will fallback automatically to non-optimized implementations if an error occurs.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.execution.arrow.pyspark.selfDestruct.enabled</code></td>
    <td>false</td>
    <td><p>(Experimental) When true, make use of Apache Arrow's self-destruct and split-blocks options for columnar data transfers in PySpark, when converting from Arrow to Pandas. This reduces memory usage at the cost of some CPU time. This optimization applies to: pyspark.sql.DataFrame.toPandas when 'spark.sql.execution.arrow.pyspark.enabled' is set.</p></td>
    <td>3.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.execution.arrow.sparkr.enabled</code></td>
    <td>false</td>
    <td><p>When true, make use of Apache Arrow for columnar data transfers in SparkR. This optimization applies to: 1. createDataFrame when its input is an R DataFrame 2. collect 3. dapply 4. gapply The following data types are unsupported: FloatType, BinaryType, ArrayType, StructType and MapType.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.execution.pandas.structHandlingMode</code></td>
    <td>legacy</td>
    <td><p>The conversion mode of struct type when creating pandas DataFrame. When "legacy",1. when Arrow optimization is disabled, convert to Row object, 2. when Arrow optimization is enabled, convert to dict or raise an Exception if there are duplicated nested field names. When "row", convert to Row object regardless of Arrow optimization. When "dict", convert to dict and use suffixed key names, e.g., a_0, a_1, if there are duplicated nested field names, regardless of Arrow optimization.</p></td>
    <td>3.5.0</td>
</tr>

<tr>
    <td><code>spark.sql.execution.pandas.udf.buffer.size</code></td>
    <td>(value of <code>spark.buffer.size</code>)</td>
    <td><p>Same as <code>spark.buffer.size</code> but only applies to Pandas UDF executions. If it is not set, the fallback is <code>spark.buffer.size</code>. Note that Pandas execution requires more than 4 bytes. Lowering this value could make small Pandas UDF batch iterated and pipelined; however, it might degrade performance. See SPARK-27870.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.execution.pyspark.udf.simplifiedTraceback.enabled</code></td>
    <td>true</td>
    <td><p>When true, the traceback from Python UDFs is simplified. It hides the Python worker, (de)serialization, etc from PySpark in tracebacks, and only shows the exception messages from UDFs. Note that this works only with CPython 3.7+.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.execution.pythonUDF.arrow.enabled</code></td>
    <td>false</td>
    <td><p>Enable Arrow optimization in regular Python UDFs. This optimization can only be enabled when the given function takes at least one argument.</p></td>
    <td>3.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.execution.pythonUDTF.arrow.enabled</code></td>
    <td>false</td>
    <td><p>Enable Arrow optimization for Python UDTFs.</p></td>
    <td>3.5.0</td>
</tr>

<tr>
    <td><code>spark.sql.execution.topKSortFallbackThreshold</code></td>
    <td>2147483632</td>
    <td><p>In SQL queries with a SORT followed by a LIMIT like 'SELECT x FROM t ORDER BY y LIMIT m', if m is under this threshold, do a top-K sort in memory, otherwise do a global sort which spills to disk if necessary.</p></td>
    <td>2.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.files.ignoreCorruptFiles</code></td>
    <td>false</td>
    <td><p>Whether to ignore corrupt files. If true, the Spark jobs will continue to run when encountering corrupted files and the contents that have been read will still be returned. This configuration is effective only when using file-based sources such as Parquet, JSON and ORC.</p></td>
    <td>2.1.1</td>
</tr>

<tr>
    <td><code>spark.sql.files.ignoreMissingFiles</code></td>
    <td>false</td>
    <td><p>Whether to ignore missing files. If true, the Spark jobs will continue to run when encountering missing files and the contents that have been read will still be returned. This configuration is effective only when using file-based sources such as Parquet, JSON and ORC.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.files.maxPartitionBytes</code></td>
    <td>128MB</td>
    <td><p>The maximum number of bytes to pack into a single partition when reading files. This configuration is effective only when using file-based sources such as Parquet, JSON and ORC.</p></td>
    <td>2.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.files.maxPartitionNum</code></td>
    <td>(none)</td>
    <td><p>The suggested (not guaranteed) maximum number of split file partitions. If it is set, Spark will rescale each partition to make the number of partitions is close to this value if the initial number of partitions exceeds this value. This configuration is effective only when using file-based sources such as Parquet, JSON and ORC.</p></td>
    <td>3.5.0</td>
</tr>

<tr>
    <td><code>spark.sql.files.maxRecordsPerFile</code></td>
    <td>0</td>
    <td><p>Maximum number of records to write out to a single file. If this value is zero or negative, there is no limit.</p></td>
    <td>2.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.files.minPartitionNum</code></td>
    <td>(none)</td>
    <td><p>The suggested (not guaranteed) minimum number of split file partitions. If not set, the default value is <code>spark.sql.leafNodeDefaultParallelism</code>. This configuration is effective only when using file-based sources such as Parquet, JSON and ORC.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.function.concatBinaryAsString</code></td>
    <td>false</td>
    <td><p>When this option is set to false and all inputs are binary, <code>functions.concat</code> returns an output as binary. Otherwise, it returns as a string.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.function.eltOutputAsString</code></td>
    <td>false</td>
    <td><p>When this option is set to false and all inputs are binary, <code>elt</code> returns an output as binary. Otherwise, it returns as a string.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.groupByAliases</code></td>
    <td>true</td>
    <td><p>When true, aliases in a select list can be used in group by clauses. When false, an analysis exception is thrown in the case.</p></td>
    <td>2.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.groupByOrdinal</code></td>
    <td>true</td>
    <td><p>When true, the ordinal numbers in group by clauses are treated as the position in the select list. When false, the ordinal numbers are ignored.</p></td>
    <td>2.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.hive.convertInsertingPartitionedTable</code></td>
    <td>true</td>
    <td><p>When set to true, and <code>spark.sql.hive.convertMetastoreParquet</code> or <code>spark.sql.hive.convertMetastoreOrc</code> is true, the built-in ORC/Parquet writer is usedto process inserting into partitioned ORC/Parquet tables created by using the HiveSQL syntax.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.hive.convertMetastoreCtas</code></td>
    <td>true</td>
    <td><p>When set to true,  Spark will try to use built-in data source writer instead of Hive serde in CTAS. This flag is effective only if <code>spark.sql.hive.convertMetastoreParquet</code> or <code>spark.sql.hive.convertMetastoreOrc</code> is enabled respectively for Parquet and ORC formats</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.hive.convertMetastoreInsertDir</code></td>
    <td>true</td>
    <td><p>When set to true,  Spark will try to use built-in data source writer instead of Hive serde in INSERT OVERWRITE DIRECTORY. This flag is effective only if <code>spark.sql.hive.convertMetastoreParquet</code> or <code>spark.sql.hive.convertMetastoreOrc</code> is enabled respectively for Parquet and ORC formats</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.hive.convertMetastoreOrc</code></td>
    <td>true</td>
    <td><p>When set to true, the built-in ORC reader and writer are used to process ORC tables created by using the HiveQL syntax, instead of Hive serde.</p></td>
    <td>2.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.hive.convertMetastoreParquet</code></td>
    <td>true</td>
    <td><p>When set to true, the built-in Parquet reader and writer are used to process parquet tables created by using the HiveQL syntax, instead of Hive serde.</p></td>
    <td>1.1.1</td>
</tr>

<tr>
    <td><code>spark.sql.hive.convertMetastoreParquet.mergeSchema</code></td>
    <td>false</td>
    <td><p>When true, also tries to merge possibly different but compatible Parquet schemas in different Parquet data files. This configuration is only effective when "spark.sql.hive.convertMetastoreParquet" is true.</p></td>
    <td>1.3.1</td>
</tr>

<tr>
    <td><code>spark.sql.hive.dropPartitionByName.enabled</code></td>
    <td>false</td>
    <td><p>When true, Spark will get partition name rather than partition object to drop partition, which can improve the performance of drop partition.</p></td>
    <td>3.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.hive.filesourcePartitionFileCacheSize</code></td>
    <td>262144000</td>
    <td><p>When nonzero, enable caching of partition file metadata in memory. All tables share a cache that can use up to specified num bytes for file metadata. This conf only has an effect when hive filesource partition management is enabled.</p></td>
    <td>2.1.1</td>
</tr>

<tr>
    <td><code>spark.sql.hive.manageFilesourcePartitions</code></td>
    <td>true</td>
    <td><p>When true, enable metastore partition management for file source tables as well. This includes both datasource and converted Hive tables. When partition management is enabled, datasource tables store partition in the Hive metastore, and use the metastore to prune partitions during query planning when spark.sql.hive.metastorePartitionPruning is set to true.</p></td>
    <td>2.1.1</td>
</tr>

<tr>
    <td><code>spark.sql.hive.metastorePartitionPruning</code></td>
    <td>true</td>
    <td><p>When true, some predicates will be pushed down into the Hive metastore so that unmatching partitions can be eliminated earlier.</p></td>
    <td>1.5.0</td>
</tr>

<tr>
    <td><code>spark.sql.hive.metastorePartitionPruningFallbackOnException</code></td>
    <td>false</td>
    <td><p>Whether to fallback to get all partitions from Hive metastore and perform partition pruning on Spark client side, when encountering MetaException from the metastore. Note that Spark query performance may degrade if this is enabled and there are many partitions to be listed. If this is disabled, Spark will fail the query instead.</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.hive.metastorePartitionPruningFastFallback</code></td>
    <td>false</td>
    <td><p>When this config is enabled, if the predicates are not supported by Hive or Spark does fallback due to encountering MetaException from the metastore, Spark will instead prune partitions by getting the partition names first and then evaluating the filter expressions on the client side. Note that the predicates with TimeZoneAwareExpression is not supported.</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.hive.thriftServer.async</code></td>
    <td>true</td>
    <td><p>When set to true, Hive Thrift server executes SQL queries in an asynchronous way.</p></td>
    <td>1.5.0</td>
</tr>

<tr>
    <td><code>spark.sql.hive.verifyPartitionPath</code></td>
    <td>false</td>
    <td><p>When true, check all the partition paths under the table's root directory when reading data stored in HDFS. This configuration will be deprecated in the future releases and replaced by spark.files.ignoreMissingFiles.</p></td>
    <td>1.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.inMemoryColumnarStorage.batchSize</code></td>
    <td>10000</td>
    <td><p>Controls the size of batches for columnar caching.  Larger batch sizes can improve memory utilization and compression, but risk OOMs when caching data.</p></td>
    <td>1.1.1</td>
</tr>

<tr>
    <td><code>spark.sql.inMemoryColumnarStorage.compressed</code></td>
    <td>true</td>
    <td><p>When set to true Spark SQL will automatically select a compression codec for each column based on statistics of the data.</p></td>
    <td>1.0.1</td>
</tr>

<tr>
    <td><code>spark.sql.inMemoryColumnarStorage.enableVectorizedReader</code></td>
    <td>true</td>
    <td><p>Enables vectorized reader for columnar caching.</p></td>
    <td>2.3.1</td>
</tr>

<tr>
    <td><code>spark.sql.json.filterPushdown.enabled</code></td>
    <td>true</td>
    <td><p>When true, enable filter pushdown to JSON datasource.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.jsonGenerator.ignoreNullFields</code></td>
    <td>true</td>
    <td><p>Whether to ignore null fields when generating JSON objects in JSON data source and JSON functions such as to_json. If false, it generates null for null fields in JSON objects.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.leafNodeDefaultParallelism</code></td>
    <td>(none)</td>
    <td><p>The default parallelism of Spark SQL leaf nodes that produce data, such as the file scan node, the local data scan node, the range node, etc. The default value of this config is 'SparkContext#defaultParallelism'.</p></td>
    <td>3.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.mapKeyDedupPolicy</code></td>
    <td>EXCEPTION</td>
    <td><p>The policy to deduplicate map keys in builtin function: CreateMap, MapFromArrays, MapFromEntries, StringToMap, MapConcat and TransformKeys. When EXCEPTION, the query fails if duplicated map keys are detected. When LAST_WIN, the map key that is inserted at last takes precedence.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.maven.additionalRemoteRepositories</code></td>
    <td>https://maven-central.storage-download.googleapis.com/maven2/</td>
    <td><p>A comma-delimited string config of the optional additional remote Maven mirror repositories. This is only used for downloading Hive jars in IsolatedClientLoader if the default Maven Central repo is unreachable.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.maxMetadataStringLength</code></td>
    <td>100</td>
    <td><p>Maximum number of characters to output for a metadata string. e.g. file location in <code>DataSourceScanExec</code>, every value will be abbreviated if exceed length.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.maxPlanStringLength</code></td>
    <td>2147483632</td>
    <td><p>Maximum number of characters to output for a plan string.  If the plan is longer, further output will be truncated.  The default setting always generates a full plan.  Set this to a lower value such as 8k if plan strings are taking up too much memory or are causing OutOfMemory errors in the driver or UI processes.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.maxSinglePartitionBytes</code></td>
    <td>9223372036854775807b</td>
    <td><p>The maximum number of bytes allowed for a single partition. Otherwise, The planner will introduce shuffle to improve parallelism.</p></td>
    <td>3.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.optimizer.collapseProjectAlwaysInline</code></td>
    <td>false</td>
    <td><p>Whether to always collapse two adjacent projections and inline expressions even if it causes extra duplication.</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.optimizer.dynamicPartitionPruning.enabled</code></td>
    <td>true</td>
    <td><p>When true, we will generate predicate for partition column when it's used as join key</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.optimizer.enableCsvExpressionOptimization</code></td>
    <td>true</td>
    <td><p>Whether to optimize CSV expressions in SQL optimizer. It includes pruning unnecessary columns from from_csv.</p></td>
    <td>3.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.optimizer.enableJsonExpressionOptimization</code></td>
    <td>true</td>
    <td><p>Whether to optimize JSON expressions in SQL optimizer. It includes pruning unnecessary columns from from_json, simplifying from_json + to_json, to_json + named_struct(from_json.col1, from_json.col2, ....).</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.optimizer.excludedRules</code></td>
    <td>(none)</td>
    <td><p>Configures a list of rules to be disabled in the optimizer, in which the rules are specified by their rule names and separated by comma. It is not guaranteed that all the rules in this configuration will eventually be excluded, as some rules are necessary for correctness. The optimizer will log the rules that have indeed been excluded.</p></td>
    <td>2.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.optimizer.runtime.bloomFilter.applicationSideScanSizeThreshold</code></td>
    <td>10GB</td>
    <td><p>Byte size threshold of the Bloom filter application side plan's aggregated scan size. Aggregated scan byte size of the Bloom filter application side needs to be over this value to inject a bloom filter.</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.optimizer.runtime.bloomFilter.creationSideThreshold</code></td>
    <td>10MB</td>
    <td><p>Size threshold of the bloom filter creation side plan. Estimated size needs to be under this value to try to inject bloom filter.</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.optimizer.runtime.bloomFilter.enabled</code></td>
    <td>true</td>
    <td><p>When true and if one side of a shuffle join has a selective predicate, we attempt to insert a bloom filter in the other side to reduce the amount of shuffle data.</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.optimizer.runtime.bloomFilter.expectedNumItems</code></td>
    <td>1000000</td>
    <td><p>The default number of expected items for the runtime bloomfilter</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.optimizer.runtime.bloomFilter.maxNumBits</code></td>
    <td>67108864</td>
    <td><p>The max number of bits to use for the runtime bloom filter</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.optimizer.runtime.bloomFilter.maxNumItems</code></td>
    <td>4000000</td>
    <td><p>The max allowed number of expected items for the runtime bloom filter</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.optimizer.runtime.bloomFilter.numBits</code></td>
    <td>8388608</td>
    <td><p>The default number of bits to use for the runtime bloom filter</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.optimizer.runtime.rowLevelOperationGroupFilter.enabled</code></td>
    <td>true</td>
    <td><p>Enables runtime group filtering for group-based row-level operations. Data sources that replace groups of data (e.g. files, partitions) may prune entire groups using provided data source filters when planning a row-level operation scan. However, such filtering is limited as not all expressions can be converted into data source filters and some expressions can only be evaluated by Spark (e.g. subqueries). Since rewriting groups is expensive, Spark can execute a query at runtime to find what records match the condition of the row-level operation. The information about matching records will be passed back to the row-level operation scan, allowing data sources to discard groups that don't have to be rewritten.</p></td>
    <td>3.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.optimizer.runtimeFilter.number.threshold</code></td>
    <td>10</td>
    <td><p>The total number of injected runtime filters (non-DPP) for a single query. This is to prevent driver OOMs with too many Bloom filters.</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.optimizer.runtimeFilter.semiJoinReduction.enabled</code></td>
    <td>false</td>
    <td><p>When true and if one side of a shuffle join has a selective predicate, we attempt to insert a semi join in the other side to reduce the amount of shuffle data.</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.orc.aggregatePushdown</code></td>
    <td>false</td>
    <td><p>If true, aggregates will be pushed down to ORC for optimization. Support MIN, MAX and COUNT as aggregate expression. For MIN/MAX, support boolean, integer, float and date type. For COUNT, support all data types. If statistics is missing from any ORC file footer, exception would be thrown.</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.orc.columnarReaderBatchSize</code></td>
    <td>4096</td>
    <td><p>The number of rows to include in a orc vectorized reader batch. The number should be carefully chosen to minimize overhead and avoid OOMs in reading data.</p></td>
    <td>2.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.orc.columnarWriterBatchSize</code></td>
    <td>1024</td>
    <td><p>The number of rows to include in a orc vectorized writer batch. The number should be carefully chosen to minimize overhead and avoid OOMs in writing data.</p></td>
    <td>3.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.orc.compression.codec</code></td>
    <td>snappy</td>
    <td><p>Sets the compression codec used when writing ORC files. If either <code>compression</code> or <code>orc.compress</code> is specified in the table-specific options/properties, the precedence would be <code>compression</code>, <code>orc.compress</code>, <code>spark.sql.orc.compression.codec</code>.Acceptable values include: none, uncompressed, snappy, zlib, lzo, zstd, lz4.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.orc.enableNestedColumnVectorizedReader</code></td>
    <td>true</td>
    <td><p>Enables vectorized orc decoding for nested column.</p></td>
    <td>3.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.orc.enableVectorizedReader</code></td>
    <td>true</td>
    <td><p>Enables vectorized orc decoding.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.orc.filterPushdown</code></td>
    <td>true</td>
    <td><p>When true, enable filter pushdown for ORC files.</p></td>
    <td>1.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.orc.mergeSchema</code></td>
    <td>false</td>
    <td><p>When true, the Orc data source merges schemas collected from all data files, otherwise the schema is picked from a random data file.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.orderByOrdinal</code></td>
    <td>true</td>
    <td><p>When true, the ordinal numbers are treated as the position in the select list. When false, the ordinal numbers in order/sort by clause are ignored.</p></td>
    <td>2.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.aggregatePushdown</code></td>
    <td>false</td>
    <td><p>If true, aggregates will be pushed down to Parquet for optimization. Support MIN, MAX and COUNT as aggregate expression. For MIN/MAX, support boolean, integer, float and date type. For COUNT, support all data types. If statistics is missing from any Parquet file footer, exception would be thrown.</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.binaryAsString</code></td>
    <td>false</td>
    <td><p>Some other Parquet-producing systems, in particular Impala and older versions of Spark SQL, do not differentiate between binary data and strings when writing out the Parquet schema. This flag tells Spark SQL to interpret binary data as a string to provide compatibility with these systems.</p></td>
    <td>1.1.1</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.columnarReaderBatchSize</code></td>
    <td>4096</td>
    <td><p>The number of rows to include in a parquet vectorized reader batch. The number should be carefully chosen to minimize overhead and avoid OOMs in reading data.</p></td>
    <td>2.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.compression.codec</code></td>
    <td>snappy</td>
    <td><p>Sets the compression codec used when writing Parquet files. If either <code>compression</code> or <code>parquet.compression</code> is specified in the table-specific options/properties, the precedence would be <code>compression</code>, <code>parquet.compression</code>, <code>spark.sql.parquet.compression.codec</code>. Acceptable values include: none, uncompressed, snappy, gzip, lzo, brotli, lz4, lz4raw, zstd.</p></td>
    <td>1.1.1</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.enableNestedColumnVectorizedReader</code></td>
    <td>true</td>
    <td><p>Enables vectorized Parquet decoding for nested columns (e.g., struct, list, map). Requires spark.sql.parquet.enableVectorizedReader to be enabled.</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.enableVectorizedReader</code></td>
    <td>true</td>
    <td><p>Enables vectorized parquet decoding.</p></td>
    <td>2.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.fieldId.read.enabled</code></td>
    <td>false</td>
    <td><p>Field ID is a native field of the Parquet schema spec. When enabled, Parquet readers will use field IDs (if present) in the requested Spark schema to look up Parquet fields instead of using column names</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.fieldId.read.ignoreMissing</code></td>
    <td>false</td>
    <td><p>When the Parquet file doesn't have any field IDs but the Spark read schema is using field IDs to read, we will silently return nulls when this flag is enabled, or error otherwise.</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.fieldId.write.enabled</code></td>
    <td>true</td>
    <td><p>Field ID is a native field of the Parquet schema spec. When enabled, Parquet writers will populate the field Id metadata (if present) in the Spark schema to the Parquet schema.</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.filterPushdown</code></td>
    <td>true</td>
    <td><p>Enables Parquet filter push-down optimization when set to true.</p></td>
    <td>1.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.inferTimestampNTZ.enabled</code></td>
    <td>true</td>
    <td><p>When enabled, Parquet timestamp columns with annotation isAdjustedToUTC = false are inferred as TIMESTAMP_NTZ type during schema inference. Otherwise, all the Parquet timestamp columns are inferred as TIMESTAMP_LTZ types. Note that Spark writes the output schema into Parquet's footer metadata on file writing and leverages it on file reading. Thus this configuration only affects the schema inference on Parquet files which are not written by Spark.</p></td>
    <td>3.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.int96AsTimestamp</code></td>
    <td>true</td>
    <td><p>Some Parquet-producing systems, in particular Impala, store Timestamp into INT96. Spark would also store Timestamp as INT96 because we need to avoid precision lost of the nanoseconds field. This flag tells Spark SQL to interpret INT96 data as a timestamp to provide compatibility with these systems.</p></td>
    <td>1.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.int96TimestampConversion</code></td>
    <td>false</td>
    <td><p>This controls whether timestamp adjustments should be applied to INT96 data when converting to timestamps, for data written by Impala.  This is necessary because Impala stores INT96 data with a different timezone offset than Hive &amp; Spark.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.mergeSchema</code></td>
    <td>false</td>
    <td><p>When true, the Parquet data source merges schemas collected from all data files, otherwise the schema is picked from the summary file or a random data file if no summary file is available.</p></td>
    <td>1.5.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.outputTimestampType</code></td>
    <td>INT96</td>
    <td><p>Sets which Parquet timestamp type to use when Spark writes data to Parquet files. INT96 is a non-standard but commonly used timestamp type in Parquet. TIMESTAMP_MICROS is a standard timestamp type in Parquet, which stores number of microseconds from the Unix epoch. TIMESTAMP_MILLIS is also standard, but with millisecond precision, which means Spark has to truncate the microsecond portion of its timestamp value.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.recordLevelFilter.enabled</code></td>
    <td>false</td>
    <td><p>If true, enables Parquet's native record-level filtering using the pushed down filters. This configuration only has an effect when 'spark.sql.parquet.filterPushdown' is enabled and the vectorized reader is not used. You can ensure the vectorized reader is not used by setting 'spark.sql.parquet.enableVectorizedReader' to false.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.respectSummaryFiles</code></td>
    <td>false</td>
    <td><p>When true, we make assumption that all part-files of Parquet are consistent with summary files and we will ignore them when merging schema. Otherwise, if this is false, which is the default, we will merge all part-files. This should be considered as expert-only option, and shouldn't be enabled before knowing what it means exactly.</p></td>
    <td>1.5.0</td>
</tr>

<tr>
    <td><code>spark.sql.parquet.writeLegacyFormat</code></td>
    <td>false</td>
    <td><p>If true, data will be written in a way of Spark 1.4 and earlier. For example, decimal values will be written in Apache Parquet's fixed-length byte array format, which other systems such as Apache Hive and Apache Impala use. If false, the newer format in Parquet will be used. For example, decimals will be written in int-based format. If Parquet output is intended for use with systems that do not support this newer format, set to true.</p></td>
    <td>1.6.0</td>
</tr>

<tr>
    <td><code>spark.sql.parser.quotedRegexColumnNames</code></td>
    <td>false</td>
    <td><p>When true, quoted Identifiers (using backticks) in SELECT statement are interpreted as regular expressions.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.pivotMaxValues</code></td>
    <td>10000</td>
    <td><p>When doing a pivot without specifying values for the pivot column this is the maximum number of (distinct) values that will be collected without error.</p></td>
    <td>1.6.0</td>
</tr>

<tr>
    <td><code>spark.sql.pyspark.inferNestedDictAsStruct.enabled</code></td>
    <td>false</td>
    <td><p>PySpark's SparkSession.createDataFrame infers the nested dict as a map by default. When it set to true, it infers the nested dict as a struct.</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.pyspark.jvmStacktrace.enabled</code></td>
    <td>false</td>
    <td><p>When true, it shows the JVM stacktrace in the user-facing PySpark exception together with Python stacktrace. By default, it is disabled to hide JVM stacktrace and shows a Python-friendly exception only. Note that this is independent from log level settings.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.pyspark.legacy.inferArrayTypeFromFirstElement.enabled</code></td>
    <td>false</td>
    <td><p>PySpark's SparkSession.createDataFrame infers the element type of an array from all values in the array by default. If this config is set to true, it restores the legacy behavior of only inferring the type from the first array element.</p></td>
    <td>3.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.readSideCharPadding</code></td>
    <td>true</td>
    <td><p>When true, Spark applies string padding when reading CHAR type columns/fields, in addition to the write-side padding. This config is true by default to better enforce CHAR type semantic in cases such as external tables.</p></td>
    <td>3.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.redaction.options.regex</code></td>
    <td>(?i)url</td>
    <td><p>Regex to decide which keys in a Spark SQL command's options map contain sensitive information. The values of options whose names that match this regex will be redacted in the explain output. This redaction is applied on top of the global redaction configuration defined by spark.redaction.regex.</p></td>
    <td>2.2.2</td>
</tr>

<tr>
    <td><code>spark.sql.redaction.string.regex</code></td>
    <td>(value of <code>spark.redaction.string.regex</code>)</td>
    <td><p>Regex to decide which parts of strings produced by Spark contain sensitive information. When this regex matches a string part, that string part is replaced by a dummy value. This is currently used to redact the output of SQL explain commands. When this conf is not set, the value from <code>spark.redaction.string.regex</code> is used.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.repl.eagerEval.enabled</code></td>
    <td>false</td>
    <td><p>Enables eager evaluation or not. When true, the top K rows of Dataset will be displayed if and only if the REPL supports the eager evaluation. Currently, the eager evaluation is supported in PySpark and SparkR. In PySpark, for the notebooks like Jupyter, the HTML table (generated by <em>repr_html</em>) will be returned. For plain Python REPL, the returned outputs are formatted like dataframe.show(). In SparkR, the returned outputs are showed similar to R data.frame would.</p></td>
    <td>2.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.repl.eagerEval.maxNumRows</code></td>
    <td>20</td>
    <td><p>The max number of rows that are returned by eager evaluation. This only takes effect when spark.sql.repl.eagerEval.enabled is set to true. The valid range of this config is from 0 to (Int.MaxValue - 1), so the invalid config like negative and greater than (Int.MaxValue - 1) will be normalized to 0 and (Int.MaxValue - 1).</p></td>
    <td>2.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.repl.eagerEval.truncate</code></td>
    <td>20</td>
    <td><p>The max number of characters for each cell that is returned by eager evaluation. This only takes effect when spark.sql.repl.eagerEval.enabled is set to true.</p></td>
    <td>2.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.session.localRelationCacheThreshold</code></td>
    <td>67108864</td>
    <td><p>The threshold for the size in bytes of local relations to be cached at the driver side after serialization.</p></td>
    <td>3.5.0</td>
</tr>

<tr>
    <td><code>spark.sql.session.timeZone</code></td>
    <td>(value of local timezone)</td>
    <td><p>The ID of session local timezone in the format of either region-based zone IDs or zone offsets. Region IDs must have the form 'area/city', such as 'America/Los_Angeles'. Zone offsets must be in the format '(+|-)HH', '(+|-)HH:mm' or '(+|-)HH:mm:ss', e.g '-08', '+01:00' or '-13:33:33'. Also 'UTC' and 'Z' are supported as aliases of '+00:00'. Other short names are not recommended to use because they can be ambiguous.</p></td>
    <td>2.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.shuffle.partitions</code></td>
    <td>200</td>
    <td><p>The default number of partitions to use when shuffling data for joins or aggregations. Note: For structured streaming, this configuration cannot be changed between query restarts from the same checkpoint location.</p></td>
    <td>1.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.shuffledHashJoinFactor</code></td>
    <td>3</td>
    <td><p>The shuffle hash join can be selected if the data size of small side multiplied by this factor is still smaller than the large side.</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.sources.bucketing.autoBucketedScan.enabled</code></td>
    <td>true</td>
    <td><p>When true, decide whether to do bucketed scan on input tables based on query plan automatically. Do not use bucketed scan if 1. query does not have operators to utilize bucketing (e.g. join, group-by, etc), or 2. there's an exchange operator between these operators and table scan. Note when 'spark.sql.sources.bucketing.enabled' is set to false, this configuration does not take any effect.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.sources.bucketing.enabled</code></td>
    <td>true</td>
    <td><p>When false, we will treat bucketed table as normal table</p></td>
    <td>2.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.sources.bucketing.maxBuckets</code></td>
    <td>100000</td>
    <td><p>The maximum number of buckets allowed.</p></td>
    <td>2.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.sources.default</code></td>
    <td>parquet</td>
    <td><p>The default data source to use in input/output.</p></td>
    <td>1.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.sources.parallelPartitionDiscovery.threshold</code></td>
    <td>32</td>
    <td><p>The maximum number of paths allowed for listing files at driver side. If the number of detected paths exceeds this value during partition discovery, it tries to list the files with another Spark distributed job. This configuration is effective only when using file-based sources such as Parquet, JSON and ORC.</p></td>
    <td>1.5.0</td>
</tr>

<tr>
    <td><code>spark.sql.sources.partitionColumnTypeInference.enabled</code></td>
    <td>true</td>
    <td><p>When true, automatically infer the data types for partitioned columns.</p></td>
    <td>1.5.0</td>
</tr>

<tr>
    <td><code>spark.sql.sources.partitionOverwriteMode</code></td>
    <td>STATIC</td>
    <td><p>When INSERT OVERWRITE a partitioned data source table, we currently support 2 modes: static and dynamic. In static mode, Spark deletes all the partitions that match the partition specification(e.g. PARTITION(a=1,b)) in the INSERT statement, before overwriting. In dynamic mode, Spark doesn't delete partitions ahead, and only overwrite those partitions that have data written into it at runtime. By default we use static mode to keep the same behavior of Spark prior to 2.3. Note that this config doesn't affect Hive serde tables, as they are always overwritten with dynamic mode. This can also be set as an output option for a data source using key partitionOverwriteMode (which takes precedence over this setting), e.g. dataframe.write.option("partitionOverwriteMode", "dynamic").save(path).</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.sources.v2.bucketing.enabled</code></td>
    <td>false</td>
    <td><p>Similar to spark.sql.sources.bucketing.enabled, this config is used to enable bucketing for V2 data sources. When turned on, Spark will recognize the specific distribution reported by a V2 data source through SupportsReportPartitioning, and will try to avoid shuffle if necessary.</p></td>
    <td>3.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.sources.v2.bucketing.partiallyClusteredDistribution.enabled</code></td>
    <td>false</td>
    <td><p>During a storage-partitioned join, whether to allow input partitions to be partially clustered, when both sides of the join are of KeyGroupedPartitioning. At planning time, Spark will pick the side with less data size based on table statistics, group and replicate them to match the other side. This is an optimization on skew join and can help to reduce data skewness when certain partitions are assigned large amount of data. This config requires both spark.sql.sources.v2.bucketing.enabled and spark.sql.sources.v2.bucketing.pushPartValues.enabled to be enabled</p></td>
    <td>3.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.sources.v2.bucketing.pushPartValues.enabled</code></td>
    <td>false</td>
    <td><p>Whether to pushdown common partition values when spark.sql.sources.v2.bucketing.enabled is enabled. When turned on, if both sides of a join are of KeyGroupedPartitioning and if they share compatible partition keys, even if they don't have the exact same partition values, Spark will calculate a superset of partition values and pushdown that info to scan nodes, which will use empty partitions for the missing partition values on either side. This could help to eliminate unnecessary shuffles</p></td>
    <td>3.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.statistics.fallBackToHdfs</code></td>
    <td>false</td>
    <td><p>When true, it will fall back to HDFS if the table statistics are not available from table metadata. This is useful in determining if a table is small enough to use broadcast joins. This flag is effective only for non-partitioned Hive tables. For non-partitioned data source tables, it will be automatically recalculated if table statistics are not available. For partitioned data source and partitioned Hive tables, It is 'spark.sql.defaultSizeInBytes' if table statistics are not available.</p></td>
    <td>2.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.statistics.histogram.enabled</code></td>
    <td>false</td>
    <td><p>Generates histograms when computing column statistics if enabled. Histograms can provide better estimation accuracy. Currently, Spark only supports equi-height histogram. Note that collecting histograms takes extra cost. For example, collecting column statistics usually takes only one table scan, but generating equi-height histogram will cause an extra table scan.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.statistics.size.autoUpdate.enabled</code></td>
    <td>false</td>
    <td><p>Enables automatic update for table size once table's data is changed. Note that if the total number of files of the table is very large, this can be expensive and slow down data change commands.</p></td>
    <td>2.3.0</td>
</tr>

<tr>
    <td><code>spark.sql.storeAssignmentPolicy</code></td>
    <td>ANSI</td>
    <td><p>When inserting a value into a column with different data type, Spark will perform type coercion. Currently, we support 3 policies for the type coercion rules: ANSI, legacy and strict. With ANSI policy, Spark performs the type coercion as per ANSI SQL. In practice, the behavior is mostly the same as PostgreSQL. It disallows certain unreasonable type conversions such as converting <code>string</code> to <code>int</code> or <code>double</code> to <code>boolean</code>. With legacy policy, Spark allows the type coercion as long as it is a valid <code>Cast</code>, which is very loose. e.g. converting <code>string</code> to <code>int</code> or <code>double</code> to <code>boolean</code> is allowed. It is also the only behavior in Spark 2.x and it is compatible with Hive. With strict policy, Spark doesn't allow any possible precision loss or data truncation in type coercion, e.g. converting <code>double</code> to <code>int</code> or <code>decimal</code> to <code>double</code> is not allowed.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.checkpointLocation</code></td>
    <td>(none)</td>
    <td><p>The default location for storing checkpoint data for streaming queries.</p></td>
    <td>2.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.continuous.epochBacklogQueueSize</code></td>
    <td>10000</td>
    <td><p>The max number of entries to be stored in queue to wait for late epochs. If this parameter is exceeded by the size of the queue, stream will stop with an error.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.disabledV2Writers</code></td>
    <td></td>
    <td><p>A comma-separated list of fully qualified data source register class names for which StreamWriteSupport is disabled. Writes to these sources will fall back to the V1 Sinks.</p></td>
    <td>2.3.1</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.fileSource.cleaner.numThreads</code></td>
    <td>1</td>
    <td><p>Number of threads used in the file source completed file cleaner.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.forceDeleteTempCheckpointLocation</code></td>
    <td>false</td>
    <td><p>When true, enable temporary checkpoint locations force delete.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.metricsEnabled</code></td>
    <td>false</td>
    <td><p>Whether Dropwizard/Codahale metrics will be reported for active streaming queries.</p></td>
    <td>2.0.2</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.multipleWatermarkPolicy</code></td>
    <td>min</td>
    <td><p>Policy to calculate the global watermark value when there are multiple watermark operators in a streaming query. The default value is 'min' which chooses the minimum watermark reported across multiple operators. Other alternative value is 'max' which chooses the maximum across multiple operators. Note: This configuration cannot be changed between query restarts from the same checkpoint location.</p></td>
    <td>2.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.noDataMicroBatches.enabled</code></td>
    <td>true</td>
    <td><p>Whether streaming micro-batch engine will execute batches without data for eager state management for stateful streaming queries.</p></td>
    <td>2.4.1</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.numRecentProgressUpdates</code></td>
    <td>100</td>
    <td><p>The number of progress updates to retain for a streaming query</p></td>
    <td>2.1.1</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.sessionWindow.merge.sessions.in.local.partition</code></td>
    <td>false</td>
    <td><p>When true, streaming session window sorts and merge sessions in local partition prior to shuffle. This is to reduce the rows to shuffle, but only beneficial when there're lots of rows in a batch being assigned to same sessions.</p></td>
    <td>3.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.stateStore.stateSchemaCheck</code></td>
    <td>true</td>
    <td><p>When true, Spark will validate the state schema against schema on existing state and fail query if it's incompatible.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.stopActiveRunOnRestart</code></td>
    <td>true</td>
    <td><p>Running multiple runs of the same streaming query concurrently is not supported. If we find a concurrent active run for a streaming query (in the same or different SparkSessions on the same cluster) and this flag is true, we will stop the old streaming query run to start the new one.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.streaming.stopTimeout</code></td>
    <td>0</td>
    <td><p>How long to wait in milliseconds for the streaming execution thread to stop when calling the streaming query's stop() method. 0 or negative values wait indefinitely.</p></td>
    <td>3.0.0</td>
</tr>

<tr>
    <td><code>spark.sql.thriftServer.interruptOnCancel</code></td>
    <td>true</td>
    <td><p>When true, all running tasks will be interrupted if one cancels a query. When false, all running tasks will remain until finished.</p></td>
    <td>3.2.0</td>
</tr>

<tr>
    <td><code>spark.sql.thriftServer.queryTimeout</code></td>
    <td>0ms</td>
    <td><p>Set a query duration timeout in seconds in Thrift Server. If the timeout is set to a positive value, a running query will be cancelled automatically when the timeout is exceeded, otherwise the query continues to run till completion. If timeout values are set for each statement via <code>java.sql.Statement.setQueryTimeout</code> and they are smaller than this configuration value, they take precedence. If you set this timeout and prefer to cancel the queries right away without waiting task to finish, consider enabling spark.sql.thriftServer.interruptOnCancel together.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.thriftserver.scheduler.pool</code></td>
    <td>(none)</td>
    <td><p>Set a Fair Scheduler pool for a JDBC client session.</p></td>
    <td>1.1.1</td>
</tr>

<tr>
    <td><code>spark.sql.thriftserver.ui.retainedSessions</code></td>
    <td>200</td>
    <td><p>The number of SQL client sessions kept in the JDBC/ODBC web UI history.</p></td>
    <td>1.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.thriftserver.ui.retainedStatements</code></td>
    <td>200</td>
    <td><p>The number of SQL statements kept in the JDBC/ODBC web UI history.</p></td>
    <td>1.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.timestampType</code></td>
    <td>TIMESTAMP_LTZ</td>
    <td><p>Configures the default timestamp type of Spark SQL, including SQL DDL, Cast clause, type literal and the schema inference of data sources. Setting the configuration as TIMESTAMP_NTZ will use TIMESTAMP WITHOUT TIME ZONE as the default type while putting it as TIMESTAMP_LTZ will use TIMESTAMP WITH LOCAL TIME ZONE. Before the 3.4.0 release, Spark only supports the TIMESTAMP WITH LOCAL TIME ZONE type.</p></td>
    <td>3.4.0</td>
</tr>

<tr>
    <td><code>spark.sql.tvf.allowMultipleTableArguments.enabled</code></td>
    <td>false</td>
    <td><p>When true, allows multiple table arguments for table-valued functions, receiving the cartesian product of all the rows of these tables.</p></td>
    <td>3.5.0</td>
</tr>

<tr>
    <td><code>spark.sql.ui.explainMode</code></td>
    <td>formatted</td>
    <td><p>Configures the query explain mode used in the Spark SQL UI. The value can be 'simple', 'extended', 'codegen', 'cost', or 'formatted'. The default value is 'formatted'.</p></td>
    <td>3.1.0</td>
</tr>

<tr>
    <td><code>spark.sql.variable.substitute</code></td>
    <td>true</td>
    <td><p>This enables substitution using syntax like <code>${var}</code>, <code>${system:var}</code>, and <code>${env:var}</code>.</p></td>
    <td>2.0.0</td>
</tr>
</table>
